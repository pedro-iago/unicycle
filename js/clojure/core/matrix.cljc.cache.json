["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ ","~$*matrix-implementation*","~$clojure.core.matrix.implementations","~$def-mat-mop","~$clojure.core.matrix","~$def-mat-mops","^8","~$TODO","~$clojure.core.matrix.macros","~$error","^;"],"~:excludes",["~#set",["~$array","~$array?","~$clone"]],"~:name","^8","~:imports",null,"~:requires",["^ ","~$clojure.core.matrix.impl.mathsops","^E","~$mp","~$clojure.core.matrix.protocols","~$clojure.core.matrix.impl.wrappers","^H","~$u","~$clojure.core.matrix.utils","~$wrap","^H","~$clojure.core.matrix.impl.sequence","^K","^6","^6","~$default","~$clojure.core.matrix.impl.defaults","^M","^M","^I","^I","~$mops","^E","~$imp","^6","^G","^G","~$clojure.core.matrix.impl.persistent-vector","^P"],"~:uses",["^ ","^5","^6"],"~:defs",["^ ","~$sparse",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","~:line",341,"~:column",7,"~:end-line",341,"~:end-column",13,"~:arglists",["~#list",["~$quote",["^10",[["~$data"],["~$implementation","^12"]]]]],"~:doc","Coerces an array to a sparse format if possible. Sparse arrays are expected to\n   minimise space usage for zero elements.\n\n   Returns the array unchanged if such coercion is not possible, or if the array is already sparse.","~:top-fn",["^ ","~:variadic",false,"~:max-fixed-arity",2,"~:method-params",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"~:arglists-meta",["^10",[null,null]]]],"^B","~$clojure.core.matrix/sparse","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"~:protocol-impl",null,"^19",["^10",[null,null]],"^X",1,"^W",341,"^Y",341,"^17",2,"~:fn-var",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Coerces an array to a sparse format if possible. Sparse arrays are expected to\n   minimise space usage for zero elements.\n\n   Returns the array unchanged if such coercion is not possible, or if the array is already sparse."],"~$sqrt!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sqrt function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/sqrt!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sqrt function on all elements of an array, using double precision values. Mutates the array in-place."],"~$mset",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",786,"^X",7,"^Y",786,"^Z",11,"^[",["^10",["^11",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$&","~$more"]]]]],"^14","Sets a scalar value in an array at the specified position. Supports any number of dimensions.\n\n   Returns a new matrix and leaves the original unchanged.\n\n   WARNING: performance of this operation may be as high as O(N) where N is the number of elements in\n   the array. Consider using mutable arrays and `mset!` when setting large numbers of individual elements\n   is required.","^15",["^ ","^16",true,"^17",4,"^18",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"]]],"^[",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/mset","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",4,"^18",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"]]],"^[",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",786,"^Y",786,"^17",4,"^1<",true,"^[",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$&","^1@"]]],"^14","Sets a scalar value in an array at the specified position. Supports any number of dimensions.\n\n   Returns a new matrix and leaves the original unchanged.\n\n   WARNING: performance of this operation may be as high as O(N) where N is the number of elements in\n   the array. Consider using mutable arrays and `mset!` when setting large numbers of individual elements\n   is required."],"~$relu!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1971,"^X",7,"^Y",1971,"^Z",12,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the ReLU (rectified linear) function for every element of an array. Mutates the array."],"^B","~$clojure.core.matrix/relu!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1971,"^Y",1971,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the ReLU (rectified linear) function for every element of an array. Mutates the array."],"~$dot",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1768,"^X",7,"^Y",1768,"^Z",10,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Efficiently computes the scalar dot product (1Dx1D inner product) of two numerical vectors. Prefer this API\n   function if you are performing a dot product on 1D vectors and want a scalar result.\n\n   If either argument is not a vector, will compute and return a higher dimensional inner-product."],"^B","~$clojure.core.matrix/dot","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^18",["^10",[["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1768,"^Y",1768,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Efficiently computes the scalar dot product (1Dx1D inner product) of two numerical vectors. Prefer this API\n   function if you are performing a dot product on 1D vectors and want a scalar result.\n\n   If either argument is not a vector, will compute and return a higher dimensional inner-product."],"~$ne",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1363,"^X",7,"^Y",1363,"^Z",9,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Element-wise not-equal comparison operation. Returns a binary array where\n  elements not-equal to the argument are represented by 1 and elements equal to\n  the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (ne 1 1) ;=> 0\n  (ne 5 1) ;=> 1\n  (ne [[1 5] [3 6]] 3) ;=> [[1 1] [0 1]]\n  (ne [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[1 1] [1 0]]"],"^B","~$clojure.core.matrix/ne","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1363,"^Y",1363,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Element-wise not-equal comparison operation. Returns a binary array where\n  elements not-equal to the argument are represented by 1 and elements equal to\n  the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (ne 1 1) ;=> 0\n  (ne 5 1) ;=> 1\n  (ne [[1 5] [3 6]] 3) ;=> [[1 1] [0 1]]\n  (ne [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[1 1] [1 0]]"],"~$index-seq",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2198,"^X",7,"^Y",2198,"^Z",16,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns a sequence of all possible index vectors into an array, in row-major order."],"^B","~$clojure.core.matrix/index-seq","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2198,"^Y",2198,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns a sequence of all possible index vectors into an array, in row-major order."],"~$dense",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",352,"^X",7,"^Y",352,"^Z",12,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Coerces an array to a dense format if possible. Dense arrays are expected to\n   allocate contiguous storage space for all elements. Either row-major or column-major\n   storage may be alloacted, depending on the implementation.\n\n   'dense' should not be used with very large arrays, and may throw an OutOfMemoryError\n    if the dense array is too large to fit in available memory.\n\n   Returns the array unchanged if such coercion is not possible, or if the array is already dense.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/dense","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",352,"^Y",352,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Coerces an array to a dense format if possible. Dense arrays are expected to\n   allocate contiguous storage space for all elements. Either row-major or column-major\n   storage may be alloacted, depending on the implementation.\n\n   'dense' should not be used with very large arrays, and may throw an OutOfMemoryError\n    if the dense array is too large to fit in available memory.\n\n   Returns the array unchanged if such coercion is not possible, or if the array is already dense."],"~$index-seq-for-shape",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2193,"^X",7,"^Y",2193,"^Z",26,"^[",["^10",["^11",["^10",[["~$sh"]]]]],"^14","Returns a sequence of all possible index vectors for a given shape, in row-major order"],"^B","~$clojure.core.matrix/index-seq-for-shape","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",26,"^18",["^10",[["^1M"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2193,"^Y",2193,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["^1M"]]]]],"^14","Returns a sequence of all possible index vectors for a given shape, in row-major order"],"~$negate!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1861,"^X",7,"^Y",1861,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the negation of a numerical array in place. Generally equivalent to (scale! m -1.0)"],"^B","~$clojure.core.matrix/negate!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1861,"^Y",1861,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the negation of a numerical array in place. Generally equivalent to (scale! m -1.0)"],"~$numerical?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",704,"^X",7,"^Y",704,"^Z",17,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the matrix is a valid numerical matrix (i.e. supports numerical core.matrix operations)."],"^B","~$clojure.core.matrix/numerical?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",704,"^Y",704,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the matrix is a valid numerical matrix (i.e. supports numerical core.matrix operations)."],"~$column-matrix?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",615,"^X",7,"^Y",615,"^Z",21,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if a matrix is a column-matrix (i.e. is 2D and has has exactly one column)"],"^B","~$clojure.core.matrix/column-matrix?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",615,"^Y",615,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if a matrix is a column-matrix (i.e. is 2D and has has exactly one column)"],"~$distance",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1833,"^X",7,"^Y",1833,"^Z",15,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Calculates the euclidean distance between two numerical vectors, as a single numerical scalar value.\n\n   This is equivalent to (norm 2 (sub a b)) but may be optimised by the underlying implementation."],"^B","~$clojure.core.matrix/distance","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",15,"^18",["^10",[["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1833,"^Y",1833,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Calculates the euclidean distance between two numerical vectors, as a single numerical scalar value.\n\n   This is equivalent to (norm 2 (sub a b)) but may be optimised by the underlying implementation."],"~$mutable",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",262,"^X",7,"^Y",262,"^Z",14,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Constructs a fully mutable copy of the given array data. \n\n   If the current implementation does not support mutable matrices, will return a mutable array\n   from another core.matrix implementation that supports either the same element type or a broader type.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/mutable","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",262,"^Y",262,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Constructs a fully mutable copy of the given array data. \n\n   If the current implementation does not support mutable matrices, will return a mutable array\n   from another core.matrix implementation that supports either the same element type or a broader type."],"~$diagonal?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",520,"^X",7,"^Y",520,"^Z",16,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a diagonal matrix."],"^B","~$clojure.core.matrix/diagonal?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",520,"^Y",520,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a diagonal matrix."],"~$add-inner-product!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1660,"^X",7,"^Y",1660,"^Z",25,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","~$factor"]]]]],"^14","Adds the inner product of two numerical arrays to the first array.\n   Returns the mutated array.\n   This is equivalent to (add! m (inner-product a b)) but may be optimised by the underlying implementation.","^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/add-inner-product!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",25,"^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1660,"^Y",1660,"^17",4,"^1<",true,"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^14","Adds the inner product of two numerical arrays to the first array.\n   Returns the mutated array.\n   This is equivalent to (add! m (inner-product a b)) but may be optimised by the underlying implementation."],"~$identity-matrix?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",504,"^X",7,"^Y",504,"^Z",23,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is an identity-matrix, i.e. a symmetric square matrix with element values\n   of 1 on the leading diagonal and 0 elsewhere."],"^B","~$clojure.core.matrix/identity-matrix?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",23,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",504,"^Y",504,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is an identity-matrix, i.e. a symmetric square matrix with element values\n   of 1 on the leading diagonal and 0 elsewhere."],"~$to-radians",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-radians function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/to-radians","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-radians function on all elements of an array, using double precision values. Returns a new array."],"~$emap-indexed",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2098,"^X",7,"^Y",2098,"^Z",19,"^[",["^10",["^11",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise map-indexed over all elements of one or more arrays.\n\n   f must accept as first argument the index vector of the current element,\n   and return a result compatible with the element-type of the array m\n\n   Returns a new array of the same element-type and shape as the array m.","^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/emap-indexed","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",2098,"^Y",2098,"^17",3,"^1<",true,"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^14","Element-wise map-indexed over all elements of one or more arrays.\n\n   f must accept as first argument the index vector of the current element,\n   and return a result compatible with the element-type of the array m\n\n   Returns a new array of the same element-type and shape as the array m."],"~$density",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",658,"^X",7,"^Y",658,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the density of the matrix, defined as the proportion of non-zero elements"],"^B","~$clojure.core.matrix/density","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",658,"^Y",658,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the density of the matrix, defined as the proportion of non-zero elements"],"~$new-scalar-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",201,"^X",7,"^Y",201,"^Z",23,"^[",["^10",["^11",["^10",[[],["^13"]]]]],"^14","Returns a new mutable scalar array containing the scalar value zero.","^15",["^ ","^16",false,"^17",1,"^18",["^10",[[],["^13"]]],"^[",["^10",[[],["^13"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/new-scalar-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",23,"^15",["^ ","^16",false,"^17",1,"^18",["^10",[[],["^13"]]],"^[",["^10",[[],["^13"]]],"^19",["^10",[null,null]]],"^18",["^10",[[],["^13"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",201,"^Y",201,"^17",1,"^1<",true,"^[",["^10",[[],["^13"]]],"^14","Returns a new mutable scalar array containing the scalar value zero."],"~$lt",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1287,"^X",7,"^Y",1287,"^Z",9,"^[",["^10",["^11",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise less-than comparison operation. Returns a binary array where\n  elements less-than the argument are represented by 1 and elements greater-\n  than or equal to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (lt 1 4) ;=> 1\n  (lt 3 3) ;=> 0\n  (lt [[1 5] [3 6]] 3) ;=> [[1 0] [0 0]]\n  (lt [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[1 0] [1 0]]","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/lt","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1287,"^Y",1287,"^17",2,"^1<",true,"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^14","Element-wise less-than comparison operation. Returns a binary array where\n  elements less-than the argument are represented by 1 and elements greater-\n  than or equal to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (lt 1 4) ;=> 1\n  (lt 3 3) ;=> 0\n  (lt [[1 5] [3 6]] 3) ;=> [[1 0] [0 0]]\n  (lt [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[1 0] [1 0]]"],"~$emax",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2141,"^X",7,"^Y",2141,"^Z",11,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the maximum element value from a numerical array"],"^B","~$clojure.core.matrix/emax","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2141,"^Y",2141,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the maximum element value from a numerical array"],"~$slice-view",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1011,"^X",7,"^Y",1011,"^Z",17,"^[",["^10",["^11",["^10",[["~$m","~$i"],["~$m","~$dimension","~$i"]]]]],"^14","Gets a view of an array slice. Guaranteed to return a mutable view if the array is mutable.","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","~$i"],["~$m","^2A","~$i"]]],"^[",["^10",[["~$m","~$i"],["~$m","^2A","~$i"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/slice-view","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","~$i"],["~$m","^2A","~$i"]]],"^[",["^10",[["~$m","~$i"],["~$m","^2A","~$i"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$i"],["~$m","^2A","~$i"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1011,"^Y",1011,"^17",3,"^1<",true,"^[",["^10",[["~$m","~$i"],["~$m","^2A","~$i"]]],"^14","Gets a view of an array slice. Guaranteed to return a mutable view if the array is mutable."],"~$orthogonal?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",535,"^X",7,"^Y",535,"^Z",18,"^[",["^10",["^11",["^10",[["~$m","~$eps"],["~$m"]]]]],"^14","Returns true if the parameter is an orthogonal matrix.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m","^2D"],["~$m"]]],"^[",["^10",[["~$m","^2D"],["~$m"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/orthogonal?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m","^2D"],["~$m"]]],"^[",["^10",[["~$m","^2D"],["~$m"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","^2D"],["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",535,"^Y",535,"^17",2,"^1<",true,"^[",["^10",[["~$m","^2D"],["~$m"]]],"^14","Returns true if the parameter is an orthogonal matrix."],"~$le",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1306,"^X",7,"^Y",1306,"^Z",9,"^[",["^10",["^11",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise less-than-or-equal-to comparison operation. Returns a binary\n  array where elements less-than or equal to the argument are represented by 1\n  and elements greater-than to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (le 3 3) ;=> 1\n  (le 4 3) ;=> 0\n  (le [[1 5] [3 6]] 3) ;=> [[1 0] [1 0]]\n  (le [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[1 0] [1 1]]","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/le","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1306,"^Y",1306,"^17",2,"^1<",true,"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^14","Element-wise less-than-or-equal-to comparison operation. Returns a binary\n  array where elements less-than or equal to the argument are represented by 1\n  and elements greater-than to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (le 3 3) ;=> 1\n  (le 4 3) ;=> 0\n  (le [[1 5] [3 6]] 3) ;=> [[1 0] [1 0]]\n  (le [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[1 0] [1 1]]"],"~$add",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1558,"^X",7,"^Y",1558,"^Z",10,"^[",["^10",["^11",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs element-wise addition on one or more numerical arrays.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/add","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",1558,"^Y",1558,"^17",2,"^1<",true,"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs element-wise addition on one or more numerical arrays."],"~$negate",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1856,"^X",7,"^Y",1856,"^Z",13,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the negation of a numerical array. Generally equivalent to (scale m -1.0)"],"^B","~$clojure.core.matrix/negate","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1856,"^Y",1856,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the negation of a numerical array. Generally equivalent to (scale m -1.0)"],"~$asin!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the asin function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/asin!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the asin function on all elements of an array, using double precision values. Mutates the array in-place."],"~$get-column",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",840,"^X",7,"^Y",840,"^Z",17,"^[",["^10",["^11",["^10",[["~$m","~$col-index"]]]]],"^14","Gets a column of a matrix, as a 1D vector.\n\n   The format of the returned 1D vector is determined by the implementation of the source matrix. \n   get-column may return a lightweight mutable view if supported by the implementation."],"^B","~$clojure.core.matrix/get-column","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$m","^2O"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",840,"^Y",840,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^2O"]]]]],"^14","Gets a column of a matrix, as a 1D vector.\n\n   The format of the returned 1D vector is determined by the implementation of the source matrix. \n   get-column may return a lightweight mutable view if supported by the implementation."],"~$cos!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cos function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/cos!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cos function on all elements of an array, using double precision values. Mutates the array in-place."],"~$e=",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1392,"^X",7,"^Y",1392,"^Z",9,"^[",["^10",["^11",["^10",[["~$m1"],["^2T","~$m2"],["^2T","^2U","~$&","^1@"]]]]],"^14","Returns true if all corresponding array elements are equal (using the semantics of clojure.core/=).\n\n   WARNING: a java.lang.Long does not equal a java.lang.Double.\n   Use 'equals' or 'e==' instead if you want to test for numerical equality.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["^2T"],["^2T","^2U"]]],"^[",["^10",[["^2T"],["^2T","^2U"],["^2T","^2U","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/e=","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["^2T"],["^2T","^2U"]]],"^[",["^10",[["^2T"],["^2T","^2U"],["^2T","^2U","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["^2T"],["^2T","^2U"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1392,"^Y",1392,"^17",2,"^1<",true,"^[",["^10",[["^2T"],["^2T","^2U"],["^2T","^2U","~$&","^1@"]]],"^14","Returns true if all corresponding array elements are equal (using the semantics of clojure.core/=).\n\n   WARNING: a java.lang.Long does not equal a java.lang.Double.\n   Use 'equals' or 'e==' instead if you want to test for numerical equality."],"~$sparse-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",328,"^X",7,"^Y",328,"^Z",20,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Creates a sparse matrix with the given data, using a specified implementation\n  or the current implementation if not specified. Sparse matrices are required to store\n  a M*N matrix with E non-zero elements in approx O(M+N+E) space or less.\n\n  Throws an exception if creation of a sparse matrix is not possible.\n\n  `sparse-matrix` wqorks as a synonym for `sparse-array`.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/sparse-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",328,"^Y",328,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Creates a sparse matrix with the given data, using a specified implementation\n  or the current implementation if not specified. Sparse matrices are required to store\n  a M*N matrix with E non-zero elements in approx O(M+N+E) space or less.\n\n  Throws an exception if creation of a sparse matrix is not possible.\n\n  `sparse-matrix` wqorks as a synonym for `sparse-array`."],"~$normalise-arg",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",865,"^X",8,"^Y",865,"^Z",21,"~:private",true,"^[",["^10",["^11",["^10",[["~$arg","~$dim-count"]]]]],"^14","Normalises arg to either a number of a sequable list of indexes"],"^2Z",true,"^B","~$clojure.core.matrix/normalise-arg","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^18",["^10",[["^2[","^30"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",865,"^Y",865,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["^2[","^30"]]]]],"^14","Normalises arg to either a number of a sequable list of indexes"],"~$ceil!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the ceil function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/ceil!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the ceil function on all elements of an array, using double precision values. Mutates the array in-place."],"~$log",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/log","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log function on all elements of an array, using double precision values. Returns a new array."],"~$clamp",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2156,"^X",7,"^Y",2156,"^Z",12,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Clamps each element in a numerical array between lower and upper bounds\n  specified by a and b, respectively.\n\n  Examples:\n  (clamp [[1 5 1] [4 10 2] [5 6 3]] 2 8) ;=> [[2 5 2] [4 8 2] [5 6 3]]\n  "],"^B","~$clojure.core.matrix/clamp","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$m","~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2156,"^Y",2156,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Clamps each element in a numerical array between lower and upper bounds\n  specified by a and b, respectively.\n\n  Examples:\n  (clamp [[1 5 1] [4 10 2] [5 6 3]] 2 8) ;=> [[2 5 2] [4 8 2] [5 6 3]]\n  "],"~$current-implementation-object",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2249,"^X",7,"^Y",2249,"^Z",36,"^[",["^10",["^11",["^10",[[]]]]],"^14","Gets a canonical object for the currently active matrix implementation. This object\n   can be used to pass as an implementation parameter, or to query implementation internals via core.matrix protocols."],"^B","~$clojure.core.matrix/current-implementation-object","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",36,"^18",["^10",[[]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2249,"^Y",2249,"^17",0,"^1<",true,"^[",["^10",["^11",["^10",[[]]]]],"^14","Gets a canonical object for the currently active matrix implementation. This object\n   can be used to pass as an implementation parameter, or to query implementation internals via core.matrix protocols."],"~$acos",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the acos function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/acos","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the acos function on all elements of an array, using double precision values. Returns a new array."],"~$to-degrees",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-degrees function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/to-degrees","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-degrees function on all elements of an array, using double precision values. Returns a new array."],"~$pack",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",743,"^X",7,"^Y",743,"^Z",11,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Packs array data in the most efficient format as defined by the implementation. May return the\n   same array if no additional packing is required."],"^B","~$clojure.core.matrix/pack","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",743,"^Y",743,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Packs array data in the most efficient format as defined by the implementation. May return the\n   same array if no additional packing is required."],"~$floor",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the floor function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/floor","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the floor function on all elements of an array, using double precision values. Returns a new array."],"~$as-vector",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1137,"^X",7,"^Y",1137,"^Z",16,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Creates a view of an array as a single flattened vector.\n\n   Returns nil if this is not supported by the implementation. You should use `to-vector` instead to\n   obtain a flattened vector without guaranteeing a view."],"^B","~$clojure.core.matrix/as-vector","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1137,"^Y",1137,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Creates a view of an array as a single flattened vector.\n\n   Returns nil if this is not supported by the implementation. You should use `to-vector` instead to\n   obtain a flattened vector without guaranteeing a view."],"~$cross",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1815,"^X",7,"^Y",1815,"^Z",12,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Computes the 3D cross-product of two numerical vectors.\n\n   Behavior on other types is undefined."],"^B","~$clojure.core.matrix/cross","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1815,"^Y",1815,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Computes the 3D cross-product of two numerical vectors.\n\n   Behavior on other types is undefined."],"~$identity-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",234,"^X",7,"^Y",234,"^Z",22,"^[",["^10",["^11",["^10",[["~$dims"],["^13","^3G"]]]]],"^14","Constructs a 2D identity matrix with the given number of rows.\n\n   Identity matrices constructed with this function may not be fully mutable because they may be\n   implemented with a specialised identity matrix type. Use (mutable (identity-matrix ...)) if you\n   need to guarantee a mutable matrix.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^3G"],["^13","^3G"]]],"^[",["^10",[["^3G"],["^13","^3G"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/identity-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",22,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^3G"],["^13","^3G"]]],"^[",["^10",[["^3G"],["^13","^3G"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^3G"],["^13","^3G"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",234,"^Y",234,"^17",2,"^1<",true,"^[",["^10",[["^3G"],["^13","^3G"]]],"^14","Constructs a 2D identity matrix with the given number of rows.\n\n   Identity matrices constructed with this function may not be fully mutable because they may be\n   implemented with a specialised identity matrix type. Use (mutable (identity-matrix ...)) if you\n   need to guarantee a mutable matrix."],"~$set-indices",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",937,"^X",7,"^Y",937,"^Z",18,"^[",["^10",["^11",["^10",[["~$a","~$indices","~$values"]]]]],"^14","like select-indices but sets the elements at the specified indices to values.\n   Leaves the original array (a) unchanged and returns a modified array"],"^B","~$clojure.core.matrix/set-indices","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$a","^3J","^3K"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",937,"^Y",937,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","^3J","^3K"]]]]],"^14","like select-indices but sets the elements at the specified indices to values.\n   Leaves the original array (a) unchanged and returns a modified array"],"~$pow!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1910,"^X",7,"^Y",1910,"^Z",11,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Mutable exponent function, see 'pow'"],"^B","~$clojure.core.matrix/pow!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1910,"^Y",1910,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Mutable exponent function, see 'pow'"],"~$index?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",673,"^X",7,"^Y",673,"^Z",13,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a valid array index type. An index is a seq-able 1D list\n   of integer values that can be used to index into arrays."],"^B","~$clojure.core.matrix/index?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",673,"^Y",673,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a valid array index type. An index is a seq-able 1D list\n   of integer values that can be used to index into arrays."],"~$tanh",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tanh function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/tanh","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tanh function on all elements of an array, using double precision values. Returns a new array."],"~$join",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1059,"^X",7,"^Y",1059,"^Z",11,"^[",["^10",["^11",["^10",[["~$&","~$arrays"]]]]],"^14","Joins arrays together, along the major dimension 0. For 1D vectors, this behaves as simple concatenation.\n   Other dimensions must be compatible. To join arrays along a different dimension, use 'join-along' instead.","^15",["^ ","^16",true,"^17",0,"^18",[["^10",["^3T"]]],"^[",["^10",[["~$&","^3T"]]],"^19",["^10",[null]]]],"^B","~$clojure.core.matrix/join","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",0,"^18",[["^10",["^3T"]]],"^[",["^10",[["~$&","^3T"]]],"^19",["^10",[null]]],"^18",[["^10",["^3T"]]],"^1;",null,"^19",["^10",[null]],"^X",1,"^W",1059,"^Y",1059,"^17",0,"^1<",true,"^[",["^10",[["~$&","^3T"]]],"^14","Joins arrays together, along the major dimension 0. For 1D vectors, this behaves as simple concatenation.\n   Other dimensions must be compatible. To join arrays along a different dimension, use 'join-along' instead."],"~$add-scaled-product",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1645,"^X",7,"^Y",1645,"^Z",25,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b","^20"]]]]],"^14","Adds the product of two numerical arrays scaled by a given factor to the first array.\n\n   This is equivalent to (add m (mul a b factor)) but may be optimised by the underlying implementation."],"^B","~$clojure.core.matrix/add-scaled-product","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",25,"^18",["^10",[["~$m","~$a","~$b","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1645,"^Y",1645,"^17",4,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b","^20"]]]]],"^14","Adds the product of two numerical arrays scaled by a given factor to the first array.\n\n   This is equivalent to (add m (mul a b factor)) but may be optimised by the underlying implementation."],"~$dimension-count",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",564,"^X",7,"^Y",564,"^Z",22,"^[",["^10",["^11",["^10",[["~$m","~$dim"]]]]],"^14","Returns the size of the specified dimension in a matrix. Will throw an error if the matrix\n   does not have the specified dimension.","~:inline",["^10",["~$fn",["^10",[["~$m","^3Y"],["^10",["~$clojure.core/sequence",["^10",["~$clojure.core/seq",["^10",["~$clojure.core/concat",["^10",["~$clojure.core/list",["^10",["^11","~$cljs.core/long"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/dimension-count"]]]],["^10",["^43","~$m"]],["^10",["^43","^3Y"]]]]]]]]]]]]]]]]]]]]],"^B","~$clojure.core.matrix/dimension-count","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",22,"^18",["^10",[["~$m","^3Y"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",564,"^Y",564,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^3Y"]]]]],"^14","Returns the size of the specified dimension in a matrix. Will throw an error if the matrix\n   does not have the specified dimension.","^3Z",["^10",["^3[",["^10",[["~$m","^3Y"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^44"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^45"]]]],["^10",["^43","~$m"]],["^10",["^43","^3Y"]]]]]]]]]]]]]]]]]]]]],"~$atan!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the atan function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/atan!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the atan function on all elements of an array, using double precision values. Mutates the array in-place."],"~$set-row",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2016,"^X",7,"^Y",2016,"^Z",14,"^[",["^10",["^11",["^10",[["~$m","~$i","~$row"]]]]],"^14","Sets a row in a matrix using a specified vector."],"^B","~$clojure.core.matrix/set-row","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m","~$i","^4:"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2016,"^Y",2016,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$i","^4:"]]]]],"^14","Sets a row in a matrix using a specified vector."],"~$sub!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1707,"^X",7,"^Y",1707,"^Z",11,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs element-wise mutable subtraction on one or more numerical arrays.\n\n   NOTE: For a single argument, returns the argument unchanged: use negate! instead if you wish to negate a mutable\n   array in place. This is intentional, so that you can do (apply sub! m list-of-arrays) and get the expected\n   result if the list of arrays is empty.\n\n   Returns the first array, after it has been mutated.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/sub!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1707,"^Y",1707,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs element-wise mutable subtraction on one or more numerical arrays.\n\n   NOTE: For a single argument, returns the argument unchanged: use negate! instead if you wish to negate a mutable\n   array in place. This is intentional, so that you can do (apply sub! m list-of-arrays) and get the expected\n   result if the list of arrays is empty.\n\n   Returns the first array, after it has been mutated."],"~$select",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",882,"^X",7,"^Y",882,"^Z",13,"^[",["^10",["^11",["^10",[["~$a","~$&","~$args"]]]]],"^14","Returns an array containing all elements in a which are at the positions\n   of the Cartesian product of args. An argument can be:\n    - a number - slices at this dimension (eliminates the dimension),\n    - a keyword which selects specific slices (:first :last)\n    - a 1-dimensional array of numbers which selects the slices at these indices\n    - a keyword which selects a range of slices (:all :butlast :rest)\n\n   The number of args must match the dimensionality of a.\n\n   Examples:\n   (select [[1 2][3 4]] 0 0) ;=> 1\n   (select [[1 2][3 4]] 0 :all) ;=> [1 2]\n   (select [[1 2][3 4]] [0 1] [0]) ;=> [[1] [3]]\n   (select [[1 2][3 4]] :all 0) ;=> [1 3]","^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]]],"^B","~$clojure.core.matrix/select","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]],"^18",[["^10",["~$a","^4?"]]],"^1;",null,"^19",["^10",[null]],"^X",1,"^W",882,"^Y",882,"^17",1,"^1<",true,"^[",["^10",[["~$a","~$&","^4?"]]],"^14","Returns an array containing all elements in a which are at the positions\n   of the Cartesian product of args. An argument can be:\n    - a number - slices at this dimension (eliminates the dimension),\n    - a keyword which selects specific slices (:first :last)\n    - a 1-dimensional array of numbers which selects the slices at these indices\n    - a keyword which selects a range of slices (:all :butlast :rest)\n\n   The number of args must match the dimensionality of a.\n\n   Examples:\n   (select [[1 2][3 4]] 0 0) ;=> 1\n   (select [[1 2][3 4]] 0 :all) ;=> [1 2]\n   (select [[1 2][3 4]] [0 1] [0]) ;=> [[1] [3]]\n   (select [[1 2][3 4]] :all 0) ;=> [1 3]"],"~$add-scaled!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1639,"^X",7,"^Y",1639,"^Z",18,"^[",["^10",["^11",["^10",[["~$m","~$a","^20"]]]]],"^14","Adds a numerical array scaled by a given factor to the first array. Returns the mutated array."],"^B","~$clojure.core.matrix/add-scaled!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$m","~$a","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1639,"^Y",1639,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","^20"]]]]],"^14","Adds a numerical array scaled by a given factor to the first array. Returns the mutated array."],"~$new-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",160,"^X",7,"^Y",160,"^Z",17,"^[",["^10",["^11",["^10",[["~$rows","~$columns"],["^13","^4D","^4E"]]]]],"^14","Constructs a new 2D array (matrix) with the given dimensions.\n   The new matrix will contain default values as defined by the implementation (usually null or zero).\n   If the implementation supports mutable matrices, then the new matrix will be fully mutable.","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^[",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/new-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^[",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",160,"^Y",160,"^17",3,"^1<",true,"^[",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^14","Constructs a new 2D array (matrix) with the given dimensions.\n   The new matrix will contain default values as defined by the implementation (usually null or zero).\n   If the implementation supports mutable matrices, then the new matrix will be fully mutable."],"~$shift",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1116,"^X",7,"^Y",1116,"^Z",12,"^[",["^10",["^11",["^10",[["~$m","^2A","~$shift-amount"],["~$m","~$shifts"]]]]],"^14","Shifts all elements of an array along specified dimensions, maintaining the shape of the array.\n\n   New spaces shifted into the array are filled with zero.","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^[",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/shift","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^[",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1116,"^Y",1116,"^17",3,"^1<",true,"^[",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^14","Shifts all elements of an array along specified dimensions, maintaining the shape of the array.\n\n   New spaces shifted into the array are filled with zero."],"~$to-radians!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-radians function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/to-radians!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-radians function on all elements of an array, using double precision values. Mutates the array in-place."],"~$softplus",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1955,"^X",7,"^Y",1955,"^Z",15,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softplus function for every element of an array."],"^B","~$clojure.core.matrix/softplus","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",15,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1955,"^Y",1955,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softplus function for every element of an array."],"~$ceil",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the ceil function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/ceil","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the ceil function on all elements of an array, using double precision values. Returns a new array."],"~$to-vector",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1145,"^X",7,"^Y",1145,"^Z",16,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Creates a new array representing the elements of array m as a single flattened vector.\n\n   This operation guarantees a new copy of the data."],"^B","~$clojure.core.matrix/to-vector","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1145,"^Y",1145,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Creates a new array representing the elements of array m as a single flattened vector.\n\n   This operation guarantees a new copy of the data."],"~$emap!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2166,"^X",7,"^Y",2166,"^Z",12,"^[",["^10",["^11",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise map of a function f over all elements of one or more arrays.\n\n   f must return a result compatible with the element-type of the array m\n\n   Performs in-place modification of the first array argument.","^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/emap!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",2166,"^Y",2166,"^17",3,"^1<",true,"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^14","Element-wise map of a function f over all elements of one or more arrays.\n\n   f must return a result compatible with the element-type of the array m\n\n   Performs in-place modification of the first array argument."],"~$abs!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the abs function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/abs!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the abs function on all elements of an array, using double precision values. Mutates the array in-place."],"~$labels",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1426,"^X",7,"^Y",1426,"^Z",13,"^[",["^10",["^11",["^10",[["~$m","^3Y"]]]]],"^14","Return a vector of labels for a given array dimension. Return nil if the dimension is unlabelled."],"^B","~$clojure.core.matrix/labels","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["~$m","^3Y"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1426,"^Y",1426,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^3Y"]]]]],"^14","Return a vector of labels for a given array dimension. Return nil if the dimension is unlabelled."],"~$zero-count",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",650,"^X",7,"^Y",650,"^Z",17,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of zeros in an array.\n\n   Result will usually be a Long, however callers should note that for very large sparse arrays\n   the zero count may be a BigInteger, i.e. equal to or larger than 2^63."],"^B","~$clojure.core.matrix/zero-count","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",650,"^Y",650,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of zeros in an array.\n\n   Result will usually be a Long, however callers should note that for very large sparse arrays\n   the zero count may be a BigInteger, i.e. equal to or larger than 2^63."],"~$swap-rows",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1992,"^X",7,"^Y",1992,"^Z",16,"^[",["^10",["^11",["^10",[["~$m","~$i","~$j"]]]]],"^14","Swap row i with row j in a matrix, returning a new matrix\n\n   This is one of the three elementary row operation (see https://en.wikipedia.org/wiki/Elementary_matrix)."],"^B","~$clojure.core.matrix/swap-rows","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m","~$i","~$j"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1992,"^Y",1992,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$i","~$j"]]]]],"^14","Swap row i with row j in a matrix, returning a new matrix\n\n   This is one of the three elementary row operation (see https://en.wikipedia.org/wiki/Elementary_matrix)."],"~$e*",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1474,"^X",7,"^Y",1474,"^Z",9,"^[",["^10",["^11",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","An element-wise multiply operator equivalent to `mul`.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/e*","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",1474,"^Y",1474,"^17",2,"^1<",true,"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","An element-wise multiply operator equivalent to `mul`."],"~$conjoin",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1074,"^X",7,"^Y",1074,"^Z",14,"^[",["^10",["^11",["^10",[["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Adds a new value [b] as a new slice to an array [a], returning the extended array.\n   Broadcasts the new value to the correct shape of a slice of a if necessary.\n\n   This can be considered as the array equivalent of clojure.core/conj","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a","~$b"]]],"^[",["^10",[["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/conjoin","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a","~$b"]]],"^[",["^10",[["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1074,"^Y",1074,"^17",2,"^1<",true,"^[",["^10",[["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Adds a new value [b] as a new slice to an array [a], returning the extended array.\n   Broadcasts the new value to the correct shape of a slice of a if necessary.\n\n   This can be considered as the array equivalent of clojure.core/conj"],"~$block-diagonal-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",254,"^X",7,"^Y",254,"^Z",28,"^[",["^10",["^11",["^10",[["~$blocks"],["^13","^56"]]]]],"^14","Constructs a block diagonal matrix for a given vector of 2D square matrices and arranges\n  the matrices along the main diagonal of the 2D matrix","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^56"],["^13","^56"]]],"^[",["^10",[["^56"],["^13","^56"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/block-diagonal-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",28,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^56"],["^13","^56"]]],"^[",["^10",[["^56"],["^13","^56"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^56"],["^13","^56"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",254,"^Y",254,"^17",2,"^1<",true,"^[",["^10",[["^56"],["^13","^56"]]],"^14","Constructs a block diagonal matrix for a given vector of 2D square matrices and arranges\n  the matrices along the main diagonal of the 2D matrix"],"~$multiply-row",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1999,"^X",7,"^Y",1999,"^Z",19,"^[",["^10",["^11",["^10",[["~$m","~$i","^20"]]]]],"^14","Multiply row i in a matrix by a constant factor, returning a new matrix\n\n   This is one of the three elementary row operation (see https://en.wikipedia.org/wiki/Elementary_matrix)."],"^B","~$clojure.core.matrix/multiply-row","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^18",["^10",[["~$m","~$i","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1999,"^Y",1999,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$i","^20"]]]]],"^14","Multiply row i in a matrix by a constant factor, returning a new matrix\n\n   This is one of the three elementary row operation (see https://en.wikipedia.org/wiki/Elementary_matrix)."],"~$log!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/log!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log function on all elements of an array, using double precision values. Mutates the array in-place."],"~$supports-shape?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",405,"^X",7,"^Y",405,"^Z",22,"^[",["^10",["^11",["^10",[["~$m","~$shape"]]]]],"^14","Returns true if the implementation supports creation of matrices with a specific shape."],"^B","~$clojure.core.matrix/supports-shape?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",22,"^18",["^10",[["~$m","^5="]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",405,"^Y",405,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^5="]]]]],"^14","Returns true if the implementation supports creation of matrices with a specific shape."],"~$eseq",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2061,"^X",7,"^Y",2061,"^Z",11,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns all elements of an array as a Clojure sequence in row-major order.\n   \n   Like clojure.core/seq, Returns nil if the array has no elements."],"^B","~$clojure.core.matrix/eseq","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2061,"^Y",2061,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns all elements of an array as a Clojure sequence in row-major order.\n   \n   Like clojure.core/seq, Returns nil if the array has no elements."],"~$label-index",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1431,"^X",7,"^Y",1431,"^Z",18,"^[",["^10",["^11",["^10",[["~$m","^3Y","~$label"]]]]],"^14","Return the index of a label along a given dimension. Returns nil if the label does not exist."],"^B","~$clojure.core.matrix/label-index","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$m","^3Y","^5B"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1431,"^Y",1431,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^3Y","^5B"]]]]],"^14","Return the index of a label along a given dimension. Returns nil if the label does not exist."],"~$new-vector",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",142,"^X",7,"^Y",142,"^Z",17,"^[",["^10",["^11",["^10",[["~$length"],["^13","^5E"]]]]],"^14","Constructs a new vector with the given length.\n   New matrix will contain default values as defined by the implementation (usually null or zero).\n   If the implementation supports mutable vectors, then the new vector will be fully mutable.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5E"],["^13","^5E"]]],"^[",["^10",[["^5E"],["^13","^5E"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/new-vector","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5E"],["^13","^5E"]]],"^[",["^10",[["^5E"],["^13","^5E"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^5E"],["^13","^5E"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",142,"^Y",142,"^17",2,"^1<",true,"^[",["^10",[["^5E"],["^13","^5E"]]],"^14","Constructs a new vector with the given length.\n   New matrix will contain default values as defined by the implementation (usually null or zero).\n   If the implementation supports mutable vectors, then the new vector will be fully mutable."],"~$transpose!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1198,"^X",7,"^Y",1198,"^Z",17,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Transposes a square 2D matrix in-place.\n\n   Will throw an exception if not possible (e.g. if the matrix is not square or not mutable)."],"^B","~$clojure.core.matrix/transpose!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1198,"^Y",1198,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Transposes a square 2D matrix in-place.\n\n   Will throw an exception if not possible (e.g. if the matrix is not square or not mutable)."],"~$mget",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$m"],["~$m","~$x"],["~$m","~$x","~$y"]]],"^[",["^10",[["~$m"],["~$m","~$x"],["~$m","~$x","~$y"],["~$m","~$x","~$y","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"~:inline-arities",["^>",[1,3,2]],"^X",7,"^W",770,"^Y",770,"^[",["^10",["^11",["^10",[["~$m"],["~$m","~$x"],["~$m","~$x","~$y"],["~$m","~$x","~$y","~$&","^1@"]]]]],"^14","Gets a scalar value from an array at the specified position. Supports any number of dimensions.","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/get-0d"]]]],["^10",["^43","~$m"]]]]]]]]]],["^10",[["~$m","~$x"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/get-1d"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]]]]]]]]]],["^10",[["~$m","~$x","~$y"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/get-2d"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]],["^10",["^43","~$y"]]]]]]]]]]]]],"^B","~$clojure.core.matrix/mget","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$m"],["~$m","~$x"],["~$m","~$x","~$y"]]],"^[",["^10",[["~$m"],["~$m","~$x"],["~$m","~$x","~$y"],["~$m","~$x","~$y","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[["~$m"],["~$m","~$x"],["~$m","~$x","~$y"]]],"^5J",["^>",[1,3,2]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",770,"^Y",770,"^17",3,"^1<",true,"^[",["^10",[["~$m"],["~$m","~$x"],["~$m","~$x","~$y"],["~$m","~$x","~$y","~$&","^1@"]]],"^14","Gets a scalar value from an array at the specified position. Supports any number of dimensions.","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^5K"]]]],["^10",["^43","~$m"]]]]]]]]]],["^10",[["~$m","~$x"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^5L"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]]]]]]]]]],["^10",[["~$m","~$x","~$y"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^5M"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]],["^10",["^43","~$y"]]]]]]]]]]]]],"~$atan",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the atan function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/atan","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the atan function on all elements of an array, using double precision values. Returns a new array."],"~$cosh!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cosh function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/cosh!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cosh function on all elements of an array, using double precision values. Mutates the array in-place."],"~$ge",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1344,"^X",7,"^Y",1344,"^Z",9,"^[",["^10",["^11",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise greater-than-or-equal-to comparison operation. Returns a binary\n  array where elements greater-than or equal to the argument are represented by 1\n  and elements less-than to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (ge 2 3) ;=> 0\n  (ge 3 3) ;=> 1\n  (ge [[1 5] [3 6]] 3) ;=> [[0 1] [1 1]]\n  (ge [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[0 1] [0 1]]","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/ge","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1344,"^Y",1344,"^17",2,"^1<",true,"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^14","Element-wise greater-than-or-equal-to comparison operation. Returns a binary\n  array where elements greater-than or equal to the argument are represented by 1\n  and elements less-than to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (ge 2 3) ;=> 0\n  (ge 3 3) ;=> 1\n  (ge [[1 5] [3 6]] 3) ;=> [[0 1] [1 1]]\n  (ge [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[0 1] [0 1]]"],"~$ensure-mutable",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",290,"^X",7,"^Y",290,"^Z",21,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Checks if an array is mutable, and if not converts to a new mutable array. Guarantees\n   that the result will be mutable, but may not be the same type as the original array."],"^B","~$clojure.core.matrix/ensure-mutable","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",290,"^Y",290,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Checks if an array is mutable, and if not converts to a new mutable array. Guarantees\n   that the result will be mutable, but may not be the same type as the original array."],"~$slice-views",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",997,"^X",7,"^Y",997,"^Z",18,"^[",["^10",["^11",["^10",[["~$m"],["~$m","^2A"]]]]],"^14","Gets a sequence of views of the slices of an array. If dimension is supplied, slices along a given dimension,\n   otherwise slices along the first dimension. If the matrix implementation supports mutable views, these views\n   can be used to mutate portions of the original array.\n\n   A key difference between 'slices' and 'slice-views' is that 'slice-views' must always return views. In order\n   to ensure this behaviour on mutable 1-dimensional arrays, it must return a sequence of 0-dimensional arrays.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^2A"]]],"^[",["^10",[["~$m"],["~$m","^2A"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/slice-views","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^2A"]]],"^[",["^10",[["~$m"],["~$m","^2A"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m"],["~$m","^2A"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",997,"^Y",997,"^17",2,"^1<",true,"^[",["^10",[["~$m"],["~$m","^2A"]]],"^14","Gets a sequence of views of the slices of an array. If dimension is supplied, slices along a given dimension,\n   otherwise slices along the first dimension. If the matrix implementation supports mutable views, these views\n   can be used to mutate portions of the original array.\n\n   A key difference between 'slices' and 'slice-views' is that 'slice-views' must always return views. In order\n   to ensure this behaviour on mutable 1-dimensional arrays, it must return a sequence of 0-dimensional arrays."],"~$diagonal-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",296,"^X",7,"^Y",296,"^Z",22,"^[",["^10",["^11",["^10",[["~$diagonal-values"],["^13","^5Z"]]]]],"^14","Constructs a 2D diagonal matrix with the given numerical values on the main diagonal.\n   All off-diagonal elements will be zero, and diagonal-values may be a vector or any\n  Clojure sequence of values.\n\n   Diagonal matrices constructed this way may use specialised storage formats, hence may not be fully mutable.\n   Use (mutable (diagonal-matrix ...)) if you need to guarantee a mutable matrix.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5Z"],["^13","^5Z"]]],"^[",["^10",[["^5Z"],["^13","^5Z"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/diagonal-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",22,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5Z"],["^13","^5Z"]]],"^[",["^10",[["^5Z"],["^13","^5Z"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^5Z"],["^13","^5Z"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",296,"^Y",296,"^17",2,"^1<",true,"^[",["^10",[["^5Z"],["^13","^5Z"]]],"^14","Constructs a 2D diagonal matrix with the given numerical values on the main diagonal.\n   All off-diagonal elements will be zero, and diagonal-values may be a vector or any\n  Clojure sequence of values.\n\n   Diagonal matrices constructed this way may use specialised storage formats, hence may not be fully mutable.\n   Use (mutable (diagonal-matrix ...)) if you need to guarantee a mutable matrix."],"~$set-inner-product!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1684,"^X",7,"^Y",1684,"^Z",25,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]]]],"^14","Sets an array equal to the inner product of two numerical arrays.\n   Returns the mutated first array.\n   This is equivalent to (assign! m (inner-product a b)) but may be optimised by the underlying implementation.","^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/set-inner-product!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",25,"^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1684,"^Y",1684,"^17",4,"^1<",true,"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^14","Sets an array equal to the inner product of two numerical arrays.\n   Returns the mutated first array.\n   This is equivalent to (assign! m (inner-product a b)) but may be optimised by the underlying implementation."],"~$sin!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sin function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/sin!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sin function on all elements of an array, using double precision values. Mutates the array in-place."],"~$mutable?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",665,"^X",7,"^Y",665,"^Z",15,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the matrix is mutable, i.e. supports setting of values.\n\n   It is possible for some matrix implementations to have constraints on mutability (e.g. mutable only in diagonal elements),\n   this method will still return true for such cases."],"^B","~$clojure.core.matrix/mutable?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",15,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",665,"^Y",665,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the matrix is mutable, i.e. supports setting of values.\n\n   It is possible for some matrix implementations to have constraints on mutability (e.g. mutable only in diagonal elements),\n   this method will still return true for such cases."],"~$normalise!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1761,"^X",7,"^Y",1761,"^Z",17,"^[",["^10",["^11",["^10",[["~$v"]]]]],"^14","Like 'normalise', but mutates a numerical vector in-place (scales to unit length).\n   Returns the modified vector."],"^B","~$clojure.core.matrix/normalise!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$v"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1761,"^Y",1761,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$v"]]]]],"^14","Like 'normalise', but mutates a numerical vector in-place (scales to unit length).\n   Returns the modified vector."],"~$scalar-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",209,"^X",7,"^Y",209,"^Z",19,"^[",["^10",["^11",["^10",[["~$value"],["^13","^69"]]]]],"^14","Creates a new zero-dimensional array containing the specified scalar value.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^69"],["^13","^69"]]],"^[",["^10",[["^69"],["^13","^69"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/scalar-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^69"],["^13","^69"]]],"^[",["^10",[["^69"],["^13","^69"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^69"],["^13","^69"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",209,"^Y",209,"^17",2,"^1<",true,"^[",["^10",[["^69"],["^13","^69"]]],"^14","Creates a new zero-dimensional array containing the specified scalar value."],"~$supports-dimensionality?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",398,"^X",7,"^Y",398,"^Z",31,"^[",["^10",["^11",["^10",[["~$m","^3X"]]]]],"^14","Returns true if the implementation for a given matrix supports a specific dimensionality, i.e.\n   can natively create and manipulate matrices with the given number of dimensions"],"^B","~$clojure.core.matrix/supports-dimensionality?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",31,"^18",["^10",[["~$m","^3X"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",398,"^Y",398,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^3X"]]]]],"^14","Returns true if the implementation for a given matrix supports a specific dimensionality, i.e.\n   can natively create and manipulate matrices with the given number of dimensions"],"~$transform",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1539,"^X",7,"^Y",1539,"^Z",16,"^[",["^10",["^11",["^10",[["~$t","~$v"]]]]],"^14","Transforms a given vector with a transformation, returning a new vector.\n\n   The transformation may be a 2D matrix, but other types of transformation may also be supported\n   e.g. affine transformations, unary operators."],"^B","~$clojure.core.matrix/transform","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$t","~$v"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1539,"^Y",1539,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$t","~$v"]]]]],"^14","Transforms a given vector with a transformation, returning a new vector.\n\n   The transformation may be a 2D matrix, but other types of transformation may also be supported\n   e.g. affine transformations, unary operators."],"~$softmax",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1977,"^X",7,"^Y",1977,"^Z",14,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softmax function for a numerical vector."],"^B","~$clojure.core.matrix/softmax","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1977,"^Y",1977,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softmax function for a numerical vector."],"~$set-selection",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",929,"^X",7,"^Y",929,"^Z",20,"^[",["^10",["^11",["^10",[["~$a","~$&","^4?"]]]]],"^14","Like select but sets the elements in the selection to the value of the final argument.\n   Leaves a unchanged and returns the modified array","^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]]],"^B","~$clojure.core.matrix/set-selection","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]],"^18",[["^10",["~$a","^4?"]]],"^1;",null,"^19",["^10",[null]],"^X",1,"^W",929,"^Y",929,"^17",1,"^1<",true,"^[",["^10",[["~$a","~$&","^4?"]]],"^14","Like select but sets the elements in the selection to the value of the final argument.\n   Leaves a unchanged and returns the modified array"],"~$column-count",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",577,"^X",7,"^Y",577,"^Z",19,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of columns in a matrix (array must be 2D or more)","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^46"]]]],["^10",["^43","~$m"]],["^10",["^43",1]]]]]]]]]]]]],"^B","~$clojure.core.matrix/column-count","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",577,"^Y",577,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of columns in a matrix (array must be 2D or more)","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^46"]]]],["^10",["^43","~$m"]],["^10",["^43",1]]]]]]]]]]]]],"~$logistic",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1944,"^X",7,"^Y",1944,"^Z",15,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the sigmoid (logistic) function for every element of an array."],"^B","~$clojure.core.matrix/logistic","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",15,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1944,"^Y",1944,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the sigmoid (logistic) function for every element of an array."],"~$mmul",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1461,"^X",7,"^Y",1461,"^Z",11,"^[",["^10",["^11",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs matrix multiplication on matrices or vectors. Equivalent to\n  inner-product when applied to vectors.  Will treat a 1D vector roughly as a\n  1xN matrix (row vector) when it's the first argument, or as an Nx1 matrix\n  (column vector) when it's the second argument--except that the dimensionality\n  of the result will be different from what it would be with matrix arguments.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/mmul","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",1461,"^Y",1461,"^17",2,"^1<",true,"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs matrix multiplication on matrices or vectors. Equivalent to\n  inner-product when applied to vectors.  Will treat a 1D vector roughly as a\n  1xN matrix (row vector) when it's the first argument, or as an Nx1 matrix\n  (column vector) when it's the second argument--except that the dimensionality\n  of the result will be different from what it would be with matrix arguments."],"~$cos",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cos function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/cos","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cos function on all elements of an array, using double precision values. Returns a new array."],"~$non-zero-indices",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2048,"^X",7,"^Y",2048,"^Z",23,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the non-zero indices of an array.\n   - For a 1D vector, returns an ordered index list.\n   - For a higher dimensional array, returns the non-zero-indices for each slice in row-major order."],"^B","~$clojure.core.matrix/non-zero-indices","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",23,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2048,"^Y",2048,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the non-zero indices of an array.\n   - For a 1D vector, returns an ordered index list.\n   - For a higher dimensional array, returns the non-zero-indices for each slice in row-major order."],"~$log10",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log10 function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/log10","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log10 function on all elements of an array, using double precision values. Returns a new array."],"~$tan",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tan function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/tan","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tan function on all elements of an array, using double precision values. Returns a new array."],"~$cbrt",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cbrt function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/cbrt","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cbrt function on all elements of an array, using double precision values. Returns a new array."],"~$eq",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1378,"^X",7,"^Y",1378,"^Z",9,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Element-wise equal comparison operation. Returns a binary\narray where elements equal to the argument are represented by 1 and\nelements not-equal to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (eq 1 1) ;=> 1\n  (eq 5 1) ;=> 0\n  (eq [[1 5] [3 6]] 3) ;=> [[0 0] [1 0]]\n  (eq [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[0 0] [0 1]]"],"^B","~$clojure.core.matrix/eq","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1378,"^Y",1378,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Element-wise equal comparison operation. Returns a binary\narray where elements equal to the argument are represented by 1 and\nelements not-equal to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (eq 1 1) ;=> 1\n  (eq 5 1) ;=> 0\n  (eq [[1 5] [3 6]] 3) ;=> [[0 0] [1 0]]\n  (eq [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[0 0] [0 1]]"],"~$index",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",109,"^X",7,"^Y",109,"^Z",12,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Constructs a new 1-dimensional integer index from given data.\n\n   The data may be in one of the following forms:\n   - A valid existing index\n   - A 1D array of integer values\n   - A sequence of integer values\n\n   If implementation is not specified, uses the current matrix library as specified\n   in *matrix-implementation* to produce the index object.\n\n   If the implementation does not support its own native index types, will return a\n   valid index from a default implementation.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/index","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",109,"^Y",109,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Constructs a new 1-dimensional integer index from given data.\n\n   The data may be in one of the following forms:\n   - A valid existing index\n   - A 1D array of integer values\n   - A sequence of integer values\n\n   If implementation is not specified, uses the current matrix library as specified\n   in *matrix-implementation* to produce the index object.\n\n   If the implementation does not support its own native index types, will return a\n   valid index from a default implementation."],"~$emul!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1525,"^X",27,"^Y",1525,"^Z",32,"~:deprecated",true,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs in-place element-wise multiplication of numerical arrays.\n\n   Returns the first argument after mutation.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/emul!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",32,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1525,"^6X",true,"^Y",1525,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs in-place element-wise multiplication of numerical arrays.\n\n   Returns the first argument after mutation."],"~$diagonal",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1042,"^X",7,"^Y",1042,"^Z",15,"^[",["^10",["^11",["^10",[["~$m"],["~$m","~$k"]]]]],"^14","Returns the specified diagonal of a 2D matrix as a vector.\n   If k>0, returns a diagonal above the main diagonal.\n   If k<0, returns a diagonal below the main diagonal.\n   Works on both square and rectangular matrices.\n   Returns empty vector if value of k is out of range (outside matrix)","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","~$k"]]],"^[",["^10",[["~$m"],["~$m","~$k"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/diagonal","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",15,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","~$k"]]],"^[",["^10",[["~$m"],["~$m","~$k"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m"],["~$m","~$k"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1042,"^Y",1042,"^17",2,"^1<",true,"^[",["^10",[["~$m"],["~$m","~$k"]]],"^14","Returns the specified diagonal of a 2D matrix as a vector.\n   If k>0, returns a diagonal above the main diagonal.\n   If k<0, returns a diagonal below the main diagonal.\n   Works on both square and rectangular matrices.\n   Returns empty vector if value of k is out of range (outside matrix)"],"~$softmax!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1982,"^X",7,"^Y",1982,"^Z",15,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softmax function for every element of a numerical vector. Mutates the vector."],"^B","~$clojure.core.matrix/softmax!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",15,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1982,"^Y",1982,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softmax function for every element of a numerical vector. Mutates the vector."],"~$submatrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",952,"^X",7,"^Y",952,"^Z",16,"^[",["^10",["^11",["^10",[["~$m","~$index-ranges"],["~$m","^2A","~$index-range"],["~$m","~$row-start","~$row-length","~$col-start","~$col-length"]]]]],"^14","Gets a view of a submatrix, for a set of index ranges.\n   \n   If Index ranges are used they must be a sequence [start, length] pairs,\n   with the special exception that these pairs can be nil (gets the whole range).\n\n   May be a mutable view if supported by the implementation.","^15",["^ ","^16",false,"^17",5,"^18",["^10",[["~$m","^73"],["~$m","^2A","^74"],["~$m","^75","^76","^77","^78"]]],"^[",["^10",[["~$m","^73"],["~$m","^2A","^74"],["~$m","^75","^76","^77","^78"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/submatrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^15",["^ ","^16",false,"^17",5,"^18",["^10",[["~$m","^73"],["~$m","^2A","^74"],["~$m","^75","^76","^77","^78"]]],"^[",["^10",[["~$m","^73"],["~$m","^2A","^74"],["~$m","^75","^76","^77","^78"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$m","^73"],["~$m","^2A","^74"],["~$m","^75","^76","^77","^78"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",952,"^Y",952,"^17",5,"^1<",true,"^[",["^10",[["~$m","^73"],["~$m","^2A","^74"],["~$m","^75","^76","^77","^78"]]],"^14","Gets a view of a submatrix, for a set of index ranges.\n   \n   If Index ranges are used they must be a sequence [start, length] pairs,\n   with the special exception that these pairs can be nil (gets the whole range).\n\n   May be a mutable view if supported by the implementation."],"~$set-current-implementation",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2254,"^X",7,"^Y",2254,"^Z",33,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Sets the currently active core.matrix implementation.\n\n   Parameter may be\n    - A known keyword for the implementation e.g. :vectorz\n    - An existing instance from the implementation\n\n   Throws an exception if the implementation cannot be loaded.\n\n   This is used primarily for functions that construct new matrices, i.e. it determines the\n   implementation used for expressions like: (matrix [[1 2] [3 4]])"],"^B","~$clojure.core.matrix/set-current-implementation","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",33,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2254,"^Y",2254,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Sets the currently active core.matrix implementation.\n\n   Parameter may be\n    - A known keyword for the implementation e.g. :vectorz\n    - An existing instance from the implementation\n\n   Throws an exception if the implementation cannot be loaded.\n\n   This is used primarily for functions that construct new matrices, i.e. it determines the\n   implementation used for expressions like: (matrix [[1 2] [3 4]])"],"~$add!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1567,"^X",7,"^Y",1567,"^Z",11,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs element-wise mutable addition on one or more numerical arrays. This is the mutable\n   equivalent of `add`.\n\n   All arguments after the first must be broadcastable to the shape of the first array.\n\n   When adding many arrays, use of `add!` with a mutable array as the first argument is\n   usually faster than repreated use of `add` because it can avoid unnecessary copying.\n\n   Returns the first array after it has been mutated.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/add!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1567,"^Y",1567,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs element-wise mutable addition on one or more numerical arrays. This is the mutable\n   equivalent of `add`.\n\n   All arguments after the first must be broadcastable to the shape of the first array.\n\n   When adding many arrays, use of `add!` with a mutable array as the first argument is\n   usually faster than repreated use of `add` because it can avoid unnecessary copying.\n\n   Returns the first array after it has been mutated."],"~$tan!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tan function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/tan!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tan function on all elements of an array, using double precision values. Mutates the array in-place."],"~$lerp!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1632,"^X",7,"^Y",1632,"^Z",12,"^[",["^10",["^11",["^10",[["~$a","~$b","^20"]]]]],"^14","Performs linear interpolation between two arrays. If factor is 0.0, result will be equal to the first vector.\n   If factor is 1.0, result will be equal to the second vector. Returns a the mutated first array."],"^B","~$clojure.core.matrix/lerp!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$a","~$b","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1632,"^Y",1632,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","~$b","^20"]]]]],"^14","Performs linear interpolation between two arrays. If factor is 0.0, result will be equal to the first vector.\n   If factor is 1.0, result will be equal to the second vector. Returns a the mutated first array."],"~$set-indices!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",943,"^X",7,"^Y",943,"^Z",19,"^[",["^10",["^11",["^10",[["~$a","^3J","^3K"]]]]],"^14","like set-indices but destructively modifies array in place"],"^B","~$clojure.core.matrix/set-indices!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^18",["^10",[["~$a","^3J","^3K"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",943,"^Y",943,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","^3J","^3K"]]]]],"^14","like set-indices but destructively modifies array in place"],"~$sub",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1695,"^X",7,"^Y",1695,"^Z",10,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs element-wise subtraction on one or more numerical arrays.\n\n   For a single argument, returns the negation.\n\n   Returns a new array.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/sub","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1695,"^Y",1695,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs element-wise subtraction on one or more numerical arrays.\n\n   For a single argument, returns the negation.\n\n   Returns a new array."],"~$add-row",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2006,"^X",7,"^Y",2006,"^Z",14,"^[",["^10",["^11",["^10",[["~$m","~$i","~$j"],["~$m","~$i","~$j","^20"]]]]],"^14","Add a row j (optionally multiplied by a scalar factor) to a row i\n   and replace row i with the result. Returns a new matrix.\n\n   This is one of the three elementary row operation (see https://en.wikipedia.org/wiki/Elementary_matrix).","^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$i","~$j"],["~$m","~$i","~$j","^20"]]],"^[",["^10",[["~$m","~$i","~$j"],["~$m","~$i","~$j","^20"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/add-row","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$i","~$j"],["~$m","~$i","~$j","^20"]]],"^[",["^10",[["~$m","~$i","~$j"],["~$m","~$i","~$j","^20"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$i","~$j"],["~$m","~$i","~$j","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2006,"^Y",2006,"^17",4,"^1<",true,"^[",["^10",[["~$m","~$i","~$j"],["~$m","~$i","~$j","^20"]]],"^14","Add a row j (optionally multiplied by a scalar factor) to a row i\n   and replace row i with the result. Returns a new matrix.\n\n   This is one of the three elementary row operation (see https://en.wikipedia.org/wiki/Elementary_matrix)."],"~$slice-dims",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",848,"^X",8,"^Y",848,"^Z",18,"^2Z",true,"^[",["^10",["^11",["^10",[["~$m","^4?","~$slice-func"]]]]],"^14","Slices along all dimensions where there is a numerical argument"],"^2Z",true,"^B","~$clojure.core.matrix/slice-dims","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$m","^4?","^7I"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",848,"^Y",848,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^4?","^7I"]]]]],"^14","Slices along all dimensions where there is a numerical argument"],"~$column-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",225,"^X",7,"^Y",225,"^Z",20,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Constructs a column matrix with the given data. The returned matrix is a 2D Nx1 column matrix.\n\n   The data must be either a valid existing vector or a sequence of scalar values.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/column-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",225,"^Y",225,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Constructs a column matrix with the given data. The returned matrix is a 2D Nx1 column matrix.\n\n   The data must be either a valid existing vector or a sequence of scalar values."],"~$exp!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the exp function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/exp!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the exp function on all elements of an array, using double precision values. Mutates the array in-place."],"~$add-scaled",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1598,"^X",7,"^Y",1598,"^Z",17,"^[",["^10",["^11",["^10",[["~$m","~$a","^20"]]]]],"^14","Adds a numerical array scaled by a given factor to the first array. \n\n   Factor should be a scalar numerical value."],"^B","~$clojure.core.matrix/add-scaled","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$m","~$a","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1598,"^Y",1598,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","^20"]]]]],"^14","Adds a numerical array scaled by a given factor to the first array. \n\n   Factor should be a scalar numerical value."],"~$cmp",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1252,"^X",7,"^Y",1252,"^Z",10,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Element-wise of comparisons of two arrays. Returns the signum of the difference\n   between corresponding elements in two arrays.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (cmp 1 3) ;=> -1\n  (cmp 0 0) ;=> 0\n  (cmp 1 -1) ;=> 1\n  (cmp [[1 3] [5 5]] [[3 3] [5 3]]) ;=> [[-1 0] [0 1]]\n  (cmp [[1 4][1 5][1 8]] [[1 2][1 5][2 7]]) ;=> [[0 1][0 0][-1 1]]\n  "],"^B","~$clojure.core.matrix/cmp","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^18",["^10",[["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1252,"^Y",1252,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","~$b"]]]]],"^14","Element-wise of comparisons of two arrays. Returns the signum of the difference\n   between corresponding elements in two arrays.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (cmp 1 3) ;=> -1\n  (cmp 0 0) ;=> 0\n  (cmp 1 -1) ;=> 1\n  (cmp [[1 3] [5 5]] [[3 3] [5 3]]) ;=> [[-1 0] [0 1]]\n  (cmp [[1 4][1 5][1 8]] [[1 2][1 5][2 7]]) ;=> [[0 1][0 0][-1 1]]\n  "],"~$sqrt",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sqrt function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/sqrt","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sqrt function on all elements of an array, using double precision values. Returns a new array."],"~$vec?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",485,"^X",7,"^Y",485,"^Z",11,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a core.matrix vector (1-dimensional array)"],"^B","~$clojure.core.matrix/vec?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",485,"^Y",485,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a core.matrix vector (1-dimensional array)"],"~$scale!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1734,"^X",7,"^Y",1734,"^Z",13,"^[",["^10",["^11",["^10",[["~$m","^20"],["~$m","^20","~$&","~$more-factors"]]]]],"^14","Scales a numerical array by one or more scalar factors (in place). The default implementation supports\n   numerical arrays and numbers as scalar values, however matrix implementations may extend this to\n   support other scalar types (e.g. complex numbers).\n\n   Returns the array after it has been mutated.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","^20"]]],"^[",["^10",[["~$m","^20"],["~$m","^20","~$&","^7X"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/scale!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","^20"]]],"^[",["^10",[["~$m","^20"],["~$m","^20","~$&","^7X"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1734,"^Y",1734,"^17",2,"^1<",true,"^[",["^10",[["~$m","^20"],["~$m","^20","~$&","^7X"]]],"^14","Scales a numerical array by one or more scalar factors (in place). The default implementation supports\n   numerical arrays and numbers as scalar values, however matrix implementations may extend this to\n   support other scalar types (e.g. complex numbers).\n\n   Returns the array after it has been mutated."],"~$scale",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1724,"^X",7,"^Y",1724,"^Z",12,"^[",["^10",["^11",["^10",[["~$m","^20"],["~$m","^20","~$&","^7X"]]]]],"^14","Scales a array by one or more scalar factors. The default implementation supports numerical arrays and\n   numbers as scalar values, however matrix implementations may extend this to support other scalar types.\n\n   Returns a new scaled matrix.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","^20"]]],"^[",["^10",[["~$m","^20"],["~$m","^20","~$&","^7X"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/scale","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","^20"]]],"^[",["^10",[["~$m","^20"],["~$m","^20","~$&","^7X"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1724,"^Y",1724,"^17",2,"^1<",true,"^[",["^10",[["~$m","^20"],["~$m","^20","~$&","^7X"]]],"^14","Scales a array by one or more scalar factors. The default implementation supports numerical arrays and\n   numbers as scalar values, however matrix implementations may extend this to support other scalar types.\n\n   Returns a new scaled matrix."],"~$set-column!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2032,"^X",7,"^Y",2032,"^Z",18,"^[",["^10",["^11",["^10",[["~$m","~$i","~$column"]]]]],"^14","Sets a column in a matrix using a specified vector."],"^B","~$clojure.core.matrix/set-column!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$m","~$i","^81"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2032,"^Y",2032,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$i","^81"]]]]],"^14","Sets a column in a matrix using a specified vector."],"~$softplus!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1960,"^X",7,"^Y",1960,"^Z",16,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softplus function for every element of an array. Mutates the array."],"^B","~$clojure.core.matrix/softplus!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1960,"^Y",1960,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the softplus function for every element of an array. Mutates the array."],"~$subvector",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",966,"^X",7,"^Y",966,"^Z",16,"^[",["^10",["^11",["^10",[["~$m","~$start","^5E"]]]]],"^14","Gets a view of part of a vector, specifed by a start index and length.\n\n   The view maintains a reference to the original,\n   so can be used to modify the original vector if it is mutable."],"^B","~$clojure.core.matrix/subvector","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m","^86","^5E"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",966,"^Y",966,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^86","^5E"]]]]],"^14","Gets a view of part of a vector, specifed by a start index and length.\n\n   The view maintains a reference to the original,\n   so can be used to modify the original vector if it is mutable."],"~$inner-product",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1782,"^X",7,"^Y",1782,"^Z",20,"^[",["^10",["^11",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Computes the inner product of numerical arrays.\n\n   For matrix/matrix and matrix/vector arguments, this is equivalent to matrix multiplication.\n\n   The inner product of two arrays with indexed dimensions {..i j} and {j k..} has dimensions {..i k..}. The inner-product of two vectors will be scalar.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/inner-product","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",1782,"^Y",1782,"^17",2,"^1<",true,"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Computes the inner product of numerical arrays.\n\n   For matrix/matrix and matrix/vector arguments, this is equivalent to matrix multiplication.\n\n   The inner product of two arrays with indexed dimensions {..i j} and {j k..} has dimensions {..i k..}. The inner-product of two vectors will be scalar."],"~$sparse?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",542,"^X",7,"^Y",542,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if an array is sparse, i.e. the implementation supports storage of the entire\n   array in less memory than would normally be implied by the number of elements.\n\n   Sparse matrices may have memory requirements that scale with the number of non-zero elements\n   rather than the total number of elements, for example."],"^B","~$clojure.core.matrix/sparse?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",542,"^Y",542,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if an array is sparse, i.e. the implementation supports storage of the entire\n   array in less memory than would normally be implied by the number of elements.\n\n   Sparse matrices may have memory requirements that scale with the number of non-zero elements\n   rather than the total number of elements, for example."],"~$to-degrees!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-degrees function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/to-degrees!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the to-degrees function on all elements of an array, using double precision values. Mutates the array in-place."],"~$cbrt!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cbrt function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/cbrt!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cbrt function on all elements of an array, using double precision values. Mutates the array in-place."],"~$inverse",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1847,"^X",7,"^Y",1847,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the inverse of a square 2D numerical matrix.\n\n   Returns nil if the matrix is singular. \n\n   Throws an error is the argument is not a sqaure 2D matrix."],"^B","~$clojure.core.matrix/inverse","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1847,"^Y",1847,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the inverse of a square 2D numerical matrix.\n\n   Returns nil if the matrix is singular. \n\n   Throws an error is the argument is not a sqaure 2D matrix."],"~$square?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",602,"^X",7,"^Y",602,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if matrix is square (i.e. a 2D array with same number of rows and columns)"],"^B","~$clojure.core.matrix/square?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",602,"^Y",602,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if matrix is square (i.e. a 2D array with same number of rows and columns)"],"~$transpose",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1182,"^X",7,"^Y",1182,"^Z",16,"^[",["^10",["^11",["^10",[["~$m"],["~$m","~$ordering"]]]]],"^14","Transposes an array, returning a new array. \n\n   Assuming no specific ordering is provided:\n    - 1D vectors and scalars will be returned unchanged\n    - For 2D matrices, rows and columns are swapped.\n    - The dimension indices are reversed for any shape of a higher order N-dimensional array. \n\n   If ordering is provided, will re-order dimensions according to the provided order. The \n   provided ordering must be of the same length as the dimensionality of the array and\n   contain all the integers in the range 0...(dims-1).","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^8E"]]],"^[",["^10",[["~$m"],["~$m","^8E"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/transpose","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^8E"]]],"^[",["^10",[["~$m"],["~$m","^8E"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m"],["~$m","^8E"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1182,"^Y",1182,"^17",2,"^1<",true,"^[",["^10",[["~$m"],["~$m","^8E"]]],"^14","Transposes an array, returning a new array. \n\n   Assuming no specific ordering is provided:\n    - 1D vectors and scalars will be returned unchanged\n    - For 2D matrices, rows and columns are swapped.\n    - The dimension indices are reversed for any shape of a higher order N-dimensional array. \n\n   If ordering is provided, will re-order dimensions according to the provided order. The \n   provided ordering must be of the same length as the dimensionality of the array and\n   contain all the integers in the range 0...(dims-1)."],"^4E",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1027,"^X",7,"^Y",1027,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the columns of a matrix, as a seqable collection of 1D vectors.\n\n   If the array has more than 2 dimensions, will return the columns from all slices in order."],"^B","~$clojure.core.matrix/columns","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1027,"^Y",1027,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the columns of a matrix, as a seqable collection of 1D vectors.\n\n   If the array has more than 2 dimensions, will return the columns from all slices in order."],"~$e==",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1406,"^X",7,"^Y",1406,"^Z",10,"^[",["^10",["^11",["^10",[["^2T"],["^2T","^2U"],["^2T","^2U","~$&","^1@"]]]]],"^14","Returns true if all corresponding array elements are numerically equal.\n\n   Throws an error if any elements of the arrays being compared are not numerical values.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["^2T"],["^2T","^2U"]]],"^[",["^10",[["^2T"],["^2T","^2U"],["^2T","^2U","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/e==","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["^2T"],["^2T","^2U"]]],"^[",["^10",[["^2T"],["^2T","^2U"],["^2T","^2U","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["^2T"],["^2T","^2U"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1406,"^Y",1406,"^17",2,"^1<",true,"^[",["^10",[["^2T"],["^2T","^2U"],["^2T","^2U","~$&","^1@"]]],"^14","Returns true if all corresponding array elements are numerically equal.\n\n   Throws an error if any elements of the arrays being compared are not numerical values."],"~$det",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1840,"^X",7,"^Y",1840,"^Z",10,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Calculates the determinant of a 2D square numerical matrix, as a single numerical scalar value."],"^B","~$clojure.core.matrix/det","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1840,"^Y",1840,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Calculates the determinant of a 2D square numerical matrix, as a single numerical scalar value."],"~$broadcast",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1157,"^X",7,"^Y",1157,"^Z",16,"^[",["^10",["^11",["^10",[["~$m","^5="]]]]],"^14","Broadcasts an array to a specified shape. Returns a new array with the shape specified.\n   The broadcasted array may be a view over the original array: attempting to modify the\n   broadcasted array therefore has implementation-dependent results.\n\n   Will throw an exception if broadcast to the target shape is not possible."],"^B","~$clojure.core.matrix/broadcast","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m","^5="]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1157,"^Y",1157,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^5="]]]]],"^14","Broadcasts an array to a specified shape. Returns a new array with the shape specified.\n   The broadcasted array may be a view over the original array: attempting to modify the\n   broadcasted array therefore has implementation-dependent results.\n\n   Will throw an exception if broadcast to the target shape is not possible."],"~$zero-matrix?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",510,"^X",7,"^Y",510,"^Z",19,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if all the elements of the parameter are zero."],"^B","~$clojure.core.matrix/zero-matrix?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",510,"^Y",510,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if all the elements of the parameter are zero."],"~$trace",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1867,"^X",7,"^Y",1867,"^Z",12,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Calculates the trace of a 2D numerical matrix (sum of elements on main diagonal).\n\n   The matrix need not be square."],"^B","~$clojure.core.matrix/trace","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1867,"^Y",1867,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Calculates the trace of a 2D numerical matrix (sum of elements on main diagonal).\n\n   The matrix need not be square."],"~$zero-vector",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",131,"^X",7,"^Y",131,"^Z",18,"^[",["^10",["^11",["^10",[["^5E"],["^13","^5E"]]]]],"^14","Constructs a new zero-filled numerical vector with the given length.\n\n   Implementations are encouraged to return immutable vectors or sparse vectors\n   for efficency whre available.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5E"],["^13","^5E"]]],"^[",["^10",[["^5E"],["^13","^5E"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/zero-vector","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5E"],["^13","^5E"]]],"^[",["^10",[["^5E"],["^13","^5E"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^5E"],["^13","^5E"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",131,"^Y",131,"^17",2,"^1<",true,"^[",["^10",[["^5E"],["^13","^5E"]]],"^14","Constructs a new zero-filled numerical vector with the given length.\n\n   Implementations are encouraged to return immutable vectors or sparse vectors\n   for efficency whre available."],"~$conforming?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",679,"^X",7,"^Y",679,"^Z",18,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"]]]]],"^14","Returns true if two arrays have a conforming shape. Two arrays are conforming if there\n   exists a common shape that both can broadcast to. This is a requirement for element-wise\n   operations to work correctly on two different-shaped arrays.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/conforming?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",679,"^Y",679,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"]]],"^14","Returns true if two arrays have a conforming shape. Two arrays are conforming if there\n   exists a common shape that both can broadcast to. This is a requirement for element-wise\n   operations to work correctly on two different-shaped arrays."],"~$ecount",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",590,"^X",7,"^Y",590,"^Z",13,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the total count of elements in an array, as an integer value.\n\n   Equal to the product of the lengths of each dimension in the array's shape.\n\n   Result will usually be a Long, however callers should note that for very large sparse arrays\n   the element count may be a BigInteger, i.e. equal to or larger than 2^63.\n\n   Returns 1 for a zero-dimensional array or scalar. "],"^B","~$clojure.core.matrix/ecount","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",590,"^Y",590,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the total count of elements in an array, as an integer value.\n\n   Equal to the product of the lengths of each dimension in the array's shape.\n\n   Result will usually be a Long, however callers should note that for very large sparse arrays\n   the element count may be a BigInteger, i.e. equal to or larger than 2^63.\n\n   Returns 1 for a zero-dimensional array or scalar. "],"~$fill",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1225,"^X",7,"^Y",1225,"^Z",11,"^[",["^10",["^11",["^10",[["~$m","^69"]]]]],"^14","Fills an array with a single scalar value. The scalar value must be compatible with the element-type\n   of the array. Returns a new array.\n\n   Functionally similar to `assign!` except only intended for use with a scalar value."],"^B","~$clojure.core.matrix/fill","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m","^69"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1225,"^Y",1225,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^69"]]]]],"^14","Fills an array with a single scalar value. The scalar value must be compatible with the element-type\n   of the array. Returns a new array.\n\n   Functionally similar to `assign!` except only intended for use with a scalar value."],"~$set-row!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2021,"^X",7,"^Y",2021,"^Z",15,"^[",["^10",["^11",["^10",[["~$m","~$i","^4:"]]]]],"^14","Sets a row in a matrix in-place using a specified vector."],"^B","~$clojure.core.matrix/set-row!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",15,"^18",["^10",[["~$m","~$i","^4:"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2021,"^Y",2021,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$i","^4:"]]]]],"^14","Sets a row in a matrix in-place using a specified vector."],"~$pow",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1898,"^X",7,"^Y",1898,"^Z",10,"^[",["^10",["^11",["^10",[["~$m"],["~$m","~$exponent"],["~$m","^91","~$&","^1@"]]]]],"^14","Raises every element of a numerical matrix by the given exponent.\n\n   Note that behaviour for large exponents may depend on the underlying implementation:\n   for example double-based matrices may overflow to Double/POSITIVE_INFINITY.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m"],["~$m","^91"]]],"^[",["^10",[["~$m"],["~$m","^91"],["~$m","^91","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/pow","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m"],["~$m","^91"]]],"^[",["^10",[["~$m"],["~$m","^91"],["~$m","^91","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$m"],["~$m","^91"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1898,"^Y",1898,"^17",2,"^1<",true,"^[",["^10",[["~$m"],["~$m","^91"],["~$m","^91","~$&","^1@"]]],"^14","Raises every element of a numerical matrix by the given exponent.\n\n   Note that behaviour for large exponents may depend on the underlying implementation:\n   for example double-based matrices may overflow to Double/POSITIVE_INFINITY."],"~$set-selection!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",921,"^X",7,"^Y",921,"^Z",21,"^[",["^10",["^11",["^10",[["~$a","~$&","^4?"]]]]],"^14","Like set-selection but mutates the array in place. Will throw an error if array is immutable.","^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]]],"^B","~$clojure.core.matrix/set-selection!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]],"^18",[["^10",["~$a","^4?"]]],"^1;",null,"^19",["^10",[null]],"^X",1,"^W",921,"^Y",921,"^17",1,"^1<",true,"^[",["^10",[["~$a","~$&","^4?"]]],"^14","Like set-selection but mutates the array in place. Will throw an error if array is immutable."],"~$exp",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the exp function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/exp","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the exp function on all elements of an array, using double precision values. Returns a new array."],"~$mset!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",true,"^17",5,"^18",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$v"]]],"^[",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$v"],["~$m","~$x","~$y","~$z","~$t","~$&","^1@"]]],"^19",["^10",[null,null,null,null,null]]],"^5J",["^>",[4,3,2]],"^X",7,"^W",803,"^Y",803,"^[",["^10",["^11",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$v"],["~$m","~$x","~$y","~$z","~$t","~$&","^1@"]]]]],"^14","Mutates a scalar value in an array at the specified position. Supports any number of dimensions.\n\n   Will throw an exception if the matrix is not mutable at the specified position. Note that it\n   is possible for some arrays to be mutable in places and immutable in others (e.g. sparse arrays)\n\n   Returns the modified matrix (it is guaranteed to return the same instance)","^3Z",["^10",["^3[",["^10",[["~$m","~$v"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/set-0d!"]]]],["^10",["^43","~$m"]],["^10",["^43","~$v"]]]]]]]]]],["^10",[["~$m","~$x","~$v"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/set-1d!"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]],["^10",["^43","~$v"]]]]]]]]]],["^10",[["~$m","~$x","~$y","~$v"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/set-2d!"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]],["^10",["^43","~$y"]],["^10",["^43","~$v"]]]]]]]]]]]]],"^B","~$clojure.core.matrix/mset!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",true,"^17",5,"^18",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$v"]]],"^[",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$v"],["~$m","~$x","~$y","~$z","~$t","~$&","^1@"]]],"^19",["^10",[null,null,null,null,null]]],"^18",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$v"]]],"^5J",["^>",[4,3,2]],"^1;",null,"^19",["^10",[null,null,null,null,null]],"^X",1,"^W",803,"^Y",803,"^17",5,"^1<",true,"^[",["^10",[["~$m","~$v"],["~$m","~$x","~$v"],["~$m","~$x","~$y","~$v"],["~$m","~$x","~$y","~$z","~$v"],["~$m","~$x","~$y","~$z","~$t","~$&","^1@"]]],"^14","Mutates a scalar value in an array at the specified position. Supports any number of dimensions.\n\n   Will throw an exception if the matrix is not mutable at the specified position. Note that it\n   is possible for some arrays to be mutable in places and immutable in others (e.g. sparse arrays)\n\n   Returns the modified matrix (it is guaranteed to return the same instance)","^3Z",["^10",["^3[",["^10",[["~$m","~$v"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^98"]]]],["^10",["^43","~$m"]],["^10",["^43","~$v"]]]]]]]]]],["^10",[["~$m","~$x","~$v"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^99"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]],["^10",["^43","~$v"]]]]]]]]]],["^10",[["~$m","~$x","~$y","~$v"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^9:"]]]],["^10",["^43","~$m"]],["^10",["^43","~$x"]],["^10",["^43","~$y"]],["^10",["^43","~$v"]]]]]]]]]]]]],"~$rank",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",621,"^X",7,"^Y",621,"^Z",11,"^[",["^10",["^11",["^10",[["~$a"],["~$comparator","~$a"]]]]],"^14","Returns the rank of each element in an array, as an array of indexes with 0 being first, in ascending order.\n\n   If passed a higher dimensional array, returns an array of ranks along the last dimension.\n\n   An optional comparator may be provided, otherwise the default comparator will be used. Comparator should\n   support java.util.Comparator on the JVM, although some implementations may support alternative comparator types \n   e.g. Clojure predicates. Please check the documentation for your core.matrix implementation.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$a"],["^9=","~$a"]]],"^[",["^10",[["~$a"],["^9=","~$a"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/rank","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$a"],["^9=","~$a"]]],"^[",["^10",[["~$a"],["^9=","~$a"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$a"],["^9=","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",621,"^Y",621,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["^9=","~$a"]]],"^14","Returns the rank of each element in an array, as an array of indexes with 0 being first, in ascending order.\n\n   If passed a higher dimensional array, returns an array of ranks along the last dimension.\n\n   An optional comparator may be provided, otherwise the default comparator will be used. Comparator should\n   support java.util.Comparator on the JVM, although some implementations may support alternative comparator types \n   e.g. Clojure predicates. Please check the documentation for your core.matrix implementation."],"~$fill!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1216,"^X",7,"^Y",1216,"^Z",12,"^[",["^10",["^11",["^10",[["~$m","^69"]]]]],"^14","Fills an array with a single scalar value. The scalar value must be compatible with the element-type\n   of the array.\n\n   Similar to assign!, but only supports scalar values (and may be more efficient)."],"^B","~$clojure.core.matrix/fill!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$m","^69"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1216,"^Y",1216,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^69"]]]]],"^14","Fills an array with a single scalar value. The scalar value must be compatible with the element-type\n   of the array.\n\n   Similar to assign!, but only supports scalar values (and may be more efficient)."],"~$matrix?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",480,"^X",7,"^Y",480,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if parameter is a valid core.matrix matrix (i.e. an array with dimensionality == 2)"],"^B","~$clojure.core.matrix/matrix?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",480,"^Y",480,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if parameter is a valid core.matrix matrix (i.e. an array with dimensionality == 2)"],"~$maximum",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2151,"^X",7,"^Y",2151,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the maximum element value from a numerical array"],"^B","~$clojure.core.matrix/maximum","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2151,"^Y",2151,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the maximum element value from a numerical array"],"~$length-squared",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1893,"^X",27,"^Y",1893,"^Z",41,"^6X",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","DEPRECATED: please use magnitude-squared instead."],"^B","~$clojure.core.matrix/length-squared","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",41,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1893,"^6X",true,"^Y",1893,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","DEPRECATED: please use magnitude-squared instead."],"~$emul",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1452,"^X",27,"^Y",1452,"^Z",31,"^6X",true,"^[",["^10",["^11",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","DEPRECATED: please use mul instead.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/emul","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",31,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",1452,"^6X",true,"^Y",1452,"^17",2,"^1<",true,"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","DEPRECATED: please use mul instead."],"~$emin",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2136,"^X",7,"^Y",2136,"^Z",11,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the minimum element value from a numerical array"],"^B","~$clojure.core.matrix/emin","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2136,"^Y",2136,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the minimum element value from a numerical array"],"~$add-scaled-product!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1652,"^X",7,"^Y",1652,"^Z",26,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b","^20"]]]]],"^14","Adds the product of two numerical arrays scaled by a given factor to the first array.\n   Returns the mutated array.\n   This is equivalent to (add! m (mul a b factor)) but may be optimised by the underlying implementation."],"^B","~$clojure.core.matrix/add-scaled-product!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",26,"^18",["^10",[["~$m","~$a","~$b","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1652,"^Y",1652,"^17",4,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b","^20"]]]]],"^14","Adds the product of two numerical arrays scaled by a given factor to the first array.\n   Returns the mutated array.\n   This is equivalent to (add! m (mul a b factor)) but may be optimised by the underlying implementation."],"~$add-product!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1592,"^X",7,"^Y",1592,"^Z",19,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Adds the product of two numerical arrays to the first array. Returns the mutated array."],"^B","~$clojure.core.matrix/add-product!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^18",["^10",[["~$m","~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1592,"^Y",1592,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Adds the product of two numerical arrays to the first array. Returns the mutated array."],"~$conjoin-along",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1088,"^X",7,"^Y",1088,"^Z",20,"^[",["^10",["^11",["^10",[["^3Y","~$a","~$b"],["^3Y","~$a","~$b","~$&","^1@"]]]]],"^14","Adds a new value [b] as a new slice to an array [a] along the given dimension,\n   returning the extended array.\n   Broadcasts the new value to the correct shape of a slice of a if necessary.\n\n   This can be considered as the array equivalent of clojure.core/conj using\n   a specified dimension","^15",["^ ","^16",true,"^17",3,"^18",["^10",[["^3Y","~$a","~$b"]]],"^[",["^10",[["^3Y","~$a","~$b"],["^3Y","~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/conjoin-along","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["^3Y","~$a","~$b"]]],"^[",["^10",[["^3Y","~$a","~$b"],["^3Y","~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^3Y","~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1088,"^Y",1088,"^17",3,"^1<",true,"^[",["^10",[["^3Y","~$a","~$b"],["^3Y","~$a","~$b","~$&","^1@"]]],"^14","Adds a new value [b] as a new slice to an array [a] along the given dimension,\n   returning the extended array.\n   Broadcasts the new value to the correct shape of a slice of a if necessary.\n\n   This can be considered as the array equivalent of clojure.core/conj using\n   a specified dimension"],"~$slice-map",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2112,"^X",7,"^Y",2112,"^Z",16,"^[",["^10",["^11",["^10",[["~$f","~$m"],["~$f","^2T","^2U"],["~$f","^2T","^2U","~$&","^1@"]]]]],"^14","Maps a function over all slices of one or more array","^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","^2T","^2U"]]],"^[",["^10",[["~$f","~$m"],["~$f","^2T","^2U"],["~$f","^2T","^2U","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/slice-map","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","^2T","^2U"]]],"^[",["^10",[["~$f","~$m"],["~$f","^2T","^2U"],["~$f","^2T","^2U","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$f","~$m"],["~$f","^2T","^2U"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",2112,"^Y",2112,"^17",3,"^1<",true,"^[",["^10",[["~$f","~$m"],["~$f","^2T","^2U"],["~$f","^2T","^2U","~$&","^1@"]]],"^14","Maps a function over all slices of one or more array"],"~$lower-triangular?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",530,"^X",7,"^Y",530,"^Z",24,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a lower triangular matrix."],"^B","~$clojure.core.matrix/lower-triangular?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",24,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",530,"^Y",530,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a lower triangular matrix."],"~$add-outer-product!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1671,"^X",7,"^Y",1671,"^Z",25,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]]]],"^14","Adds the inner product of two numerical arrays to the first array.\n   \n   Returns the mutated array.\n\n   This is equivalent to (add! m (outer-product a b)) but may be optimised by the underlying implementation.","^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/add-outer-product!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",25,"^15",["^ ","^16",false,"^17",4,"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1671,"^Y",1671,"^17",4,"^1<",true,"^[",["^10",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^20"]]],"^14","Adds the inner product of two numerical arrays to the first array.\n   \n   Returns the mutated array.\n\n   This is equivalent to (add! m (outer-product a b)) but may be optimised by the underlying implementation."],"~$ereduce",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2069,"^X",7,"^Y",2069,"^Z",14,"^[",["^10",["^11",["^10",[["~$f","~$m"],["~$f","~$init","~$m"]]]]],"^14","Element-wise reduce on all elements of an array. \n\n   It is *not* guaranteed that the reduction may be stopped early using clojure.core/reduced. If this \n   behaviour is wanted, please check the details of the specific implementation or use the more generic \n   Clojure code:\n     (reduce f (eseq m))","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","^9X","~$m"]]],"^[",["^10",[["~$f","~$m"],["~$f","^9X","~$m"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/ereduce","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","^9X","~$m"]]],"^[",["^10",[["~$f","~$m"],["~$f","^9X","~$m"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$f","~$m"],["~$f","^9X","~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2069,"^Y",2069,"^17",3,"^1<",true,"^[",["^10",[["~$f","~$m"],["~$f","^9X","~$m"]]],"^14","Element-wise reduce on all elements of an array. \n\n   It is *not* guaranteed that the reduction may be stopped early using clojure.core/reduced. If this \n   behaviour is wanted, please check the details of the specific implementation or use the more generic \n   Clojure code:\n     (reduce f (eseq m))"],"~$cosh",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cosh function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/cosh","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the cosh function on all elements of an array, using double precision values. Returns a new array."],"~$scale-add!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1615,"^X",7,"^Y",1615,"^Z",17,"^[",["^10",["^11",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","~$constant"]]]]],"^14","Scales array m1 by factor a, then adds an array m2 scaled by factor b. May optionally add a constant.\n   Broadly equivalent to (add! (mul! m1 a) (mul m2 b) constant)\n\n   Returns the mutated array `m1`. The array `m2` will not be changed.","^15",["^ ","^16",false,"^17",5,"^18",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^[",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/scale-add!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^15",["^ ","^16",false,"^17",5,"^18",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^[",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1615,"^Y",1615,"^17",5,"^1<",true,"^[",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^14","Scales array m1 by factor a, then adds an array m2 scaled by factor b. May optionally add a constant.\n   Broadly equivalent to (add! (mul! m1 a) (mul m2 b) constant)\n\n   Returns the mutated array `m1`. The array `m2` will not be changed."],"~$div!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1491,"^X",7,"^Y",1491,"^Z",11,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs in-place element-wise matrix division for numerical arrays.\n\n   All arguments after the first must be broadcastable to the shape of the first array.\n\n   Computes the reciprocal of each element when passed a single argument (similar to clojure.core//).","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/div!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1491,"^Y",1491,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs in-place element-wise matrix division for numerical arrays.\n\n   All arguments after the first must be broadcastable to the shape of the first array.\n\n   Computes the reciprocal of each element when passed a single argument (similar to clojure.core//)."],"~$upper-triangular?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",525,"^X",7,"^Y",525,"^Z",24,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a upper triangular matrix."],"^B","~$clojure.core.matrix/upper-triangular?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",24,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",525,"^Y",525,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a upper triangular matrix."],"~$native?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",376,"^X",7,"^Y",376,"^Z",14,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Returns true if the array is in a native format.\n\n   Native formats are implementation defined, and may use non-Java resources (e.g. GPU memory)."],"^B","~$clojure.core.matrix/native?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",376,"^Y",376,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Returns true if the array is in a native format.\n\n   Native formats are implementation defined, and may use non-Java resources (e.g. GPU memory)."],"~$join-along",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1065,"^X",7,"^Y",1065,"^Z",17,"^[",["^10",["^11",["^10",[["^2A","~$&","^3T"]]]]],"^14","Joins arrays together, concatenating them along the specified dimension.\n\n   Other dimensions must be compatible.","^15",["^ ","^16",true,"^17",1,"^18",[["^10",["^2A","^3T"]]],"^[",["^10",[["^2A","~$&","^3T"]]],"^19",["^10",[null]]]],"^B","~$clojure.core.matrix/join-along","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^15",["^ ","^16",true,"^17",1,"^18",[["^10",["^2A","^3T"]]],"^[",["^10",[["^2A","~$&","^3T"]]],"^19",["^10",[null]]],"^18",[["^10",["^2A","^3T"]]],"^1;",null,"^19",["^10",[null]],"^X",1,"^W",1065,"^Y",1065,"^17",1,"^1<",true,"^[",["^10",[["^2A","~$&","^3T"]]],"^14","Joins arrays together, concatenating them along the specified dimension.\n\n   Other dimensions must be compatible."],"~$filter-slices",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2121,"^X",7,"^Y",2121,"^Z",20,"^[",["^10",["^11",["^10",[["~$pred","~$m"]]]]],"^14","Filters the slices of a core.matrix array, returning only those slices where (pred slice) is truthy.\n   \n   Will result in an nil value if no slices satify the criteria. If not nil, the return value is \n   guaranteed to be a seqable core.matrix array, e.g. you can:\n    - use (seq (filter-slices m)) to get a sequence of slices\n    - use (when-let [z (filter-slices m)] ...) to operate on the result as a core.matrix array."],"^B","~$clojure.core.matrix/filter-slices","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^18",["^10",[["^:<","~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2121,"^Y",2121,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["^:<","~$m"]]]]],"^14","Filters the slices of a core.matrix array, returning only those slices where (pred slice) is truthy.\n   \n   Will result in an nil value if no slices satify the criteria. If not nil, the return value is \n   guaranteed to be a seqable core.matrix array, e.g. you can:\n    - use (seq (filter-slices m)) to get a sequence of slices\n    - use (when-let [z (filter-slices m)] ...) to operate on the result as a core.matrix array."],"~$assign-array!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",422,"^X",7,"^Y",422,"^Z",20,"^[",["^10",["^11",["^10",[["~$dest","~$java-array"],["^:?","^:@","~$offset"]]]]],"^14","Assigns values to a destination core.matrix array from a Java array, in element-wise order. \n   The element type of Java array must be compatible.\n   Returns the mutated core.matrix array","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^:?","^:@"],["^:?","^:@","^:A"]]],"^[",["^10",[["^:?","^:@"],["^:?","^:@","^:A"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/assign-array!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^:?","^:@"],["^:?","^:@","^:A"]]],"^[",["^10",[["^:?","^:@"],["^:?","^:@","^:A"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^:?","^:@"],["^:?","^:@","^:A"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",422,"^Y",422,"^17",3,"^1<",true,"^[",["^10",[["^:?","^:@"],["^:?","^:@","^:A"]]],"^14","Assigns values to a destination core.matrix array from a Java array, in element-wise order. \n   The element type of Java array must be compatible.\n   Returns the mutated core.matrix array"],"~$broadcast-like",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1167,"^X",7,"^Y",1167,"^Z",21,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Broadcasts the second array to the shape of the first. See 'broadcast'.","^3Z",["^10",["^3[",["^10",[["~$m","~$a"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/broadcast-like"]]]],["^10",["^43","~$m"]],["^10",["^43","~$a"]]]]]]]]]]]]],"^B","~$clojure.core.matrix/broadcast-like","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1167,"^Y",1167,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Broadcasts the second array to the shape of the first. See 'broadcast'.","^3Z",["^10",["^3[",["^10",[["~$m","~$a"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^:D"]]]],["^10",["^43","~$m"]],["^10",["^43","~$a"]]]]]]]]]]]]],"~$sparse-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",317,"^X",7,"^Y",317,"^Z",19,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Creates a sparse array with the given data, using a specified implementation\n  or the current implementation if not specified.\n\n  Throws an exception if creation of a sparse array is not possible","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/sparse-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",317,"^Y",317,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Creates a sparse array with the given data, using a specified implementation\n  or the current implementation if not specified.\n\n  Throws an exception if creation of a sparse array is not possible"],"~$slice-count",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",583,"^X",7,"^Y",583,"^Z",18,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of slices in an array (array must be 1D or more). The array is sliced\n   in row-major order, i.e. this is the dimension count of the first dimension.","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^46"]]]],["^10",["^43","~$m"]],["^10",["^43",0]]]]]]]]]]]]],"^B","~$clojure.core.matrix/slice-count","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",583,"^Y",583,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of slices in an array (array must be 1D or more). The array is sliced\n   in row-major order, i.e. this is the dimension count of the first dimension.","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^46"]]]],["^10",["^43","~$m"]],["^10",["^43",0]]]]]]]]]]]]],"~$outer-product",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1796,"^X",7,"^Y",1796,"^Z",20,"^[",["^10",["^11",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Computes the outer product of numerical arrays.\n\n   For two vectors of size m and n, the result will be a m x n matrix.\n\n   In general, the outer product fior higher diemnsional arrays is defined as the \n   tensor product (see https://en.wikipedia.org/wiki/Tensor_product)\n   i.e. The outer product of two arrays with indexed dimensions {i..j} and {k..l} \n   has dimensions {i..j k..l}. The dimensionality of the result will be the\n   sum of the dimensionalities of the two arguments.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/outer-product","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",1796,"^Y",1796,"^17",2,"^1<",true,"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Computes the outer product of numerical arrays.\n\n   For two vectors of size m and n, the result will be a m x n matrix.\n\n   In general, the outer product fior higher diemnsional arrays is defined as the \n   tensor product (see https://en.wikipedia.org/wiki/Tensor_product)\n   i.e. The outer product of two arrays with indexed dimensions {i..j} and {k..l} \n   has dimensions {i..j k..l}. The dimensionality of the result will be the\n   sum of the dimensionalities of the two arguments."],"^?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",66,"^X",7,"^Y",66,"^Z",12,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Constructs a new n-dimensional array from the given data.\n\n   This function will examine the data in order to construct an array of the appropriate shape.\n\n   The data may be in one of the following forms:\n   - A valid existing array (which will be converted to the implementation)\n   - Nested sequences of scalar values, e.g. Clojure vectors (must have regular shape)\n   - A sequence of slices, each of which must be valid array data\n   - A single scalar value, which will be wrapped or coerced as necessary for the implementation\n\n   If implementation is not specified, uses the current matrix library as specified\n   in *matrix-implementation*\n\n   If the implementation does not support the shape or type of data provided, may either\n   create an array using a different implementation on a best-efforts basis or\n   alternatively throw an error. This behaviour is implementation-specific.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",66,"^Y",66,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Constructs a new n-dimensional array from the given data.\n\n   This function will examine the data in order to construct an array of the appropriate shape.\n\n   The data may be in one of the following forms:\n   - A valid existing array (which will be converted to the implementation)\n   - Nested sequences of scalar values, e.g. Clojure vectors (must have regular shape)\n   - A sequence of slices, each of which must be valid array data\n   - A single scalar value, which will be wrapped or coerced as necessary for the implementation\n\n   If implementation is not specified, uses the current matrix library as specified\n   in *matrix-implementation*\n\n   If the implementation does not support the shape or type of data provided, may either\n   create an array using a different implementation on a best-efforts basis or\n   alternatively throw an error. This behaviour is implementation-specific."],"~$magnitude",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1874,"^X",7,"^Y",1874,"^Z",16,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the magnitude over all elements in an array.\n\n   This is the 2-norm: equivalent to the Frobenius norm on matrices, or the Euclidean length on vectors."],"^B","~$clojure.core.matrix/magnitude","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1874,"^Y",1874,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the magnitude over all elements in an array.\n\n   This is the 2-norm: equivalent to the Frobenius norm on matrices, or the Euclidean length on vectors."],"~$slices",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",987,"^X",7,"^Y",987,"^Z",13,"^[",["^10",["^11",["^10",[["~$m"],["~$m","^2A"]]]]],"^14","Gets a sequence of slices of an array. If dimension is supplied, slices along a given dimension,\n   otherwise slices along the first dimension.\n\n   Returns a sequence of scalar values if the array is 1-dimensional.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^2A"]]],"^[",["^10",[["~$m"],["~$m","^2A"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/slices","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^2A"]]],"^[",["^10",[["~$m"],["~$m","^2A"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m"],["~$m","^2A"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",987,"^Y",987,"^17",2,"^1<",true,"^[",["^10",[["~$m"],["~$m","^2A"]]],"^14","Gets a sequence of slices of an array. If dimension is supplied, slices along a given dimension,\n   otherwise slices along the first dimension.\n\n   Returns a sequence of scalar values if the array is 1-dimensional."],"~$equals",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1237,"^X",7,"^Y",1237,"^Z",13,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$epsilon"]]]]],"^14","Returns true if two arrays are numerically equal.\n\n   Will return false for arrays of different shapes.\n\n   May either return false or throw an error if the arrays are not numerical.\n\n   If epsilon is provided, performs an equality test\n   with the given maximum tolerance (default is 0.0, i.e. exact numerical equivalence)","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","^:R"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","^:R"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/equals","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","^:R"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","^:R"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","^:R"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1237,"^Y",1237,"^17",3,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","^:R"]]],"^14","Returns true if two arrays are numerically equal.\n\n   Will return false for arrays of different shapes.\n\n   May either return false or throw an error if the arrays are not numerical.\n\n   If epsilon is provided, performs an equality test\n   with the given maximum tolerance (default is 0.0, i.e. exact numerical equivalence)"],"~$row-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",216,"^X",7,"^Y",216,"^Z",17,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Constructs a row matrix with the given data. The returned matrix is a 2D 1xN row matrix.\n\n   The data must be either a valid existing vector or a sequence of scalar values.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/row-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",216,"^Y",216,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Constructs a row matrix with the given data. The returned matrix is a 2D 1xN row matrix.\n\n   The data must be either a valid existing vector or a sequence of scalar values."],"~$esum",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2131,"^X",7,"^Y",2131,"^Z",11,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the sum of all the elements in a numerical array."],"^B","~$clojure.core.matrix/esum","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2131,"^Y",2131,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the sum of all the elements in a numerical array."],"~$round!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the round function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/round!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the round function on all elements of an array, using double precision values. Mutates the array in-place."],"~$symmetric?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",515,"^X",7,"^Y",515,"^Z",17,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a symmetric matrix, i.e. Aij = Aji for all i,j."],"^B","~$clojure.core.matrix/symmetric?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",515,"^Y",515,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a symmetric matrix, i.e. Aij = Aji for all i,j."],"~$asin",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the asin function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/asin","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the asin function on all elements of an array, using double precision values. Returns a new array."],"~$lerp",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1626,"^X",7,"^Y",1626,"^Z",11,"^[",["^10",["^11",["^10",[["~$a","~$b","^20"]]]]],"^14","Performs linear interpolation between two arrays. If factor is 0.0, result will be equal to the first vector.\n   If factor is 1.0, result will be equal to the second vector. Returns a new array."],"^B","~$clojure.core.matrix/lerp","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$a","~$b","^20"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1626,"^Y",1626,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","~$b","^20"]]]]],"^14","Performs linear interpolation between two arrays. If factor is 0.0, result will be equal to the first vector.\n   If factor is 1.0, result will be equal to the second vector. Returns a new array."],"~$select-view",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",903,"^X",7,"^Y",903,"^Z",18,"^[",["^10",["^11",["^10",[["~$a","~$&","^4?"]]]]],"^14","Like `select`, but guarantees a view over the original data.","^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]]],"^B","~$clojure.core.matrix/select-view","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^15",["^ ","^16",true,"^17",1,"^18",[["^10",["~$a","^4?"]]],"^[",["^10",[["~$a","~$&","^4?"]]],"^19",["^10",[null]]],"^18",[["^10",["~$a","^4?"]]],"^1;",null,"^19",["^10",[null]],"^X",1,"^W",903,"^Y",903,"^17",1,"^1<",true,"^[",["^10",[["~$a","~$&","^4?"]]],"^14","Like `select`, but guarantees a view over the original data."],"^4D",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1020,"^X",7,"^Y",1020,"^Z",11,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the rows of a matrix, as a sequence of 1D vectors.\n\n   If the array has more than 2 dimensions, will return the rows from all slices in order."],"^B","~$clojure.core.matrix/rows","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1020,"^Y",1020,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the rows of a matrix, as a sequence of 1D vectors.\n\n   If the array has more than 2 dimensions, will return the rows from all slices in order."],"~$matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",92,"^X",7,"^Y",92,"^Z",13,"^[",["^10",["^11",["^10",[["^12"],["^13","^12"]]]]],"^14","Constructs a new 2-dimensional matrix from the given numerical data.\n\n   The data may be in one of the following forms:\n   - A valid existing numerical array\n   - Nested sequences of scalar values, e.g. Clojure vectors\n   - A sequence of slices, each of which must be valid matrix data\n\n   If implementation is not specified, uses the current matrix library as specified\n   in *matrix-implementation*\n\n   `matrix` works as a synonym for `array`","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^12"],["^13","^12"]]],"^[",["^10",[["^12"],["^13","^12"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^12"],["^13","^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",92,"^Y",92,"^17",2,"^1<",true,"^[",["^10",[["^12"],["^13","^12"]]],"^14","Constructs a new 2-dimensional matrix from the given numerical data.\n\n   The data may be in one of the following forms:\n   - A valid existing numerical array\n   - Nested sequences of scalar values, e.g. Clojure vectors\n   - A sequence of slices, each of which must be valid matrix data\n\n   If implementation is not specified, uses the current matrix library as specified\n   in *matrix-implementation*\n\n   `matrix` works as a synonym for `array`"],"~$div",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1483,"^X",7,"^Y",1483,"^Z",10,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs element-wise division on numerical arrays.\n\n   Computes the reciprocal of each element when passed a single argument (similar to clojure.core//).","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/div","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1483,"^Y",1483,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs element-wise division on numerical arrays.\n\n   Computes the reciprocal of each element when passed a single argument (similar to clojure.core//)."],"~$mul!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1509,"^X",7,"^Y",1509,"^Z",11,"^[",["^10",["^11",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs in-place element-wise multiplication of numerical arrays.\n\n   All arguments after the first must be broadcastable to the shape of the first array.\n\n   Returns the first argument after mutation.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/mul!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$a"],["~$a","~$b"]]],"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",1509,"^Y",1509,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs in-place element-wise multiplication of numerical arrays.\n\n   All arguments after the first must be broadcastable to the shape of the first array.\n\n   Returns the first argument after mutation."],"~$signum!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the signum function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/signum!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the signum function on all elements of an array, using double precision values. Mutates the array in-place."],"~$scale-add",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1605,"^X",7,"^Y",1605,"^Z",16,"^[",["^10",["^11",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]]]],"^14","Scales array m1 by factor a, then adds an array m2 scaled by factor b. May optionally add a constant.\n   Broadly equivalent to (add (mul m1 a) (mul m2 b) constant)\n\n   Returns a new array.","^15",["^ ","^16",false,"^17",5,"^18",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^[",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/scale-add","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^15",["^ ","^16",false,"^17",5,"^18",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^[",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1605,"^Y",1605,"^17",5,"^1<",true,"^[",["^10",[["^2T","~$a","^2U","~$b"],["^2T","~$a","^2U","~$b","^:1"]]],"^14","Scales array m1 by factor a, then adds an array m2 scaled by factor b. May optionally add a constant.\n   Broadly equivalent to (add (mul m1 a) (mul m2 b) constant)\n\n   Returns a new array."],"~$add-product",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1586,"^X",7,"^Y",1586,"^Z",18,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Adds the element-wise product of two numerical arrays to the first array.\n   Arrays should be the same shape."],"^B","~$clojure.core.matrix/add-product","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$m","~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1586,"^Y",1586,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Adds the element-wise product of two numerical arrays to the first array.\n   Arrays should be the same shape."],"~$round",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the round function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/round","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the round function on all elements of an array, using double precision values. Returns a new array."],"~$normalise-args",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",877,"^X",8,"^Y",877,"^Z",22,"^2Z",true,"^[",["^10",["^11",["^10",[["^4?","~$m"]]]]],"^14","Normalises arguments by mapping :all to the complete range"],"^2Z",true,"^B","~$clojure.core.matrix/normalise-args","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",22,"^18",["^10",[["^4?","~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",877,"^Y",877,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["^4?","~$m"]]]]],"^14","Normalises arguments by mapping :all to the complete range"],"~$normalise",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1752,"^X",7,"^Y",1752,"^Z",16,"^[",["^10",["^11",["^10",[["~$v"]]]]],"^14","Normalises a numerical vector (scales to unit length). Returns a new normalised vector.\n\n   The result is undefined if the initial length of the vector is zero (it is possible the\n   implementation may return NaNs or zeros). If this is a concern, it is recommended to check\n   the length of the vector first in order to handle this as a special case."],"^B","~$clojure.core.matrix/normalise","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$v"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1752,"^Y",1752,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$v"]]]]],"^14","Normalises a numerical vector (scales to unit length). Returns a new normalised vector.\n\n   The result is undefined if the initial length of the vector is zero (it is possible the\n   implementation may return NaNs or zeros). If this is a concern, it is recommended to check\n   the length of the vector first in order to handle this as a special case."],"~$emap",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2081,"^X",7,"^Y",2081,"^Z",11,"^[",["^10",["^11",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise map over all elements of one or more arrays.\n\n   f must return a result compatible with the element-type of the array m. If a more general \n   type is required, try coercing to a more general array type first, e.g.\n     \n     (emap (fn [x] (str x)) (double-array [1 2 3]))             ;; Throws an error\n     (emap (fn [x] (str x)) (coerce [] (double-array [1 2 3]))) ;; OK!\n\n   Returns a new array of the same element-type and shape as the array m.","^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/emap","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",2081,"^Y",2081,"^17",3,"^1<",true,"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^14","Element-wise map over all elements of one or more arrays.\n\n   f must return a result compatible with the element-type of the array m. If a more general \n   type is required, try coercing to a more general array type first, e.g.\n     \n     (emap (fn [x] (str x)) (double-array [1 2 3]))             ;; Throws an error\n     (emap (fn [x] (str x)) (coerce [] (double-array [1 2 3]))) ;; OK!\n\n   Returns a new array of the same element-type and shape as the array m."],"~$acos!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the acos function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/acos!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the acos function on all elements of an array, using double precision values. Mutates the array in-place."],"~$select-indices",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",913,"^X",7,"^Y",913,"^Z",21,"^[",["^10",["^11",["^10",[["~$a","^3J"]]]]],"^14","Returns a one-dimensional array of the elements which are at the specified\n   indices. An index is a one-dimensional array which element-count matches the\n   dimensionality of a. Examples:\n   (select-indices [[1 2] [3 4]] [[0 0][1 1]]) ;=> [1 4]"],"^B","~$clojure.core.matrix/select-indices","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^18",["^10",[["~$a","^3J"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",913,"^Y",913,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$a","^3J"]]]]],"^14","Returns a one-dimensional array of the elements which are at the specified\n   indices. An index is a one-dimensional array which element-count matches the\n   dimensionality of a. Examples:\n   (select-indices [[1 2] [3 4]] [[0 0][1 1]]) ;=> [1 4]"],"~$assign!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",415,"^X",7,"^Y",415,"^Z",14,"^[",["^10",["^11",["^10",[["^:?","~$src"]]]]],"^14","Assigns a new value to an array. Sets the values of the target element-wise, broadcasting where necessary.\n   Returns the mutated array. The new value may be either a scalar or a array of compatible (maybe smaller) shape."],"^B","~$clojure.core.matrix/assign!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["^:?","^;P"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",415,"^Y",415,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["^:?","^;P"]]]]],"^14","Assigns a new value to an array. Sets the values of the target element-wise, broadcasting where necessary.\n   Returns the mutated array. The new value may be either a scalar or a array of compatible (maybe smaller) shape."],"~$get-row",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",831,"^X",7,"^Y",831,"^Z",14,"^[",["^10",["^11",["^10",[["~$m","~$x"]]]]],"^14","Gets a row of a matrix, as a 1D vector.\n\n   The format of the returned 1D vector is determined by the implementation of the source matrix. \n   get-row may return a lightweight mutable view if supported by the implementation."],"^B","~$clojure.core.matrix/get-row","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m","~$x"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",831,"^Y",831,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$x"]]]]],"^14","Gets a row of a matrix, as a 1D vector.\n\n   The format of the returned 1D vector is determined by the implementation of the source matrix. \n   get-row may return a lightweight mutable view if supported by the implementation."],"~$mul",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1441,"^X",7,"^Y",1441,"^Z",10,"^[",["^10",["^11",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]]]],"^14","Performs element-wise multiplication with scalars and numerical arrays.\n\n   Behaves like clojure.core/* for scalar values.","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/mul","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$a"],["~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",1441,"^Y",1441,"^17",2,"^1<",true,"^[",["^10",[[],["~$a"],["~$a","~$b"],["~$a","~$b","~$&","^1@"]]],"^14","Performs element-wise multiplication with scalars and numerical arrays.\n\n   Behaves like clojure.core/* for scalar values."],"~$sinh!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sinh function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/sinh!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sinh function on all elements of an array, using double precision values. Mutates the array in-place."],"~$native",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",366,"^X",7,"^Y",366,"^Z",13,"^[",["^10",["^11",["^10",[["~$a"],["~$impl","~$a"]]]]],"^14","Coerces an array into a native format array if possible. Native arrays may offer\n   superior performance for some operations, depending on the implementation.\n   Returns nil if no appropriate native format exists.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$a"],["^;Y","~$a"]]],"^[",["^10",[["~$a"],["^;Y","~$a"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/native","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$a"],["^;Y","~$a"]]],"^[",["^10",[["~$a"],["^;Y","~$a"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$a"],["^;Y","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",366,"^Y",366,"^17",2,"^1<",true,"^[",["^10",[["~$a"],["^;Y","~$a"]]],"^14","Coerces an array into a native format array if possible. Native arrays may offer\n   superior performance for some operations, depending on the implementation.\n   Returns nil if no appropriate native format exists."],"~$logistic!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1949,"^X",7,"^Y",1949,"^Z",16,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the sigmoid (logistic) function for every element of an array. Mutates the array."],"^B","~$clojure.core.matrix/logistic!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1949,"^Y",1949,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the sigmoid (logistic) function for every element of an array. Mutates the array."],"~$eif",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1268,"^X",7,"^Y",1268,"^Z",10,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Element-wise if. Tranverses each element, x, of an array, m. If x > 0,\n  returns a (if a is a scalar) or the corresponding element from a (if a is an\n  array or matrix). If x <= 0, returns b (if b is a scalar) or the corresponding\n  element from array b (if b is an array or matrix).\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (eif (lt 1 3) 3 6) ;=> 3\n  (eif (lt 5 3) 3 6) ;=> 6\n  (eif (eq A B) 1 2) ;=> [[1 2] [2 1]]\n  (eif (eq A B) 1 D) ;=> [[1 1] [9 1]]\n  (eif (eq A B) C 2) ;=> [[2 2] [2 2]]\n  (eif [[1 0][0 1] [[2 3][4 5]] [[6 7][8 9]]) ;=> [[2 7][8 5]]\n  (eif (gt [[2 6][3 5]] 4) [[0 0][0 0]] [[1 1][1 1]] ;=> [[0 1][0 1]]"],"^B","~$clojure.core.matrix/eif","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",10,"^18",["^10",[["~$m","~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1268,"^Y",1268,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a","~$b"]]]]],"^14","Element-wise if. Tranverses each element, x, of an array, m. If x > 0,\n  returns a (if a is a scalar) or the corresponding element from a (if a is an\n  array or matrix). If x <= 0, returns b (if b is a scalar) or the corresponding\n  element from array b (if b is an array or matrix).\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (eif (lt 1 3) 3 6) ;=> 3\n  (eif (lt 5 3) 3 6) ;=> 6\n  (eif (eq A B) 1 2) ;=> [[1 2] [2 1]]\n  (eif (eq A B) 1 D) ;=> [[1 1] [9 1]]\n  (eif (eq A B) C 2) ;=> [[2 2] [2 2]]\n  (eif [[1 0][0 1] [[2 3][4 5]] [[6 7][8 9]]) ;=> [[2 7][8 5]]\n  (eif (gt [[2 6][3 5]] 4) [[0 0][0 0]] [[1 1][1 1]] ;=> [[0 1][0 1]]"],"~$row-matrix?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",609,"^X",7,"^Y",609,"^Z",18,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if a matrix is a row-matrix (i.e. is 2D and has exactly one row)"],"^B","~$clojure.core.matrix/row-matrix?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",609,"^Y",609,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if a matrix is a row-matrix (i.e. is 2D and has exactly one row)"],"~$assign",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",433,"^X",7,"^Y",433,"^Z",13,"^[",["^10",["^11",["^10",[["^:?","^;P"]]]]],"^14","Copies array src element-wise, broadcasting to fill the whole shape of m.\n   Similar to assign!, except returns a new destination array.\n   Returns a new array, of the same shape and implementation as the original m."],"^B","~$clojure.core.matrix/assign","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["^:?","^;P"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",433,"^Y",433,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["^:?","^;P"]]]]],"^14","Copies array src element-wise, broadcasting to fill the whole shape of m.\n   Similar to assign!, except returns a new destination array.\n   Returns a new array, of the same shape and implementation as the original m."],"~$tanh!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tanh function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/tanh!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the tanh function on all elements of an array, using double precision values. Mutates the array in-place."],"~$main-diagonal",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1034,"^X",7,"^Y",1034,"^Z",20,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the main diagonal of a matrix or general array, as a vector.\n   The main diagonal of a general array is defined as those elements where the all the\n   indexes are equal, i.e. the index is of the form [i i ... i]\n   Works on both square and rectangular matrices."],"^B","~$clojure.core.matrix/main-diagonal","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1034,"^Y",1034,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the main diagonal of a matrix or general array, as a vector.\n   The main diagonal of a general array is defined as those elements where the all the\n   indexes are equal, i.e. the index is of the form [i i ... i]\n   Works on both square and rectangular matrices."],"~$cross!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1822,"^X",7,"^Y",1822,"^Z",13,"^[",["^10",["^11",["^10",[["~$a","~$b"],["^:?","~$a","~$b"]]]]],"^14","Computes the cross-product of two numerical 3D vectors a and b, storing the result in the first vector.\n\n   Returns the (mutated) first vector.","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$a","~$b"],["^:?","~$a","~$b"]]],"^[",["^10",[["~$a","~$b"],["^:?","~$a","~$b"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/cross!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$a","~$b"],["^:?","~$a","~$b"]]],"^[",["^10",[["~$a","~$b"],["^:?","~$a","~$b"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$a","~$b"],["^:?","~$a","~$b"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1822,"^Y",1822,"^17",3,"^1<",true,"^[",["^10",[["~$a","~$b"],["^:?","~$a","~$b"]]],"^14","Computes the cross-product of two numerical 3D vectors a and b, storing the result in the first vector.\n\n   Returns the (mutated) first vector."],"~$abs",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the abs function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/abs","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the abs function on all elements of an array, using double precision values. Returns a new array."],"~$new-sparse-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",190,"^X",7,"^Y",190,"^Z",23,"^[",["^10",["^11",["^10",[["^5="],["^13","^5="]]]]],"^14","Creates a new sparse array with the given shape.\n   New array will contain default values as defined by the implementation (usually zero).\n   If the implementation supports mutable sparse matrices, then the new matrix should be fully mutable.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5="],["^13","^5="]]],"^[",["^10",[["^5="],["^13","^5="]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/new-sparse-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",23,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5="],["^13","^5="]]],"^[",["^10",[["^5="],["^13","^5="]]],"^19",["^10",[null,null]]],"^18",["^10",[["^5="],["^13","^5="]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",190,"^Y",190,"^17",2,"^1<",true,"^[",["^10",[["^5="],["^13","^5="]]],"^14","Creates a new sparse array with the given shape.\n   New array will contain default values as defined by the implementation (usually zero).\n   If the implementation supports mutable sparse matrices, then the new matrix should be fully mutable."],"~$sinh",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sinh function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/sinh","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sinh function on all elements of an array, using double precision values. Returns a new array."],"~$to-nested-vectors",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",456,"^X",7,"^Y",456,"^Z",24,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Converts an array to an idiomatic, immutable nested Clojure vector format. The bottom level of the\n   nested vectors will contain the element values. Higher levels will all implement IPersistentVector.\n\n   The depth of nesting will be equal to the dimensionality of the array."],"^B","~$clojure.core.matrix/to-nested-vectors","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",24,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",456,"^Y",456,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Converts an array to an idiomatic, immutable nested Clojure vector format. The bottom level of the\n   nested vectors will contain the element values. Higher levels will all implement IPersistentVector.\n\n   The depth of nesting will be equal to the dimensionality of the array."],"~$scalar",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",464,"^X",7,"^Y",464,"^Z",13,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Coerces m to a scalar value. Result is guaranteed not to be an array.\n   Will throw an exception if m is not zero-dimensional.","^3Z",["^10",["^3[",["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^5K"]]]],["^10",["^43","~$m"]]]]]]]]]]],"^B","~$clojure.core.matrix/scalar","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",464,"^Y",464,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Coerces m to a scalar value. Result is guaranteed not to be an array.\n   Will throw an exception if m is not zero-dimensional.","^3Z",["^10",["^3[",["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^5K"]]]],["^10",["^43","~$m"]]]]]]]]]]],"^5B",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1421,"^X",7,"^Y",1421,"^Z",12,"^[",["^10",["^11",["^10",[["~$m","^3Y","~$i"]]]]],"^14","Returns a label for the specified position along a given array dimension. Returns nil if the dimension is unlabelled."],"^B","~$clojure.core.matrix/label","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$m","^3Y","~$i"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1421,"^Y",1421,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^3Y","~$i"]]]]],"^14","Returns a label for the specified position along a given array dimension. Returns nil if the dimension is unlabelled."],"~$class",["^ ","^B","~$clojure.core.matrix/class","^V","resources/public/js/clojure/core/matrix.cljc","^W",53,"^X",7,"^Y",53,"^Z",17,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",53,"^X",12,"^Y",53,"^Z",17]],"~$implementation-check",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2231,"^X",8,"^Y",2231,"^Z",28,"^2Z",true,"^[",["^10",["^11",["^10",[[],["^;Y"]]]]],"^14","Gets a canonical matrix object for a given implementation (keyword or array), or the current implementation\n   if not otherwise specified. Scalars are regarded as conforming to the current implementation\n   Throws an exception if none is available.","^15",["^ ","^16",false,"^17",1,"^18",["^10",[[],["^;Y"]]],"^[",["^10",[[],["^;Y"]]],"^19",["^10",[null,null]]]],"^2Z",true,"^B","~$clojure.core.matrix/implementation-check","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",28,"^15",["^ ","^16",false,"^17",1,"^18",["^10",[[],["^;Y"]]],"^[",["^10",[[],["^;Y"]]],"^19",["^10",[null,null]]],"^18",["^10",[[],["^;Y"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2231,"^Y",2231,"^17",1,"^1<",true,"^[",["^10",[[],["^;Y"]]],"^14","Gets a canonical matrix object for a given implementation (keyword or array), or the current implementation\n   if not otherwise specified. Scalars are regarded as conforming to the current implementation\n   Throws an exception if none is available."],"~$broadcast-coerce",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1173,"^X",7,"^Y",1173,"^Z",23,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Broadcasts and coerces the second array to the same shape and type of the first.\n   Equivalent to (coerce m (broadcast-like m a)).\n\n   Useful for converting arrays to the correct shape and type for efficient future operations.","^3Z",["^10",["^3[",["^10",[["~$m","~$a"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/broadcast-coerce"]]]],["^10",["^43","~$m"]],["^10",["^43","~$a"]]]]]]]]]]]]],"^B","~$clojure.core.matrix/broadcast-coerce","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",23,"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1173,"^Y",1173,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$a"]]]]],"^14","Broadcasts and coerces the second array to the same shape and type of the first.\n   Equivalent to (coerce m (broadcast-like m a)).\n\n   Useful for converting arrays to the correct shape and type for efficient future operations.","^3Z",["^10",["^3[",["^10",[["~$m","~$a"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^<M"]]]],["^10",["^43","~$m"]],["^10",["^43","~$a"]]]]]]]]]]]]],"~$same-shape?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",688,"^X",7,"^Y",688,"^Z",18,"^[",["^10",["^11",["^10",[[],["~$m"],["~$m","~$n"],["~$m","~$n","~$&","^1@"]]]]],"^14","Returns true if the arrays have the same shape, false otherwise","^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$m"],["~$m","~$n"]]],"^[",["^10",[[],["~$m"],["~$m","~$n"],["~$m","~$n","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]]],"^B","~$clojure.core.matrix/same-shape?","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[[],["~$m"],["~$m","~$n"]]],"^[",["^10",[[],["~$m"],["~$m","~$n"],["~$m","~$n","~$&","^1@"]]],"^19",["^10",[null,null,null,null]]],"^18",["^10",[[],["~$m"],["~$m","~$n"]]],"^1;",null,"^19",["^10",[null,null,null,null]],"^X",1,"^W",688,"^Y",688,"^17",2,"^1<",true,"^[",["^10",[[],["~$m"],["~$m","~$n"],["~$m","~$n","~$&","^1@"]]],"^14","Returns true if the arrays have the same shape, false otherwise"],"^@",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",474,"^X",7,"^Y",474,"^Z",13,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a valid core.matrix N-dimensional array, for any N>=0.","^3Z",["^10",["^3[",["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$cljs.core/not"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/is-scalar?"]]]],["^10",["^43","~$m"]]]]]]]]]]]]]]]]]]],"^B","~$clojure.core.matrix/array?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",474,"^Y",474,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter is a valid core.matrix N-dimensional array, for any N>=0.","^3Z",["^10",["^3[",["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^<Q"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^<R"]]]],["^10",["^43","~$m"]]]]]]]]]]]]]]]]]]],"~$gt",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1325,"^X",7,"^Y",1325,"^Z",9,"^[",["^10",["^11",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise greater-than comparison operation. Returns a binary array where\n  elements greater-than the argument are represented by 1 and elements less-\n  than or equal to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (gt 4 3) ;=> 1\n  (gt 3 3) ;=> 0\n  (gt [[1 5] [3 6]] 3) ;=> [[0 1] [0 1]]\n  (gt [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[0 1] [0 0]]","^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/gt","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",9,"^15",["^ ","^16",true,"^17",2,"^18",["^10",[["~$m","~$a"]]],"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1325,"^Y",1325,"^17",2,"^1<",true,"^[",["^10",[["~$m","~$a"],["~$m","~$a","~$&","^1@"]]],"^14","Element-wise greater-than comparison operation. Returns a binary array where\n  elements greater-than the argument are represented by 1 and elements less-\n  than or equal to the argument are 0.\n\n  Performs broadcasting of arguments if required to match the size of the largest array.\n\n  Examples:\n  (gt 4 3) ;=> 1\n  (gt 3 3) ;=> 0\n  (gt [[1 5] [3 6]] 3) ;=> [[0 1] [0 1]]\n  (gt [[1 5] [4 6]] [[2 3] [5 6]]) ;=> [[0 1] [0 0]]"],"^A",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",440,"^X",7,"^Y",440,"^Z",12,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Constructs a (shallow) clone of the array. This function is intended to\n   allow safe defensive usage of matrices / vectors. If the intent is to create a mutable clone of\n   some array data, it is recommended to use mutable instead.\n\n   Guarantees that:\n   1. Mutating the returned array will not modify any other array (defensive copy)\n   2. The returned array will be fully mutable, if the implementation supports mutable matrices.\n\n   The clone may or may not be of the same implementation: implementations are encouraged to do so but\n   this is not mandatory.\n\n   A core.matrix implementation which only provides immutable arrays may safely return the same array."],"^B","~$clojure.core.matrix/clone","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",440,"^Y",440,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Constructs a (shallow) clone of the array. This function is intended to\n   allow safe defensive usage of matrices / vectors. If the intent is to create a mutable clone of\n   some array data, it is recommended to use mutable instead.\n\n   Guarantees that:\n   1. Mutating the returned array will not modify any other array (defensive copy)\n   2. The returned array will be fully mutable, if the implementation supports mutable matrices.\n\n   The clone may or may not be of the same implementation: implementations are encouraged to do so but\n   this is not mandatory.\n\n   A core.matrix implementation which only provides immutable arrays may safely return the same array."],"~$to-object-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",728,"^X",7,"^Y",728,"^Z",22,"^[",["^10",["^11",["^10",[["~$m"],["~$m","~$want-copy?"]]]]],"^14","Returns a Java Object[] array containing the values of an array m in row-major order.\n\n    If want-copy? is true, will guarantee a new Object array (defensive copy).\n    If want-copy? is false, will return the internal array used by m, or nil if not supported\n    by the implementation.\n    If want-copy? is not specified, will return either a copy or the internal array","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^<X"]]],"^[",["^10",[["~$m"],["~$m","^<X"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/to-object-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",22,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^<X"]]],"^[",["^10",[["~$m"],["~$m","^<X"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m"],["~$m","^<X"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",728,"^Y",728,"^17",2,"^1<",true,"^[",["^10",[["~$m"],["~$m","^<X"]]],"^14","Returns a Java Object[] array containing the values of an array m in row-major order.\n\n    If want-copy? is true, will guarantee a new Object array (defensive copy).\n    If want-copy? is false, will return the internal array used by m, or nil if not supported\n    by the implementation.\n    If want-copy? is not specified, will return either a copy or the internal array"],"~$row-count",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",571,"^X",7,"^Y",571,"^Z",16,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of rows in a matrix or vector (array must be 1D or more).","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^46"]]]],["^10",["^43","~$m"]],["^10",["^43",0]]]]]]]]]]]]],"^B","~$clojure.core.matrix/row-count","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",571,"^Y",571,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the number of rows in a matrix or vector (array must be 1D or more).","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^46"]]]],["^10",["^43","~$m"]],["^10",["^43",0]]]]]]]]]]]]],"~$slice",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",974,"^X",7,"^Y",974,"^Z",12,"^[",["^10",["^11",["^10",[["~$m","^6U"],["~$m","^2A","^6U"]]]]],"^14","Gets a slice of an array along a specific dimension.\n   \n   The returned array will have one less dimension, i.e. slicing a matrix will return a vector\n   and slicing a 1D vector will return a scalar.\n\n   Slicing on the first dimension (dimension 0) is likely to perform better\n   for many array implementations. This is the default.","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^6U"],["~$m","^2A","^6U"]]],"^[",["^10",[["~$m","^6U"],["~$m","^2A","^6U"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/slice","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^6U"],["~$m","^2A","^6U"]]],"^[",["^10",[["~$m","^6U"],["~$m","^2A","^6U"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","^6U"],["~$m","^2A","^6U"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",974,"^Y",974,"^17",3,"^1<",true,"^[",["^10",[["~$m","^6U"],["~$m","^2A","^6U"]]],"^14","Gets a slice of an array along a specific dimension.\n   \n   The returned array will have one less dimension, i.e. slicing a matrix will return a vector\n   and slicing a 1D vector will return a scalar.\n\n   Slicing on the first dimension (dimension 0) is likely to perform better\n   for many array implementations. This is the default."],"~$permutation-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",245,"^X",7,"^Y",245,"^Z",25,"^[",["^10",["^11",["^10",[["~$permutation"],["^13","^=3"]]]]],"^14","Constructs a permutation matrix for a given permutation vector. The permutation vector should\n   contain a distinct set of integers 0...n-1, representing the re-ordering performed by\n   the permutation matrix.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^=3"],["^13","^=3"]]],"^[",["^10",[["^=3"],["^13","^=3"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/permutation-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",25,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^=3"],["^13","^=3"]]],"^[",["^10",[["^=3"],["^13","^=3"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^=3"],["^13","^=3"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",245,"^Y",245,"^17",2,"^1<",true,"^[",["^10",[["^=3"],["^13","^=3"]]],"^14","Constructs a permutation matrix for a given permutation vector. The permutation vector should\n   contain a distinct set of integers 0...n-1, representing the re-ordering performed by\n   the permutation matrix."],"~$floor!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the floor function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/floor!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the floor function on all elements of an array, using double precision values. Mutates the array in-place."],"~$new-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",178,"^X",7,"^Y",178,"^Z",16,"^[",["^10",["^11",["^10",[["^5="],["^13","^5="]]]]],"^14","Creates a new array with the given shape.\n   New array will contain default values as defined by the implementation (usually null or zero).\n   If the implementation supports mutable matrices, then the new matrix will be fully mutable.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5="],["^13","^5="]]],"^[",["^10",[["^5="],["^13","^5="]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/new-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5="],["^13","^5="]]],"^[",["^10",[["^5="],["^13","^5="]]],"^19",["^10",[null,null]]],"^18",["^10",[["^5="],["^13","^5="]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",178,"^Y",178,"^17",2,"^1<",true,"^[",["^10",[["^5="],["^13","^5="]]],"^14","Creates a new array with the given shape.\n   New array will contain default values as defined by the implementation (usually null or zero).\n   If the implementation supports mutable matrices, then the new matrix will be fully mutable."],"~$square",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1747,"^X",7,"^Y",1747,"^Z",13,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Squares every element of a numerical array. Returns a new array."],"^B","~$clojure.core.matrix/square","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1747,"^Y",1747,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Squares every element of a numerical array. Returns a new array."],"~$compute-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",308,"^X",7,"^Y",308,"^Z",21,"^[",["^10",["^11",["^10",[["^5=","~$f"],["^13","^5=","~$f"]]]]],"^14","Creates a array with the specified shape, and each element specified by (f i j k...)\n   Where i, j, k... are the index positions of each element in the matrix","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^5=","~$f"],["^13","^5=","~$f"]]],"^[",["^10",[["^5=","~$f"],["^13","^5=","~$f"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/compute-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^5=","~$f"],["^13","^5=","~$f"]]],"^[",["^10",[["^5=","~$f"],["^13","^5=","~$f"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^5=","~$f"],["^13","^5=","~$f"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",308,"^Y",308,"^17",3,"^1<",true,"^[",["^10",[["^5=","~$f"],["^13","^5=","~$f"]]],"^14","Creates a array with the specified shape, and each element specified by (f i j k...)\n   Where i, j, k... are the index positions of each element in the matrix"],"~$minimum",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2146,"^X",7,"^Y",2146,"^Z",14,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the minimum element value from a numerical array"],"^B","~$clojure.core.matrix/minimum","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2146,"^Y",2146,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Gets the minimum element value from a numerical array"],"^5E",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1888,"^X",27,"^Y",1888,"^Z",33,"^6X",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","DEPRECATED: please use magnitude instead."],"^B","~$clojure.core.matrix/length","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",33,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1888,"^6X",true,"^Y",1888,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","DEPRECATED: please use magnitude instead."],"~$current-implementation",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2226,"^X",7,"^Y",2226,"^Z",29,"^[",["^10",["^11",["^10",[[]]]]],"^14","Gets the currently active matrix implementation as a keyword, e.g. :vectorz"],"^B","~$clojure.core.matrix/current-implementation","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",29,"^18",["^10",[[]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2226,"^Y",2226,"^17",0,"^1<",true,"^[",["^10",["^11",["^10",[[]]]]],"^14","Gets the currently active matrix implementation as a keyword, e.g. :vectorz"],"~$sin",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sin function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/sin","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the sin function on all elements of an array, using double precision values. Returns a new array."],"~$zero-matrix",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",151,"^X",7,"^Y",151,"^Z",18,"^[",["^10",["^11",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]]]],"^14","Constructs a new zero-filled numerical matrix with the given dimensions.\n\n   May produce a lightweight immutable zero matrix if supported by the implementation.","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^[",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/zero-matrix","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",18,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^[",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",151,"^Y",151,"^17",3,"^1<",true,"^[",["^10",[["^4D","^4E"],["^13","^4D","^4E"]]],"^14","Constructs a new zero-filled numerical matrix with the given dimensions.\n\n   May produce a lightweight immutable zero matrix if supported by the implementation."],"~$relu",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1966,"^X",7,"^Y",1966,"^Z",11,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the ReLU (rectified linear) function for every element of an array."],"^B","~$clojure.core.matrix/relu","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",11,"^18",["^10",[["~$a"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1966,"^Y",1966,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$a"]]]]],"^14","Computes the ReLU (rectified linear) function for every element of an array."],"~$set-column",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2027,"^X",7,"^Y",2027,"^Z",17,"^[",["^10",["^11",["^10",[["~$m","~$i","^81"]]]]],"^14","Sets a column in a matrix using a specified vector."],"^B","~$clojure.core.matrix/set-column","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$m","~$i","^81"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2027,"^Y",2027,"^17",3,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","~$i","^81"]]]]],"^14","Sets a column in a matrix using a specified vector."],"~$immutable",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",279,"^X",7,"^Y",279,"^Z",16,"^[",["^10",["^11",["^10",[["^12"]]]]],"^14","Returns an immutable array containing the given array data.\n\n   May return the same array if it is already immutable.\n\n   If the implementation does not support immutable matrices, will return an immutable array\n   from another core.matrix implementation that supports either the same element type or a broader type."],"^B","~$clojure.core.matrix/immutable","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",16,"^18",["^10",[["^12"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",279,"^Y",279,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["^12"]]]]],"^14","Returns an immutable array containing the given array data.\n\n   May return the same array if it is already immutable.\n\n   If the implementation does not support immutable matrices, will return an immutable array\n   from another core.matrix implementation that supports either the same element type or a broader type."],"~$reshape",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1206,"^X",7,"^Y",1206,"^Z",14,"^[",["^10",["^11",["^10",[["~$m","^5="]]]]],"^14","Changes the shape of a matrix to the specified new shape. shape can be any sequence of dimension sizes.\n\n   Preserves the row-major order of matrix elements. Truncates the sequence of elements if the shape is smaller\n   than the original shape.\n\n   Pads with default values (dependent on implementation - normally zero) if the shape is larger."],"^B","~$clojure.core.matrix/reshape","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$m","^5="]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1206,"^Y",1206,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$m","^5="]]]]],"^14","Changes the shape of a matrix to the specified new shape. shape can be any sequence of dimension sizes.\n\n   Preserves the row-major order of matrix elements. Truncates the sequence of elements if the shape is smaller\n   than the original shape.\n\n   Pads with default values (dependent on implementation - normally zero) if the shape is larger."],"^5=",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",634,"^X",7,"^Y",634,"^Z",12,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the shape of an array, i.e. the dimension sizes for all dimensions.\n\n   The result will be a vector containing only integer index values, with a count\n   equal to the dimensionality of the array.\n\n   Returns nil the if object is not an array (i.e. is a scalar value)","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$cljs.core/if-let"]]]],["^10",["^43",["^10",["~$clojure.core/vec",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^1M"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/get-shape"]]]],["^10",["^43","~$m"]]]]]]]]]]]]]]]]]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$cljs.core/vec"]]]],["^10",["^43",["^10",["^11","^1M"]]]]]]]]]]]],["^10",["^43",null]]]]]]]]]]]]],"^B","~$clojure.core.matrix/shape","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",634,"^Y",634,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the shape of an array, i.e. the dimension sizes for all dimensions.\n\n   The result will be a vector containing only integer index values, with a count\n   equal to the dimensionality of the array.\n\n   Returns nil the if object is not an array (i.e. is a scalar value)","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^=N"]]]],["^10",["^43",["^10",["^=O",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^1M"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^=P"]]]],["^10",["^43","~$m"]]]]]]]]]]]]]]]]]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^=Q"]]]],["^10",["^43",["^10",["^11","^1M"]]]]]]]]]]]],["^10",["^43",null]]]]]]]]]]]]],"~$transform!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1547,"^X",7,"^Y",1547,"^Z",17,"^[",["^10",["^11",["^10",[["~$t","~$v"]]]]],"^14","Transforms a given vector in place. This is a mutable equivalent to `transform`.\n\n   Returns the transformed vector.\n\n   The transformation must map an n-dimensional vector to another n-dimensional vector, i.e.\n   if it is a 2D matrix then it must have shape [n x n]."],"^B","~$clojure.core.matrix/transform!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^18",["^10",[["~$t","~$v"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1547,"^Y",1547,"^17",2,"^1<",true,"^[",["^10",["^11",["^10",[["~$t","~$v"]]]]],"^14","Transforms a given vector in place. This is a mutable equivalent to `transform`.\n\n   Returns the transformed vector.\n\n   The transformation must map an n-dimensional vector to another n-dimensional vector, i.e.\n   if it is a 2D matrix then it must have shape [n x n]."],"~$scalar?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",490,"^X",7,"^Y",490,"^Z",14,"^[",["^10",["^11",["^10",[["~$v"]]]]],"^14","Returns true if the parameter is a scalar value (i.e. acceptable as matrix element value).\n   A 0-d array containing a scalar is *not* itself a scalar value.","^3Z",["^10",["^3[",["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^<R"]]]],["^10",["^43","~$m"]]]]]]]]]]],"^B","~$clojure.core.matrix/scalar?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",14,"^18",["^10",[["~$v"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",490,"^Y",490,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$v"]]]]],"^14","Returns true if the parameter is a scalar value (i.e. acceptable as matrix element value).\n   A 0-d array containing a scalar is *not* itself a scalar value.","^3Z",["^10",["^3[",["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^<R"]]]],["^10",["^43","~$m"]]]]]]]]]]],"~$zero-dimensional?",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",497,"^X",7,"^Y",497,"^Z",24,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter has zero dimensions. i.e. it is a 0-d array or a scalar value.\n\n   Behaviour is the same as `scalar?`, except that true is returned for 0-dimensional arrays."],"^B","~$clojure.core.matrix/zero-dimensional?","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",24,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",497,"^Y",497,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns true if the parameter has zero dimensions. i.e. it is a 0-d array or a scalar value.\n\n   Behaviour is the same as `scalar?`, except that true is returned for 0-dimensional arrays."],"~$dimensionality",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",557,"^X",7,"^Y",557,"^Z",21,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the dimensionality of an array. The dimensionality is equal to\n   the number of dimensions in the array's shape.","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^44"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","~$clojure.core.matrix.protocols/dimensionality"]]]],["^10",["^43","~$m"]]]]]]]]]]]]]]]]]]]]],"^B","~$clojure.core.matrix/dimensionality","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",557,"^Y",557,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the dimensionality of an array. The dimensionality is equal to\n   the number of dimensions in the array's shape.","^3Z",["^10",["^3[",["^10",[["~$m"],["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^44"]]]],["^10",["^43",["^10",["^40",["^10",["^41",["^10",["^42",["^10",["^43",["^10",["^11","^=Z"]]]],["^10",["^43","~$m"]]]]]]]]]]]]]]]]]]]]],"~$rotate",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1107,"^X",7,"^Y",1107,"^Z",13,"^[",["^10",["^11",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]]]],"^14","Rotates an array along specified dimensions.\n\n   Elements rotated off will re-appear at the other side. The shape of the array will not be modified.","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^[",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/rotate","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^[",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1107,"^Y",1107,"^17",3,"^1<",true,"^[",["^10",[["~$m","^2A","^4H"],["~$m","^4I"]]],"^14","Rotates an array along specified dimensions.\n\n   Elements rotated off will re-appear at the other side. The shape of the array will not be modified."],"~$signum",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the signum function on all elements of an array, using double precision values. Returns a new array.","^V",null],"^B","~$clojure.core.matrix/signum","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the signum function on all elements of an array, using double precision values. Returns a new array."],"~$magnitude-squared",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1881,"^X",7,"^Y",1881,"^Z",24,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the squared magnitude over all elements in an array.\n\n   This may be more efficient that computing the magnitude in some implementations."],"^B","~$clojure.core.matrix/magnitude-squared","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",24,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1881,"^Y",1881,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Calculates the squared magnitude over all elements in an array.\n\n   This may be more efficient that computing the magnitude in some implementations."],"~$log10!",["^ ","^T",null,"^U",["^ ","^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log10 function on all elements of an array, using double precision values. Mutates the array in-place.","^V",null],"^B","~$clojure.core.matrix/log10!","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1942,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Computes the log10 function on all elements of an array, using double precision values. Mutates the array in-place."],"~$to-double-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",712,"^X",7,"^Y",712,"^Z",22,"^[",["^10",["^11",["^10",[["~$m"],["~$m","^<X"]]]]],"^14","Returns a Java double[] array containing the values of a numerical array m in row-major order. Will\n    throw an error if any of the array elements cannot be converted to doubles.\n\n    If want-copy? is true, will guarantee a new double array (defensive copy).\n    If want-copy? is false, will return the internal array used by m, or nil if not supported\n    by the implementation.\n    If want-copy? is not specified, will return either a copy or the internal array","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^<X"]]],"^[",["^10",[["~$m"],["~$m","^<X"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/to-double-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",22,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["~$m"],["~$m","^<X"]]],"^[",["^10",[["~$m"],["~$m","^<X"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m"],["~$m","^<X"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",712,"^Y",712,"^17",2,"^1<",true,"^[",["^10",[["~$m"],["~$m","^<X"]]],"^14","Returns a Java double[] array containing the values of a numerical array m in row-major order. Will\n    throw an error if any of the array elements cannot be converted to doubles.\n\n    If want-copy? is true, will guarantee a new double array (defensive copy).\n    If want-copy? is false, will return the internal array used by m, or nil if not supported\n    by the implementation.\n    If want-copy? is not specified, will return either a copy or the internal array"],"~$element-type",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",551,"^X",7,"^Y",551,"^Z",19,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the class of elements that can be in the array. For example, a numerical array may return\n   the class java.lang.Double."],"^B","~$clojure.core.matrix/element-type","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",19,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",551,"^Y",551,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Returns the class of elements that can be in the array. For example, a numerical array may return\n   the class java.lang.Double."],"~$non-zero-count",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2041,"^X",7,"^Y",2041,"^Z",21,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Counts the number of non-zero values in a numerical array.\n   May perform a full array scan, but will often be quicker for specialised\n   sparse arrays - sometimes as fast as O(1)"],"^B","~$clojure.core.matrix/non-zero-count","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",21,"^18",["^10",[["~$m"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",2041,"^Y",2041,"^17",1,"^1<",true,"^[",["^10",["^11",["^10",[["~$m"]]]]],"^14","Counts the number of non-zero values in a numerical array.\n   May perform a full array scan, but will often be quicker for specialised\n   sparse arrays - sometimes as fast as O(1)"],"~$emap-indexed!",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",2179,"^X",7,"^Y",2179,"^Z",20,"^[",["^10",["^11",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]]]],"^14","Element-wise map-indexed over all elements of one or more arrays.\n\n   f must accept as first argument the index vector of the current element,\n   and return a result compatible with the element-type of the array m\n\n   Performs in-place modification of the first array argument.","^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]]],"^B","~$clojure.core.matrix/emap-indexed!","^16",true,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",20,"^15",["^ ","^16",true,"^17",3,"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^19",["^10",[null,null,null]]],"^18",["^10",[["~$f","~$m"],["~$f","~$m","~$a"]]],"^1;",null,"^19",["^10",[null,null,null]],"^X",1,"^W",2179,"^Y",2179,"^17",3,"^1<",true,"^[",["^10",[["~$f","~$m"],["~$f","~$m","~$a"],["~$f","~$m","~$a","~$&","^1@"]]],"^14","Element-wise map-indexed over all elements of one or more arrays.\n\n   f must accept as first argument the index vector of the current element,\n   and return a result compatible with the element-type of the array m\n\n   Performs in-place modification of the first array argument."],"~$coerce",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",749,"^X",7,"^Y",749,"^Z",13,"^[",["^10",["^11",["^10",[["~$param"],["~$matrix-or-implementation","^>A"]]]]],"^14","Coerces param (which may be any array) into a format preferred by a specific matrix implementation.\n   If the matrix implementation is not specified, uses the current matrix implementation.\n   If param is already in a format deemed usable by the implementation, may return it unchanged.\n\n   coerce should never alter the shape of the array, but may convert element types where necessary\n   (e.g. turning real values into complex values when converting to a complex array type).","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^>A"],["^>B","^>A"]]],"^[",["^10",[["^>A"],["^>B","^>A"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/coerce","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",13,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^>A"],["^>B","^>A"]]],"^[",["^10",[["^>A"],["^>B","^>A"]]],"^19",["^10",[null,null]]],"^18",["^10",[["^>A"],["^>B","^>A"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",749,"^Y",749,"^17",2,"^1<",true,"^[",["^10",[["^>A"],["^>B","^>A"]]],"^14","Coerces param (which may be any array) into a format preferred by a specific matrix implementation.\n   If the matrix implementation is not specified, uses the current matrix implementation.\n   If param is already in a format deemed usable by the implementation, may return it unchanged.\n\n   coerce should never alter the shape of the array, but may convert element types where necessary\n   (e.g. turning real values into complex values when converting to a complex array type)."],"~$order",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",1125,"^X",7,"^Y",1125,"^Z",12,"^[",["^10",["^11",["^10",[["~$m","^3J"],["~$m","^2A","^3J"]]]]],"^14","Reorders slices of an array along a specified dimension. Re-orders along major dimension\n   if no dimension is specified.\n\n   Indicies can be any seqable object containing the indices along the specified dimension to select.\n   An index can be selected multiple times (which created repreated slices), or not at all (which excludes\n   the slice from the result).","^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^3J"],["~$m","^2A","^3J"]]],"^[",["^10",[["~$m","^3J"],["~$m","^2A","^3J"]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/order","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",12,"^15",["^ ","^16",false,"^17",3,"^18",["^10",[["~$m","^3J"],["~$m","^2A","^3J"]]],"^[",["^10",[["~$m","^3J"],["~$m","^2A","^3J"]]],"^19",["^10",[null,null]]],"^18",["^10",[["~$m","^3J"],["~$m","^2A","^3J"]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",1125,"^Y",1125,"^17",3,"^1<",true,"^[",["^10",[["~$m","^3J"],["~$m","^2A","^3J"]]],"^14","Reorders slices of an array along a specified dimension. Re-orders along major dimension\n   if no dimension is specified.\n\n   Indicies can be any seqable object containing the indices along the specified dimension to select.\n   An index can be selected multiple times (which created repreated slices), or not at all (which excludes\n   the slice from the result)."],"~$zero-array",["^ ","^T",null,"^U",["^ ","^V","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix.cljc","^W",169,"^X",7,"^Y",169,"^Z",17,"^[",["^10",["^11",["^10",[["^5="],["^13","^5="]]]]],"^14","Creates a new zero-filled numerical array with the given shape.","^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5="],["^13","^5="]]],"^[",["^10",[["^5="],["^13","^5="]]],"^19",["^10",[null,null]]]],"^B","~$clojure.core.matrix/zero-array","^16",false,"^V","resources/public/js/clojure/core/matrix.cljc","^Z",17,"^15",["^ ","^16",false,"^17",2,"^18",["^10",[["^5="],["^13","^5="]]],"^[",["^10",[["^5="],["^13","^5="]]],"^19",["^10",[null,null]]],"^18",["^10",[["^5="],["^13","^5="]]],"^1;",null,"^19",["^10",[null,null]],"^X",1,"^W",169,"^Y",169,"^17",2,"^1<",true,"^[",["^10",[["^5="],["^13","^5="]]],"^14","Creates a new zero-filled numerical array with the given shape."]],"~:require-macros",["^ ","^8","^8","^;","^;","^L","^M","^M","^M","^P","^P","^N","^E","^E","^E","^J","^H","^H","^H"],"~:cljs.analyzer/constants",["^ ","~:seen",["^>",["~:else","~:all","~:first","~:butlast","~:last","~:rest"]],"~:order",["^>K","^>L","^>O","^>N","^>M","^>P"]],"^14","Main namespace for the core.matrix array programming API. \n\n   Contains all of the most common array programing functions. Arguments can generally be:\n    - A scalar value, e.g. the double 1.7\n    - A valid core.matrix array, e.g. [[1 2] [3 4]] as a 2D matrix or [1 2 3] as a 1D vector\n\n   Functions in this API may be supported by multiple matrix implementations, allowing code that uses\n   this API to quickly switch between implementations without significant changes (if any). The precise\n   imnplementation used is generally the first array argument to any API function - this is intended to\n   be consistent with conventions for Clojure protocol dispatch. The precise results of operations\n   may be implementation-dependent, subject to the constraints stated in the docstrings."]