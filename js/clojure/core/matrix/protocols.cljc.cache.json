["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ ","~$error","~$clojure.core.matrix.macros"],"~:excludes",["~#set",["~$clone"]],"~:name","~$clojure.core.matrix.protocols","~:imports",null,"~:requires",["^ ","~$clojure.core.matrix.utils","^>","~$mops","~$clojure.core.matrix.impl.mathsops","^@","^@"],"~:uses",["^ ","~$same-shape-object?","^>"],"~:defs",["^ ","~$sparse",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","~:line",206,"~:column",4,"~:end-line",206,"~:end-column",10,"~:protocol","~$clojure.core.matrix.protocols/PSparse","~:doc","Attempts to make array into a sparse format. Must return the same array unchanged if not possible.","~:arglists",["~#list",["~$quote",["^P",[["~$m"]]]]]],"^L","^M","^:","~$clojure.core.matrix.protocols/sparse","~:variadic",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"~:method-params",["^P",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^I",1,"^H",199,"^J",206,"~:max-fixed-arity",1,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Attempts to make array into a sparse format. Must return the same array unchanged if not possible."],"~$PIndicesSetting",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1134,"^I",14,"^J",1134,"^K",29,"^N","Protocol for setting elements of an array at the specified indices","~:protocol-symbol",true,"~:jsdoc",["^P",["@interface"]],"~:protocol-info",["^ ","~:methods",["^ ","~$set-indices",[["~$a","~$indices","~$values"]],"~$set-indices!",[["~$a","^13","^14"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PIndicesSetting","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",1134,"^10",["^ ","^11",["^ ","^12",[["~$a","^13","^14"]],"^15",[["~$a","^13","^14"]]]],"~:info",null,"^J",1134,"~:tag","~$any","~:impls",["^8",[]],"^N","Protocol for setting elements of an array at the specified indices","^[",["^P",["@interface"]]],"~$element-clamp",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",955,"^I",4,"^J",955,"^K",17,"^L","~$clojure.core.matrix.protocols/PElementMinMax","^N","Returns a matrix where the elements are clamped to be within lower and\n    upper bounds specified by a and b, respectively.","^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]]],"^L","^1<","^:","~$clojure.core.matrix.protocols/element-clamp","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",950,"^J",955,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]],"^N","Returns a matrix where the elements are clamped to be within lower and\n    upper bounds specified by a and b, respectively."],"~$sqrt!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",939,"^I",4,"^J",939,"^K",9,"^L","~$clojure.core.matrix.protocols/PMathsFunctionsMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/sqrt!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",939,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$select-columns",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1218,"^I",4,"^J",1218,"^K",18,"^L","~$clojure.core.matrix.protocols/PDatasetImplementation","^N","Produces a new dataset with the columns in the specified order","^O",["^P",["^Q",["^P",[["~$ds","~$cols"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/select-columns","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["^1C","^1D"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1218,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["^1C","^1D"]]]]],"^N","Produces a new dataset with the columns in the specified order"],"~$relu!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",864,"^I",4,"^J",864,"^K",9,"^L","~$clojure.core.matrix.protocols/PReLUMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1G","^:","~$clojure.core.matrix.protocols/relu!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",862,"^J",864,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$rename-columns",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1222,"^I",4,"^J",1222,"^K",18,"^L","^1B","^N","Renames columns based on map of old new column name pairs","^O",["^P",["^Q",["^P",[["^1C","~$col-map"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/rename-columns","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["^1C","^1J"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1222,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["^1C","^1J"]]]]],"^N","Renames columns based on map of old new column name pairs"],"~$is-mutable?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",109,"^I",4,"^J",109,"^K",15,"^L","~$clojure.core.matrix.protocols/PIndexedSetting","^N","Returns true if the matrix is mutable and therefore supports direct mutable operations, e.g. add!","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1M","^:","~$clojure.core.matrix.protocols/is-mutable?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",102,"^J",109,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the matrix is mutable and therefore supports direct mutable operations, e.g. add!"],"~$PVectorisable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",786,"^I",14,"^J",786,"^K",27,"^N","Protocol to return an array as a flattened vector of all elements.\n   Implementations are encouraged to avoid taking a full copy of all data\n   (e.g. by using structural sharing or views).","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$to-vector",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PVectorisable","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",786,"^10",["^ ","^11",["^ ","^1P",[["~$m"]]]],"^17",null,"^J",786,"^18","^19","^1:",["^8",[]],"^N","Protocol to return an array as a flattened vector of all elements.\n   Implementations are encouraged to avoid taking a full copy of all data\n   (e.g. by using structural sharing or views).","^[",["^P",["@interface"]]],"~$dense",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",217,"^I",4,"^J",217,"^K",9,"^L","~$clojure.core.matrix.protocols/PDense","^N","Attempts to make array into a dense format. Must return the same array unchanged if not possible.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1S","^:","~$clojure.core.matrix.protocols/dense","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",214,"^J",217,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Attempts to make array into a dense format. Must return the same array unchanged if not possible."],"~$sparse-coerce",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",205,"^I",4,"^J",205,"^K",17,"^L","^M","^N","Attempts to coerce data to a sparse array of implementation m. May return nil if not supported","^O",["^P",["^Q",["^P",[["~$m","~$data"]]]]]],"^L","^M","^:","~$clojure.core.matrix.protocols/sparse-coerce","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","^1V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",199,"^J",205,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]],"^N","Attempts to coerce data to a sparse array of implementation m. May return nil if not supported"],"~$PSoftplus",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",850,"^I",14,"^J",850,"^K",23,"^N","Protocol to support element-wise softplus function on a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$softplus",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSoftplus","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",850,"^10",["^ ","^11",["^ ","^1Y",[["~$m"]]]],"^17",null,"^J",850,"^18","^19","^1:",["^8",[]],"^N","Protocol to support element-wise softplus function on a numerical array.","^[",["^P",["@interface"]]],"~$PSpecialisedConstructors",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",249,"^I",14,"^J",249,"^K",38,"^N","Protocol for construction of special matrices.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$identity-matrix",[["~$m","~$dims"]],"~$diagonal-matrix",[["~$m","~$diagonal-values"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSpecialisedConstructors","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",38,"^I",1,"^H",249,"^10",["^ ","^11",["^ ","^20",[["~$m","^21"]],"^22",[["~$m","^23"]]]],"^17",null,"^J",249,"^18","^19","^1:",["^8",[]],"^N","Protocol for construction of special matrices.","^[",["^P",["@interface"]]],"~$PMatrixMutableScaling",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",616,"^I",14,"^J",616,"^K",35,"^N","Protocol to support mutable array scaling by scalar values.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$scale!",[["~$m","~$factor"]],"~$pre-scale!",[["~$m","^27"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PMatrixMutableScaling","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",35,"^I",1,"^H",616,"^10",["^ ","^11",["^ ","^26",[["~$m","^27"]],"^28",[["~$m","^27"]]]],"^17",null,"^J",616,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable array scaling by scalar values.","^[",["^P",["@interface"]]],"~$validate-shape",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",168,"^I",4,"^J",168,"^K",18,"^L","~$clojure.core.matrix.protocols/PValidateShape","^N","Returns the shape of the array, performing validation and throwing an error if the shape is inconsistent","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^2;","^:","~$clojure.core.matrix.protocols/validate-shape","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",165,"^J",168,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the shape of the array, performing validation and throwing an error if the shape is inconsistent"],"~$rotate-all",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",714,"^I",4,"^J",714,"^K",14,"^L","~$clojure.core.matrix.protocols/PRotateAll","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$shifts"]]]]]],"^L","^2>","^:","~$clojure.core.matrix.protocols/rotate-all","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","^2?"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",710,"^J",714,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2?"]]]]],"^N",null],"~$get-slice",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",350,"^I",4,"^J",350,"^K",13,"^L","~$clojure.core.matrix.protocols/PMatrixSlices","^N","Gets a slice of an array along a specified dimension with the given index.","^O",["^P",["^Q",["^P",[["~$m","~$dimension","~$i"]]]]]],"^L","^2B","^:","~$clojure.core.matrix.protocols/get-slice","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m","^2C","~$i"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",341,"^J",350,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2C","~$i"]]]]],"^N","Gets a slice of an array along a specified dimension with the given index."],"~$PColumnNames",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1162,"^I",14,"^J",1162,"^K",26,"^N","Protocol for arrays supporting labelled columns. This is a specialisation of label functionality\n   intended for use by datasets, the key difference is that column-names should always select the\n   last dimension.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$column-name",[["~$m","~$column"]],"~$column-names",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PColumnNames","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",1162,"^10",["^ ","^11",["^ ","^2F",[["~$m","^2G"]],"^2H",[["~$m"]]]],"^17",null,"^J",1162,"^18","^19","^1:",["^8",[]],"^N","Protocol for arrays supporting labelled columns. This is a specialisation of label functionality\n   intended for use by datasets, the key difference is that column-names should always select the\n   last dimension.","^[",["^P",["@interface"]]],"~$numerical?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",750,"^I",4,"^J",750,"^K",14,"^L","~$clojure.core.matrix.protocols/PNumerical","^N","Returns true if the array is numerical.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^2K","^:","~$clojure.core.matrix.protocols/numerical?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",747,"^J",750,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the array is numerical."],"~$PVectorCross",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",771,"^I",14,"^J",771,"^K",26,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$cross-product",[["~$a","~$b"]],"~$cross-product!",[["~$a","~$b"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PVectorCross","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",771,"^10",["^ ","^11",["^ ","^2N",[["~$a","~$b"]],"^2O",[["~$a","~$b"]]]],"^17",null,"^J",771,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"~$PNorm",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1179,"^I",14,"^J",1179,"^K",19,"^N","Protocol for matrix and vector norms","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$norm",[["~$m","~$p"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PNorm","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^I",1,"^H",1179,"^10",["^ ","^11",["^ ","^2R",[["~$m","~$p"]]]],"^17",null,"^J",1179,"^18","^19","^1:",["^8",[]],"^N","Protocol for matrix and vector norms","^[",["^P",["@interface"]]],"~$PNewSparseArray",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",433,"^I",14,"^J",433,"^K",29,"^N","Protocol for constructing sparse arrays. Should return nil if the sparse array shape is not supported.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$new-sparse-array",[["~$m","~$shape"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PNewSparseArray","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",433,"^10",["^ ","^11",["^ ","^2U",[["~$m","^2V"]]]],"^17",null,"^J",433,"^18","^19","^1:",["^8",[]],"^N","Protocol for constructing sparse arrays. Should return nil if the sparse array shape is not supported.","^[",["^P",["@interface"]]],"~$distance",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",778,"^I",4,"^J",778,"^K",12,"^L","~$clojure.core.matrix.protocols/PVectorDistance","^N","Euclidean distance of two vectors.","^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^2Y","^:","~$clojure.core.matrix.protocols/distance","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",777,"^J",778,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Euclidean distance of two vectors."],"~$PSparseArray",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",426,"^I",14,"^J",426,"^K",26,"^N","Protocol for determining if an array is in a sparse format. It is up to the implementation to define\n   its own sparse formats, but in general the intention should be that a sparse array uses significantly\n   less storage than an equivalent dense array, assuming a high proportion of zero values in the array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$is-sparse?",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSparseArray","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",426,"^10",["^ ","^11",["^ ","^30",[["~$m"]]]],"^17",null,"^J",426,"^18","^19","^1:",["^8",[]],"^N","Protocol for determining if an array is in a sparse format. It is up to the implementation to define\n   its own sparse formats, but in general the intention should be that a sparse array uses significantly\n   less storage than an equivalent dense array, assuming a high proportion of zero values in the array.","^[",["^P",["@interface"]]],"~$diagonal?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1083,"^I",4,"^J",1083,"^K",13,"^L","~$clojure.core.matrix.protocols/PMatrixTypes","^N","Returns true if the matrix is diagonal, i.e. zero everywhere except the main diagonal","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^33","^:","~$clojure.core.matrix.protocols/diagonal?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1082,"^J",1083,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the matrix is diagonal, i.e. zero everywhere except the main diagonal"],"~$add-inner-product!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",655,"^I",4,"^J",655,"^K",22,"^L","~$clojure.core.matrix.protocols/PAddInnerProductMutable","^N","Adds the inner product of a, b and an optional scalar factor to m","^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]]],"~:top-fn",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^V",["^P",[null,null]]]],"^L","^36","^:","~$clojure.core.matrix.protocols/add-inner-product!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",651,"^J",655,"^W",4,"^X",true,"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^N","Adds the inner product of a, b and an optional scalar factor to m"],"~$positive-semidefinite?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1087,"^I",4,"^J",1087,"^K",26,"^L","^33","^N","Returns true if the matrix is positive semidefinite","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^33","^:","~$clojure.core.matrix.protocols/positive-semidefinite?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1082,"^J",1087,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the matrix is positive semidefinite"],"~$PMapIndexed",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1048,"^I",14,"^J",1048,"^K",25,"^N","Protocol for map-indexed operation on matrices","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$element-map-indexed",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","~$more"]],"~$element-map-indexed!",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PMapIndexed","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",1048,"^10",["^ ","^11",["^ ","^3<",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]],"^3>",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]],"^17",null,"^J",1048,"^18","^19","^1:",["^8",[]],"^N","Protocol for map-indexed operation on matrices","^[",["^P",["@interface"]]],"~$PSoftplusMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",854,"^I",14,"^J",854,"^K",30,"^N","Protocol to support mutable element-wise softplus function on a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$softplus!",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSoftplusMutable","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",854,"^10",["^ ","^11",["^ ","^3A",[["~$m"]]]],"^17",null,"^J",854,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable element-wise softplus function on a numerical array.","^[",["^P",["@interface"]]],"~$identity-matrix?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1072,"^I",4,"^J",1072,"^K",20,"^L","~$clojure.core.matrix.protocols/PMatrixPredicates","^N","Returns true if the matrix m is an identity matrix","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3D","^:","~$clojure.core.matrix.protocols/identity-matrix?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1070,"^J",1072,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the matrix m is an identity matrix"],"^28",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",619,"^I",4,"^J",619,"^K",14,"^L","^29","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^27"]]]]]],"^L","^29","^:","~$clojure.core.matrix.protocols/pre-scale!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",616,"^J",619,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^27"]]]]],"^N",null],"~$to-radians",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",919,"^I",4,"^J",919,"^K",14,"^L","~$clojure.core.matrix.protocols/PMathsFunctions","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/to-radians","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",919,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PMatrixCloning",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",125,"^I",14,"^J",125,"^K",28,"^N","Protocol for cloning a matrix value. The new clone must be mutable if the original\n   matrix is mutable, i.e. mutating the clone must not affect the original. The copy should be shallow, if applicable.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^9",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PMatrixCloning","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",125,"^10",["^ ","^11",["^ ","^9",[["~$m"]]]],"^17",null,"^J",125,"^18","^19","^1:",["^8",[]],"^N","Protocol for cloning a matrix value. The new clone must be mutable if the original\n   matrix is mutable, i.e. mutating the clone must not affect the original. The copy should be shallow, if applicable.","^[",["^P",["@interface"]]],"~$new-scalar-array",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",227,"^I",4,"^J",227,"^K",20,"^L","~$clojure.core.matrix.protocols/PZeroDimensionConstruction","^N","Construct a new zero-dimensional array with the specified scalar value (zero if not specified)","^O",["^P",["^Q",["^P",[["~$m"],["~$m","~$value"]]]]],"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","^3N"]]],"^O",["^P",[["~$m"],["~$m","^3N"]]],"^V",["^P",[null,null]]]],"^L","^3M","^:","~$clojure.core.matrix.protocols/new-scalar-array","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","^3N"]]],"^O",["^P",[["~$m"],["~$m","^3N"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m"],["~$m","^3N"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",226,"^J",227,"^W",2,"^X",true,"^O",["^P",[["~$m"],["~$m","^3N"]]],"^N","Construct a new zero-dimensional array with the specified scalar value (zero if not specified)"],"~$set-1d!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",121,"^I",4,"^J",121,"^K",11,"^L","~$clojure.core.matrix.protocols/PIndexedSettingMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$row","~$v"]]]]]],"^L","^3Q","^:","~$clojure.core.matrix.protocols/set-1d!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","^3R","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",118,"^J",121,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3R","~$v"]]]]],"^N",null],"~$PReLUMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",862,"^I",14,"^J",862,"^K",26,"^N","Protocol to support mutable element-wise relu function on a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^1F",[["~$m"]]]]],"^Z",true,"^:","^1G","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",862,"^10",["^ ","^11",["^ ","^1F",[["~$m"]]]],"^17",null,"^J",862,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable element-wise relu function on a numerical array.","^[",["^P",["@interface"]]],"~$PMatrixScaling",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",604,"^I",14,"^J",604,"^K",28,"^N","Protocol to support numerical array scaling by scalar values. Provided because array classes may have\n   efficient specialised scaling operaions.\n\n   Works according the the default definition of multiplication for the matrix class\n   (usually numerical, i.e. equivalent to clojure.core/+)","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$scale",[["~$m","~$constant"]],"~$pre-scale",[["~$m","^3W"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PMatrixScaling","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",604,"^10",["^ ","^11",["^ ","^3V",[["~$m","^3W"]],"^3X",[["~$m","^3W"]]]],"^17",null,"^J",604,"^18","^19","^1:",["^8",[]],"^N","Protocol to support numerical array scaling by scalar values. Provided because array classes may have\n   efficient specialised scaling operaions.\n\n   Works according the the default definition of multiplication for the matrix class\n   (usually numerical, i.e. equivalent to clojure.core/+)","^[",["^P",["@interface"]]],"~$to-map",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1228,"^I",4,"^J",1228,"^K",10,"^L","~$clojure.core.matrix.protocols/PDatasetMaps","^N","Returns map of columns with associated list of values","^O",["^P",["^Q",["^P",[["^1C"]]]]]],"^L","^3[","^:","~$clojure.core.matrix.protocols/to-map","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["^1C"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1227,"^J",1228,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["^1C"]]]]],"^N","Returns map of columns with associated list of values"],"~$orthogonal?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1088,"^I",4,"^J",1088,"^K",15,"^L","^33","^N","Returns true if the matrix is orthogonal","^O",["^P",["^Q",["^P",[["~$m","~$eps"]]]]]],"^L","^33","^:","~$clojure.core.matrix.protocols/orthogonal?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","^42"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1082,"^J",1088,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^42"]]]]],"^N","Returns true if the matrix is orthogonal"],"~$PMatrixSubComponents",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",420,"^I",14,"^J",420,"^K",34,"^N","Protocol for picking out subsections of a 2D matrix. Should return a mutable view if possible.\n   The default implementation creates a new vector containing the diagonal values.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$main-diagonal",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PMatrixSubComponents","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",34,"^I",1,"^H",420,"^10",["^ ","^11",["^ ","^45",[["~$m"]]]],"^17",null,"^J",420,"^18","^19","^1:",["^8",[]],"^N","Protocol for picking out subsections of a 2D matrix. Should return a mutable view if possible.\n   The default implementation creates a new vector containing the diagonal values.","^[",["^P",["@interface"]]],"~$PIndexImplementation",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1145,"^I",14,"^J",1145,"^K",34,"^N","Protocol for determining if an object is a valid index. Implementations may implement this protocol to support their own index types.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$index?",[["~$m"]],"~$index-to-longs",[["~$m"]],"~$index-to-ints",[["~$m"]],"~$index-from-longs",[["~$m","~$xs"]],"~$index-from-ints",[["~$m","^4<"]],"~$index-coerce",[["~$m","~$a"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PIndexImplementation","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",34,"^I",1,"^H",1145,"^10",["^ ","^11",["^ ","^48",[["~$m"]],"^49",[["~$m"]],"^4:",[["~$m"]],"^4;",[["~$m","^4<"]],"^4=",[["~$m","^4<"]],"^4>",[["~$m","~$a"]]]],"^17",null,"^J",1145,"^18","^19","^1:",["^8",[]],"^N","Protocol for determining if an object is a valid index. Implementations may implement this protocol to support their own index types.","^[",["^P",["@interface"]]],"~$PAddScaledProduct",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",545,"^I",14,"^J",545,"^K",31,"^N","Protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b * factor","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$add-scaled-product",[["~$m","~$a","~$b","^27"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PAddScaledProduct","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",545,"^10",["^ ","^11",["^ ","^4A",[["~$m","~$a","~$b","^27"]]]],"^17",null,"^J",545,"^18","^19","^1:",["^8",[]],"^N","Protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b * factor","^[",["^P",["@interface"]]],"~$negate",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",811,"^I",4,"^J",811,"^K",10,"^L","~$clojure.core.matrix.protocols/PNegation","^N","Returns a new numerical array with all elements negated.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^4D","^:","~$clojure.core.matrix.protocols/negate","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",810,"^J",811,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns a new numerical array with all elements negated."],"~$set-2d!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",122,"^I",4,"^J",122,"^K",11,"^L","^3Q","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^3R","^2G","~$v"]]]]]],"^L","^3Q","^:","~$clojure.core.matrix.protocols/set-2d!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","^3R","^2G","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",118,"^J",122,"^W",4,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3R","^2G","~$v"]]]]],"^N",null],"~$PDense",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",214,"^I",14,"^J",214,"^K",20,"^N","Protocol for constructing a dense array from the given data.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$dense-coerce",[["~$m","^1V"]],"^1R",[["~$m"]]]]],"^Z",true,"^:","^1S","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^I",1,"^H",214,"^10",["^ ","^11",["^ ","^4I",[["~$m","^1V"]],"^1R",[["~$m"]]]],"^17",null,"^J",214,"^18","^19","^1:",["^8",[]],"^N","Protocol for constructing a dense array from the given data.","^[",["^P",["@interface"]]],"~$PPermutationMatrix",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",258,"^I",14,"^J",258,"^K",32,"^N","Protocol for construction of a permutation matrix.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$permutation-matrix",[["~$m","~$permutation"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PPermutationMatrix","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",32,"^I",1,"^H",258,"^10",["^ ","^11",["^ ","^4K",[["~$m","^4L"]]]],"^17",null,"^J",258,"^18","^19","^1:",["^8",[]],"^N","Protocol for construction of a permutation matrix.","^[",["^P",["@interface"]]],"~$asin!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",925,"^I",4,"^J",925,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/asin!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",925,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PImmutableMatrixConstruction",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",219,"^I",14,"^J",219,"^K",42,"^N","Protocol for creating an immutable copy of a matrix. If implemented, must return a fully immutable\n   copy of the given matrix.\n\n   The default implementation will attempt to choose a suitable immutable matrix implementation.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$immutable-matrix",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PImmutableMatrixConstruction","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",42,"^I",1,"^H",219,"^10",["^ ","^11",["^ ","^4Q",[["~$m"]]]],"^17",null,"^J",219,"^18","^19","^1:",["^8",[]],"^N","Protocol for creating an immutable copy of a matrix. If implemented, must return a fully immutable\n   copy of the given matrix.\n\n   The default implementation will attempt to choose a suitable immutable matrix implementation.","^[",["^P",["@interface"]]],"~$get-column",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",346,"^I",4,"^J",346,"^K",14,"^L","^2B","^N","Gets a column of a matrix with the given row index.","^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]]],"^L","^2B","^:","~$clojure.core.matrix.protocols/get-column","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$i"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",341,"^J",346,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]],"^N","Gets a column of a matrix with the given row index."],"~$cos!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",929,"^I",4,"^J",929,"^K",8,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/cos!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",929,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$svd",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1197,"^I",4,"^J",1197,"^K",7,"^L","~$clojure.core.matrix.protocols/PSVDDecomposition","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$options"]]]]]],"^L","^4X","^:","~$clojure.core.matrix.protocols/svd","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",7,"^T",["^P",[["~$m","^4Y"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1195,"^J",1197,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]],"^N",null],"~$ceil!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",928,"^I",4,"^J",928,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/ceil!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",928,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$POrder",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",731,"^I",14,"^J",731,"^K",20,"^N","Protocol for matrix reorder.\n\n   By default, re-orders along the first (major) dimension, but may reorder along any dimension by\n   specifiying the dimension argument.\n\n   Indicies can be any seqable object containing the indices along the specified dimension to select.\n   An index can be selected multiple times (which created repreated slices), or not at all (which excludes\n   the slice from the result).\n\n   Some implementation may implement re-ordering using lightweight or mutable views over the original array\n   data.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$order",[["~$m","^13"],["~$m","^2C","^13"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/POrder","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^I",1,"^H",731,"^10",["^ ","^11",["^ ","^52",[["~$m","^13"],["~$m","^2C","^13"]]]],"^17",null,"^J",731,"^18","^19","^1:",["^8",[]],"^N","Protocol for matrix reorder.\n\n   By default, re-orders along the first (major) dimension, but may reorder along any dimension by\n   specifiying the dimension argument.\n\n   Indicies can be any seqable object containing the indices along the specified dimension to select.\n   An index can be selected multiple times (which created repreated slices), or not at all (which excludes\n   the slice from the result).\n\n   Some implementation may implement re-ordering using lightweight or mutable views over the original array\n   data.","^[",["^P",["@interface"]]],"~$element-map",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1027,"^I",4,"^J",1027,"^K",15,"^L","~$clojure.core.matrix.protocols/PFunctionalOperations","^N","Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error.","^O",["^P",["^Q",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]]],"^L","^55","^:","~$clojure.core.matrix.protocols/element-map","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]],"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^U",null,"^V",["^P",[null,null,null]],"^I",1,"^H",1018,"^J",1027,"^W",4,"^X",true,"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^N","Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error."],"~$log",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",909,"^I",4,"^J",909,"^K",7,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/log","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",7,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",909,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^2F",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1166,"^I",4,"^J",1166,"^K",15,"^L","^2I","^N","Returns the label at a specific column","^O",["^P",["^Q",["^P",[["~$m","^2G"]]]]]],"^L","^2I","^:","~$clojure.core.matrix.protocols/column-name","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","^2G"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1162,"^J",1166,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2G"]]]]],"^N","Returns the label at a specific column"],"~$PSelectView",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1118,"^I",14,"^J",1118,"^K",25,"^N","Protocol for the sel function. Like PSelect, but guarantees an mutable view.\n\n   If not supported by the implementation, may return nil to indicate that a default mutable view\n   should be created.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$select-view",[["~$a","~$args"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSelectView","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",1118,"^10",["^ ","^11",["^ ","^5;",[["~$a","^5<"]]]],"^17",null,"^J",1118,"^18","^19","^1:",["^8",[]],"^N","Protocol for the sel function. Like PSelect, but guarantees an mutable view.\n\n   If not supported by the implementation, may return nil to indicate that a default mutable view\n   should be created.","^[",["^P",["@interface"]]],"~$acos",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",900,"^I",4,"^J",900,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/acos","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",900,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$element-multiply",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",523,"^I",4,"^J",523,"^K",20,"^L","~$clojure.core.matrix.protocols/PMatrixMultiply","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^5A","^:","~$clojure.core.matrix.protocols/element-multiply","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",517,"^J",523,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$to-degrees",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",918,"^I",4,"^J",918,"^K",14,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/to-degrees","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",918,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PPack",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",324,"^I",14,"^J",324,"^K",19,"^N","Protocol to efficiently pack an array, according to the most efficient representation for a given\n   implementation.\n\n   Definition of pack is up to the implementation to interpret, but the general rules are:\n   1. Must not change the value of the array for comparison purposes\n   2. Must not change the shape of the array\n   3. May preserve sparse representation\n   4. Should convert to most efficient format for common operations (e.g. mget, inner-product)","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$pack",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PPack","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^I",1,"^H",324,"^10",["^ ","^11",["^ ","^5F",[["~$m"]]]],"^17",null,"^J",324,"^18","^19","^1:",["^8",[]],"^N","Protocol to efficiently pack an array, according to the most efficient representation for a given\n   implementation.\n\n   Definition of pack is up to the implementation to interpret, but the general rules are:\n   1. Must not change the value of the array for comparison purposes\n   2. Must not change the shape of the array\n   3. May preserve sparse representation\n   4. Should convert to most efficient format for common operations (e.g. mget, inner-product)","^[",["^P",["@interface"]]],"~$PConversion",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",310,"^I",14,"^J",310,"^K",25,"^N","Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers,\n   however providing an efficient implementation is strongly encouraged to enable fast interop\n   with Clojure vectors.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$convert-to-nested-vectors",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PConversion","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",310,"^10",["^ ","^11",["^ ","^5I",[["~$m"]]]],"^17",null,"^J",310,"^18","^19","^1:",["^8",[]],"^N","Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers,\n   however providing an efficient implementation is strongly encouraged to enable fast interop\n   with Clojure vectors.","^[",["^P",["@interface"]]],"^5F",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",333,"^I",4,"^J",333,"^K",8,"^L","^5G","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^5G","^:","~$clojure.core.matrix.protocols/pack","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",324,"^J",333,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$floor",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",908,"^I",4,"^J",908,"^K",9,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/floor","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",908,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PZeroDimensionSet",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",245,"^I",14,"^J",245,"^K",31,"^N","Protocol for setting the scalar value in zero-dimensional arrays.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$set-0d",[["~$m","^3N"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PZeroDimensionSet","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",245,"^10",["^ ","^11",["^ ","^5O",[["~$m","^3N"]]]],"^17",null,"^J",245,"^18","^19","^1:",["^8",[]],"^N","Protocol for setting the scalar value in zero-dimensional arrays.","^[",["^P",["@interface"]]],"~$PLeastSquares",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1207,"^I",14,"^J",1207,"^K",27,"^N","Protocol for computing least-square solution to a linear matrix equation","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$least-squares",[["~$a","~$b"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PLeastSquares","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",1207,"^10",["^ ","^11",["^ ","^5R",[["~$a","~$b"]]]],"^17",null,"^J",1207,"^18","^19","^1:",["^8",[]],"^N","Protocol for computing least-square solution to a linear matrix equation","^[",["^P",["@interface"]]],"~$as-vector",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",782,"^I",4,"^J",782,"^K",13,"^L","~$clojure.core.matrix.protocols/PVectorView","^N","Returns a view of an array as a single flattened vector. May return the vector itself\n     if it is already a 1D vector.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^5U","^:","~$clojure.core.matrix.protocols/as-vector","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",781,"^J",782,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns a view of an array as a single flattened vector. May return the vector itself\n     if it is already a 1D vector."],"~$matrix-multiply!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",592,"^I",4,"^J",592,"^K",20,"^L","~$clojure.core.matrix.protocols/PMatrixMultiplyMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^5X","^:","~$clojure.core.matrix.protocols/matrix-multiply!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",590,"^J",592,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$PExponent",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",831,"^I",14,"^J",831,"^K",23,"^N","Protocol to support the 'pow' function. Should raise every element of a matrix to a\n   given exponent. Default implementation uses Java's Math/pow function which is appropriate for\n   double values: arrays supporting arbitrary precision numbers or complex types will need to\n   provide their own implementation.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$element-pow",[["~$m","~$exponent"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PExponent","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",831,"^10",["^ ","^11",["^ ","^5[",[["~$m","^60"]]]],"^17",null,"^J",831,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the 'pow' function. Should raise every element of a matrix to a\n   given exponent. Default implementation uses Java's Math/pow function which is appropriate for\n   double values: arrays supporting arbitrary precision numbers or complex types will need to\n   provide their own implementation.","^[",["^P",["@interface"]]],"~$PSVDDecomposition",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1195,"^I",14,"^J",1195,"^K",31,"^N","Protocol for SVD decomposition","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^4W",[["~$m","^4Y"]]]]],"^Z",true,"^:","^4X","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",1195,"^10",["^ ","^11",["^ ","^4W",[["~$m","^4Y"]]]],"^17",null,"^J",1195,"^18","^19","^1:",["^8",[]],"^N","Protocol for SVD decomposition","^[",["^P",["@interface"]]],"~$element-le",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",977,"^I",4,"^J",977,"^K",14,"^L","~$clojure.core.matrix.protocols/PCompare","^N","Return a binary array or matrix where elements of m less-than-or-equal\n    to a are  represented by 1 and elements greater-than a are represented as 0.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-le","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",977,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Return a binary array or matrix where elements of m less-than-or-equal\n    to a are  represented by 1 and elements greater-than a are represented as 0."],"~$PSummable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",826,"^I",14,"^J",826,"^K",23,"^N","Protocol to support the summing of all elements in an array.\n   The array must hold numeric values only, or an exception will be thrown.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$element-sum",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSummable","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",826,"^10",["^ ","^11",["^ ","^67",[["~$m"]]]],"^17",null,"^J",826,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the summing of all elements in an array.\n   The array must hold numeric values only, or an exception will be thrown.","^[",["^P",["@interface"]]],"^20",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",251,"^I",4,"^J",251,"^K",19,"^L","^24","^N","Create a 2D identity matrix with the given number of dimensions","^O",["^P",["^Q",["^P",[["~$m","^21"]]]]]],"^L","^24","^:","~$clojure.core.matrix.protocols/identity-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m","^21"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",249,"^J",251,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^21"]]]]],"^N","Create a 2D identity matrix with the given number of dimensions"],"^12",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1136,"^I",4,"^J",1136,"^K",15,"^L","^16","^N","sets the elements from a at indices to values. Returns a new array.","^O",["^P",["^Q",["^P",[["~$a","^13","^14"]]]]]],"^L","^16","^:","~$clojure.core.matrix.protocols/set-indices","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$a","^13","^14"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1134,"^J",1136,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","^13","^14"]]]]],"^N","sets the elements from a at indices to values. Returns a new array."],"~$broadcast-compatible",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1280,"^I",7,"^J",1280,"^K",27,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Broadcasts two matrices into identical shapes, coercing to the type of the first matrix.\n   Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."],"^:","~$clojure.core.matrix.protocols/broadcast-compatible","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1280,"^J",1280,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Broadcasts two matrices into identical shapes, coercing to the type of the first matrix.\n   Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."],"^48",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1147,"^I",4,"^J",1147,"^K",10,"^L","^4?","^N","Returns true if the argument is a valid index, false otherwise","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^4?","^:","~$clojure.core.matrix.protocols/index?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1145,"^J",1147,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the argument is a valid index, false otherwise"],"~$tanh",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",917,"^I",4,"^J",917,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/tanh","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",917,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$join",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",406,"^I",4,"^J",406,"^K",8,"^L","~$clojure.core.matrix.protocols/PSliceJoin","^N","Concatenates a to m, along the major slice dimension","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^6A","^:","~$clojure.core.matrix.protocols/join","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",404,"^J",406,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Concatenates a to m, along the major slice dimension"],"^4A",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",549,"^I",4,"^J",549,"^K",22,"^L","^4B","^N","Adds the elementwise product of a, b and a scalar factor to m","^O",["^P",["^Q",["^P",[["~$m","~$a","~$b","^27"]]]]]],"^L","^4B","^:","~$clojure.core.matrix.protocols/add-scaled-product","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^T",["^P",[["~$m","~$a","~$b","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",545,"^J",549,"^W",4,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b","^27"]]]]],"^N","Adds the elementwise product of a, b and a scalar factor to m"],"~$matrix-sub",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",625,"^I",4,"^J",625,"^K",14,"^L","~$clojure.core.matrix.protocols/PMatrixAdd","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^6E","^:","~$clojure.core.matrix.protocols/matrix-sub","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",621,"^J",625,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$dimension-count",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",89,"^I",4,"^J",89,"^K",19,"^L","~$clojure.core.matrix.protocols/PDimensionInfo","^N","Returns the size of a specific dimension. Must throw an exception if the array does not\n     have the specified dimension.","^O",["^P",["^Q",["^P",[["~$m","~$dimension-number"]]]]]],"^L","^6H","^:","~$clojure.core.matrix.protocols/dimension-count","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m","^6I"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",75,"^J",89,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^6I"]]]]],"^N","Returns the size of a specific dimension. Must throw an exception if the array does not\n     have the specified dimension."],"~$PGenericValues",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1097,"^I",14,"^J",1097,"^K",28,"^N","Protocol for returning the generic/default values of a matrix implementation","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$generic-zero",[["~$m"]],"~$generic-one",[["~$m"]],"~$generic-value",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PGenericValues","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",1097,"^10",["^ ","^11",["^ ","^6L",[["~$m"]],"^6M",[["~$m"]],"^6N",[["~$m"]]]],"^17",null,"^J",1097,"^18","^19","^1:",["^8",[]],"^N","Protocol for returning the generic/default values of a matrix implementation","^[",["^P",["@interface"]]],"~$implementation-key",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",43,"^I",4,"^J",43,"^K",22,"^L","~$clojure.core.matrix.protocols/PImplementation","^N","Returns a keyword representing this implementation, that can be used to request array instances or\n     look up implementation metadata etc.\n\n     Each implementation should have one unique key. Official mapping of implementation keywords is\n     maintained in the var clojure.core.matrix.implementations/KNOWN-IMPLEMENTATIONS.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6Q","^:","~$clojure.core.matrix.protocols/implementation-key","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",40,"^J",43,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns a keyword representing this implementation, that can be used to request array instances or\n     look up implementation metadata etc.\n\n     Each implementation should have one unique key. Official mapping of implementation keywords is\n     maintained in the var clojure.core.matrix.implementations/KNOWN-IMPLEMENTATIONS."],"~$atan!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",926,"^I",4,"^J",926,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/atan!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",926,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$set-row",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",889,"^I",4,"^J",889,"^K",11,"^L","~$clojure.core.matrix.protocols/PRowSetting","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$i","^3R"]]]]]],"^L","^6V","^:","~$clojure.core.matrix.protocols/set-row","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","~$i","^3R"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",887,"^J",889,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i","^3R"]]]]],"^N",null],"~$PReshaping",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",316,"^I",14,"^J",316,"^K",24,"^N","Protocol to reshape matrices. Should support any new shape allowed by the implementation.\n   Must preserve row-major ordering of matrix elements.\n   If the original matrix is mutable, must return a new mutable copy of data.\n   If the new shape has less elements than the original shape, it is OK to truncate the remaining elements.\n   If the new shape requires more elements than the original shape, should throw an exception.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$reshape",[["~$m","^2V"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PReshaping","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",316,"^10",["^ ","^11",["^ ","^6Y",[["~$m","^2V"]]]],"^17",null,"^J",316,"^18","^19","^1:",["^8",[]],"^N","Protocol to reshape matrices. Should support any new shape allowed by the implementation.\n   Must preserve row-major ordering of matrix elements.\n   If the original matrix is mutable, must return a new mutable copy of data.\n   If the new shape has less elements than the original shape, it is OK to truncate the remaining elements.\n   If the new shape requires more elements than the original shape, should throw an exception.","^[",["^P",["@interface"]]],"~$PSliceJoin",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",404,"^I",14,"^J",404,"^K",24,"^N","Protocol for concatenating / joining arrays.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^6@",[["~$m","~$a"]]]]],"^Z",true,"^:","^6A","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",404,"^10",["^ ","^11",["^ ","^6@",[["~$m","~$a"]]]],"^17",null,"^J",404,"^18","^19","^1:",["^8",[]],"^N","Protocol for concatenating / joining arrays.","^[",["^P",["@interface"]]],"~$PRotate",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",704,"^I",14,"^J",704,"^K",21,"^N","Rotates an array along a specified dimension by the given number of places.\n\n   Rotating a dimension that does not exist has no effect on the array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$rotate",[["~$m","~$dim","~$places"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PRotate","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^I",1,"^H",704,"^10",["^ ","^11",["^ ","^71",[["~$m","^72","^73"]]]],"^17",null,"^J",704,"^18","^19","^1:",["^8",[]],"^N","Rotates an array along a specified dimension by the given number of places.\n\n   Rotating a dimension that does not exist has no effect on the array.","^[",["^P",["@interface"]]],"~$get-rows",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",355,"^I",4,"^J",355,"^K",12,"^L","~$clojure.core.matrix.protocols/PMatrixRows","^N","Returns the rows of a matrix, as a seqable object","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^76","^:","~$clojure.core.matrix.protocols/get-rows","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",353,"^J",355,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the rows of a matrix, as a seqable object"],"~$element-ge",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",983,"^I",4,"^J",983,"^K",14,"^L","^64","^N","Return a binary array or matrix where elements of m greater-than-or-equal\n    to a are  represented by 1 and elements less than a are represented as 0.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-ge","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",983,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Return a binary array or matrix where elements of m greater-than-or-equal\n    to a are  represented by 1 and elements less than a are represented as 0."],"~$PShift",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",716,"^I",14,"^J",716,"^K",20,"^N","Rotates an array using the specified shifts for each dimension. Newly shifted in elements\n   should be filled with the default scalar value (usually zero).","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$shift",[["~$m","^72","^73"]],"~$shift-all",[["~$m","^2?"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PShift","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^I",1,"^H",716,"^10",["^ ","^11",["^ ","^7;",[["~$m","^72","^73"]],"^7<",[["~$m","^2?"]]]],"^17",null,"^J",716,"^18","^19","^1:",["^8",[]],"^N","Rotates an array using the specified shifts for each dimension. Newly shifted in elements\n   should be filled with the default scalar value (usually zero).","^[",["^P",["@interface"]]],"~$select",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1116,"^I",4,"^J",1116,"^K",10,"^L","~$clojure.core.matrix.protocols/PSelect","^N","selects all elements at indices which are in the cartesian product of args","^O",["^P",["^Q",["^P",[["~$a","^5<"]]]]]],"^L","^7?","^:","~$clojure.core.matrix.protocols/select","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$a","^5<"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1113,"^J",1116,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","^5<"]]]]],"^N","selects all elements at indices which are in the cartesian product of args"],"~$add-scaled!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",572,"^I",4,"^J",572,"^K",15,"^L","~$clojure.core.matrix.protocols/PAddScaledMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a","^27"]]]]]],"^L","^7B","^:","~$clojure.core.matrix.protocols/add-scaled!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","~$a","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",566,"^J",572,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","^27"]]]]],"^N",null],"~$PArrayMetrics",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",159,"^I",14,"^J",159,"^K",27,"^N","Optional protocol for quick determination of array matrics","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$nonzero-count",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PArrayMetrics","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",159,"^10",["^ ","^11",["^ ","^7E",[["~$m"]]]],"^17",null,"^J",159,"^18","^19","^1:",["^8",[]],"^N","Optional protocol for quick determination of array matrics","^[",["^P",["@interface"]]],"^30",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",430,"^I",4,"^J",430,"^K",14,"^L","^31","^N","Returns true if the array is in a sparse format, as defined by the implementation.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^31","^:","~$clojure.core.matrix.protocols/is-sparse?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",426,"^J",430,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the array is in a sparse format, as defined by the implementation."],"~$new-matrix",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",66,"^I",4,"^J",66,"^K",14,"^L","^6Q","^N","Returns a new matrix (regular 2D matrix) with the given number of rows and columns, filled with numeric zero.","^O",["^P",["^Q",["^P",[["~$m","~$rows","~$columns"]]]]]],"^L","^6Q","^:","~$clojure.core.matrix.protocols/new-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","^7I","^7J"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",40,"^J",66,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^7I","^7J"]]]]],"^N","Returns a new matrix (regular 2D matrix) with the given number of rows and columns, filled with numeric zero."],"^7;",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",719,"^I",4,"^J",719,"^K",9,"^L","^7=","^N","Shift along a single specified dimension","^O",["^P",["^Q",["^P",[["~$m","^72","^73"]]]]]],"^L","^7=","^:","~$clojure.core.matrix.protocols/shift","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m","^72","^73"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",716,"^J",719,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^72","^73"]]]]],"^N","Shift along a single specified dimension"],"~$to-radians!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",943,"^I",4,"^J",943,"^K",15,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/to-radians!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",943,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$element-seq",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1022,"^I",4,"^J",1022,"^K",15,"^L","^55","^N","Must return a seqable object containing all elements of the matrix, in row-major order.\n     i.e. it must be possible to call clojure.core/seq on the result. Valid sequable objects may\n     include Java arrays, Clojure vectors/sequences, and any Java object that implement Iterable.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^55","^:","~$clojure.core.matrix.protocols/element-seq","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1018,"^J",1022,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Must return a seqable object containing all elements of the matrix, in row-major order.\n     i.e. it must be possible to call clojure.core/seq on the result. Valid sequable objects may\n     include Java arrays, Clojure vectors/sequences, and any Java object that implement Iterable."],"^1Y",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",852,"^I",4,"^J",852,"^K",12,"^L","^1Z","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1Z","^:","~$clojure.core.matrix.protocols/softplus","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",850,"^J",852,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$ceil",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",904,"^I",4,"^J",904,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/ceil","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",904,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$set-0d!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",241,"^I",4,"^J",241,"^K",11,"^L","~$clojure.core.matrix.protocols/PZeroDimensionAccess","^N","Sets the scalar value in the 0d array to a given value. Throws an error if not mutable.","^O",["^P",["^Q",["^P",[["~$m","^3N"]]]]]],"^L","^7U","^:","~$clojure.core.matrix.protocols/set-0d!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","^3N"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",232,"^J",241,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3N"]]]]],"^N","Sets the scalar value in the 0d array to a given value. Throws an error if not mutable."],"^1P",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",790,"^I",4,"^J",790,"^K",13,"^L","^1Q","^N","Returns an array as a single flattened vector","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1Q","^:","~$clojure.core.matrix.protocols/to-vector","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",786,"^J",790,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns an array as a single flattened vector"],"~$PFunctionalOperations",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1018,"^I",14,"^J",1018,"^K",35,"^N","Protocol to allow functional-style operations on matrix elements.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^7O",[["~$m"]],"^54",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]],"~$element-map!",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]],"~$element-reduce",[["~$m","~$f"],["~$m","~$f","~$init"]]]]],"^Z",true,"^:","^55","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",35,"^I",1,"^H",1018,"^10",["^ ","^11",["^ ","^7O",[["~$m"]],"^54",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]],"^7Y",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]],"^7Z",[["~$m","~$f"],["~$m","~$f","^7["]]]],"^17",null,"^J",1018,"^18","^19","^1:",["^8",[]],"^N","Protocol to allow functional-style operations on matrix elements.","^[",["^P",["@interface"]]],"~$PColumnSetting",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",892,"^I",14,"^J",892,"^K",28,"^N","Protocol for column setting. Should set a dimension 1 (column) slice to the given column value.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$set-column",[["~$m","~$i","^2G"]],"~$set-column!",[["~$m","~$i","^2G"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PColumnSetting","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",892,"^10",["^ ","^11",["^ ","^81",[["~$m","~$i","^2G"]],"^82",[["~$m","~$i","^2G"]]]],"^17",null,"^J",892,"^18","^19","^1:",["^8",[]],"^N","Protocol for column setting. Should set a dimension 1 (column) slice to the given column value.","^[",["^P",["@interface"]]],"~$get-slice-view",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",377,"^I",4,"^J",377,"^K",18,"^L","~$clojure.core.matrix.protocols/PSliceView2","^N","Gets a view of an array slice along the specified dimension.","^O",["^P",["^Q",["^P",[["~$m","^72","~$i"]]]]]],"^L","^85","^:","~$clojure.core.matrix.protocols/get-slice-view","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m","^72","~$i"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",370,"^J",377,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^72","~$i"]]]]],"^N","Gets a view of an array slice along the specified dimension."],"^3X",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",612,"^I",4,"^J",612,"^K",13,"^L","^3Y","^N","Pre-multiplies the array with the scalar constant. This is the same as scale for arrays\n     where multiplication is commutative, but may be different for special kinds of scalars.","^O",["^P",["^Q",["^P",[["~$m","^3W"]]]]]],"^L","^3Y","^:","~$clojure.core.matrix.protocols/pre-scale","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m","^3W"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",604,"^J",612,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3W"]]]]],"^N","Pre-multiplies the array with the scalar constant. This is the same as scale for arrays\n     where multiplication is commutative, but may be different for special kinds of scalars."],"~$PComputeMatrix",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",685,"^I",14,"^J",685,"^K",28,"^N","Protocol to compute a matrix by calling a function on each indexed location. The function f will be called\n   as (f x y z ...) for all index values.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$compute-matrix",[["~$m","^2V","~$f"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PComputeMatrix","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",685,"^10",["^ ","^11",["^ ","^89",[["~$m","^2V","~$f"]]]],"^17",null,"^J",685,"^18","^19","^1:",["^8",[]],"^N","Protocol to compute a matrix by calling a function on each indexed location. The function f will be called\n   as (f x y z ...) for all index values.","^[",["^P",["@interface"]]],"~$abs!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",923,"^I",4,"^J",923,"^K",8,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/abs!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",923,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$labels",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1160,"^I",4,"^J",1160,"^K",10,"^L","~$clojure.core.matrix.protocols/PDimensionLabels","^N","Returns all labels along a given dimension, as a vector","^O",["^P",["^Q",["^P",[["~$m","^72"]]]]]],"^L","^8>","^:","~$clojure.core.matrix.protocols/labels","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^72"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1157,"^J",1160,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^72"]]]]],"^N","Returns all labels along a given dimension, as a vector"],"~$zero-count",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",442,"^I",4,"^J",442,"^K",14,"^L","~$clojure.core.matrix.protocols/PZeroCount","^N","Returns the number of zeros in the array","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^8A","^:","~$clojure.core.matrix.protocols/zero-count","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",439,"^J",442,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the number of zeros in the array"],"~$swap-rows",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",880,"^I",4,"^J",880,"^K",13,"^L","~$clojure.core.matrix.protocols/PRowOperations","^N","Returns a new matrix with rows i and j swapped","^O",["^P",["^Q",["^P",[["~$m","~$i","~$j"]]]]]],"^L","^8D","^:","~$clojure.core.matrix.protocols/swap-rows","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m","~$i","~$j"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",878,"^J",880,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i","~$j"]]]]],"^N","Returns a new matrix with rows i and j swapped"],"~$select-rows",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1219,"^I",4,"^J",1219,"^K",15,"^L","^1B","^N","Produces a new dataset with specified rows","^O",["^P",["^Q",["^P",[["^1C","^7I"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/select-rows","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["^1C","^7I"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1219,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["^1C","^7I"]]]]],"^N","Produces a new dataset with specified rows"],"~$PNegation",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",810,"^I",14,"^J",810,"^K",23,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^4C",[["~$m"]]]]],"^Z",true,"^:","^4D","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",810,"^10",["^ ","^11",["^ ","^4C",[["~$m"]]]],"^17",null,"^J",810,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"~$PSparse",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",199,"^I",14,"^J",199,"^K",21,"^N","Protocol for constructing a sparse array from the given data. Implementations should\n   consider the possibility that data may be a large lazy sequence, possibly larger than memory, so should ideally\n   attempt to construct the sparse matrix incrementally without realising the whole sequence at once.\n\n   May return nil if no sparse conversion is available.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^1U",[["~$m","^1V"]],"^D",[["~$m"]]]]],"^Z",true,"^:","^M","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^I",1,"^H",199,"^10",["^ ","^11",["^ ","^1U",[["~$m","^1V"]],"^D",[["~$m"]]]],"^17",null,"^J",199,"^18","^19","^1:",["^8",[]],"^N","Protocol for constructing a sparse array from the given data. Implementations should\n   consider the possibility that data may be a large lazy sequence, possibly larger than memory, so should ideally\n   attempt to construct the sparse matrix incrementally without realising the whole sequence at once.\n\n   May return nil if no sparse conversion is available.","^[",["^P",["@interface"]]],"~$PSubMatrix",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",678,"^I",14,"^J",678,"^K",24,"^N","Protocol to get a subarray of another array. dim-ranges should be a sequence of [start len]\n   pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension.\n\n   Returning a mutable view is preferred, if the implementation supports this.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$submatrix",[["~$d","~$dim-ranges"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSubMatrix","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",678,"^10",["^ ","^11",["^ ","^8K",[["~$d","^8L"]]]],"^17",null,"^J",678,"^18","^19","^1:",["^8",[]],"^N","Protocol to get a subarray of another array. dim-ranges should be a sequence of [start len]\n   pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension.\n\n   Returning a mutable view is preferred, if the implementation supports this.","^[",["^P",["@interface"]]],"~$block-diagonal-matrix",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",264,"^I",4,"^J",264,"^K",25,"^L","~$clojure.core.matrix.protocols/PBlockDiagonalMatrix","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$blocks"]]]]]],"^L","^8O","^:","~$clojure.core.matrix.protocols/block-diagonal-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^T",["^P",[["~$m","^8P"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",262,"^J",264,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^8P"]]]]],"^N",null],"~$element-max",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",954,"^I",4,"^J",954,"^K",15,"^L","^1<","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1<","^:","~$clojure.core.matrix.protocols/element-max","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",950,"^J",954,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$multiply-row",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",882,"^I",4,"^J",882,"^K",16,"^L","^8D","^N","Returns a new matrix with row i multiplied by k","^O",["^P",["^Q",["^P",[["~$m","~$i","~$k"]]]]]],"^L","^8D","^:","~$clojure.core.matrix.protocols/multiply-row","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m","~$i","~$k"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",878,"^J",882,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i","~$k"]]]]],"^N","Returns a new matrix with row i multiplied by k"],"~$PMatrixPredicates",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1070,"^I",14,"^J",1070,"^K",31,"^N","Protocol for matrix predicates like identity-matrix? or zero-matrix?","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^3C",[["~$m"]],"~$zero-matrix?",[["~$m"]],"~$symmetric?",[["~$m"]]]]],"^Z",true,"^:","^3D","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",1070,"^10",["^ ","^11",["^ ","^3C",[["~$m"]],"^8W",[["~$m"]],"^8X",[["~$m"]]]],"^17",null,"^J",1070,"^18","^19","^1:",["^8",[]],"^N","Protocol for matrix predicates like identity-matrix? or zero-matrix?","^[",["^P",["@interface"]]],"~$log!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",933,"^I",4,"^J",933,"^K",8,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/log!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",933,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$vector-transform",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",601,"^I",4,"^J",601,"^K",20,"^L","~$clojure.core.matrix.protocols/PVectorTransform","^N","Transforms a vector","^O",["^P",["^Q",["^P",[["~$t","~$v"]]]]]],"^L","^90","^:","~$clojure.core.matrix.protocols/vector-transform","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$t","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",595,"^J",601,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$t","~$v"]]]]],"^N","Transforms a vector"],"~$PVectorTransform",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",595,"^I",14,"^J",595,"^K",30,"^N","Protocol to support transformation of a vector to another vector. Is equivalent to matrix multiplication\n   when 2D matrices are used as transformations. But other transformations are possible, e.g. non-affine\n   transformations.\n\n   A transformation need not be a core.matrix matrix: other types are permissible","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^8[",[["~$t","~$v"]],"~$vector-transform!",[["~$t","~$v"]]]]],"^Z",true,"^:","^90","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",595,"^10",["^ ","^11",["^ ","^8[",[["~$t","~$v"]],"^93",[["~$t","~$v"]]]],"^17",null,"^J",595,"^18","^19","^1:",["^8",[]],"^N","Protocol to support transformation of a vector to another vector. Is equivalent to matrix multiplication\n   when 2D matrices are used as transformations. But other transformations are possible, e.g. non-affine\n   transformations.\n\n   A transformation need not be a core.matrix matrix: other types are permissible","^[",["^P",["@interface"]]],"~$replace-column",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1223,"^I",4,"^J",1223,"^K",18,"^L","^1B","^N","Replaces column in a dataset with new values","^O",["^P",["^Q",["^P",[["^1C","~$col-name","~$vs"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/replace-column","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["^1C","^95","^96"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1223,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["^1C","^95","^96"]]]]],"^N","Replaces column in a dataset with new values"],"~$new-vector",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",64,"^I",4,"^J",64,"^K",14,"^L","^6Q","^N","Returns a new vector (1D column matrix) of the given length, filled with numeric zero.","^O",["^P",["^Q",["^P",[["~$m","~$length"]]]]]],"^L","^6Q","^:","~$clojure.core.matrix.protocols/new-vector","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","^99"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",40,"^J",64,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^99"]]]]],"^N","Returns a new vector (1D column matrix) of the given length, filled with numeric zero."],"~$persistent-vector-coerce",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1236,"^I",7,"^J",1236,"^K",31,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^N","Coerces a data structure to nested persistent vectors"],"^:","~$clojure.core.matrix.protocols/persistent-vector-coerce","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^T",["^P",[["~$x"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1236,"^J",1236,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^N","Coerces a data structure to nested persistent vectors"],"^67",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",829,"^I",4,"^J",829,"^K",15,"^L","^68","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^68","^:","~$clojure.core.matrix.protocols/element-sum","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",826,"^J",829,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$add-column",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1220,"^I",4,"^J",1220,"^K",14,"^L","^1B","^N","Adds column to the dataset","^O",["^P",["^Q",["^P",[["^1C","^95","~$col"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/add-column","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["^1C","^95","^9?"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1220,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["^1C","^95","^9?"]]]]],"^N","Adds column to the dataset"],"~$PDatasetImplementation",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1215,"^I",14,"^J",1215,"^K",36,"^N","Protocol for general dataset functionality","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^1A",[["^1C","^1D"]],"^1I",[["^1C","^1J"]],"^8F",[["^1C","^7I"]],"^94",[["^1C","^95","^96"]],"^9>",[["^1C","^95","^9?"]],"~$join-rows",[["~$ds1","~$ds2"]],"^7J",[["^1C"]],"~$join-columns",[["^9C","^9D"]],"~$merge-datasets",[["^9C","^9D"]]]]],"^Z",true,"^:","^1B","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",36,"^I",1,"^H",1215,"^10",["^ ","^11",["^ ","^1A",[["^1C","^1D"]],"^1I",[["^1C","^1J"]],"^8F",[["^1C","^7I"]],"^94",[["^1C","^95","^96"]],"^9>",[["^1C","^95","^9?"]],"^9B",[["^9C","^9D"]],"^7J",[["^1C"]],"^9E",[["^9C","^9D"]],"^9F",[["^9C","^9D"]]]],"^17",null,"^J",1215,"^18","^19","^1:",["^8",[]],"^N","Protocol for general dataset functionality","^[",["^P",["@interface"]]],"~$transpose!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",728,"^I",4,"^J",728,"^K",14,"^L","~$clojure.core.matrix.protocols/PTransposeInPlace","^N","Transposes a mutable 2D matrix in place","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^9H","^:","~$clojure.core.matrix.protocols/transpose!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",726,"^J",728,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Transposes a mutable 2D matrix in place"],"~$atan",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",902,"^I",4,"^J",902,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/atan","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",902,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PRowOperations",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",878,"^I",14,"^J",878,"^K",28,"^N","Protocol for elementary row operations","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^8C",[["~$m","~$i","~$j"]],"^8T",[["~$m","~$i","~$k"]],"~$add-row",[["~$m","~$i","~$j","~$k"]]]]],"^Z",true,"^:","^8D","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",878,"^10",["^ ","^11",["^ ","^8C",[["~$m","~$i","~$j"]],"^8T",[["~$m","~$i","~$k"]],"^9M",[["~$m","~$i","~$j","~$k"]]]],"^17",null,"^J",878,"^18","^19","^1:",["^8",[]],"^N","Protocol for elementary row operations","^[",["^P",["@interface"]]],"~$cosh!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",930,"^I",4,"^J",930,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/cosh!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",930,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PZeroDimensionAccess",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",232,"^I",14,"^J",232,"^K",34,"^N","Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ\n   from scalar values in the following two senses:\n    - They may be mutable (in which case set-0d! is expected to work)\n    - They are not considered themselves to be scalars. Hence you must use get-0d to access the\n      contained scalar value","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$get-0d",[["~$m"]],"^7T",[["~$m","^3N"]]]]],"^Z",true,"^:","^7U","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",34,"^I",1,"^H",232,"^10",["^ ","^11",["^ ","^9Q",[["~$m"]],"^7T",[["~$m","^3N"]]]],"^17",null,"^J",232,"^18","^19","^1:",["^8",[]],"^N","Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ\n   from scalar values in the following two senses:\n    - They may be mutable (in which case set-0d! is expected to work)\n    - They are not considered themselves to be scalars. Hence you must use get-0d to access the\n      contained scalar value","^[",["^P",["@interface"]]],"~$PEigenDecomposition",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1199,"^I",14,"^J",1199,"^K",33,"^N","Procotol for Eigenvalue decomposition","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$eigen",[["~$m","^4Y"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PEigenDecomposition","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",33,"^I",1,"^H",1199,"^10",["^ ","^11",["^ ","^9S",[["~$m","^4Y"]]]],"^17",null,"^J",1199,"^18","^19","^1:",["^8",[]],"^N","Procotol for Eigenvalue decomposition","^[",["^P",["@interface"]]],"^4>",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1152,"^I",4,"^J",1152,"^K",16,"^L","^4?","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^4?","^:","~$clojure.core.matrix.protocols/index-coerce","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1145,"^J",1152,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$new-matrix-nd",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",68,"^I",4,"^J",68,"^K",17,"^L","^6Q","^N","Returns a new general matrix of the given shape.\n     Must return nil if the shape is not supported by the implementation.\n     Shape can be any sequence of integer dimension sizes (including 0 dimensions).","^O",["^P",["^Q",["^P",[["~$m","^2V"]]]]]],"^L","^6Q","^:","~$clojure.core.matrix.protocols/new-matrix-nd","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","^2V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",40,"^J",68,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2V"]]]]],"^N","Returns a new general matrix of the given shape.\n     Must return nil if the shape is not supported by the implementation.\n     Shape can be any sequence of integer dimension sizes (including 0 dimensions)."],"~$PMathsFunctions",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",897,"^I",14,"^J",897,"^K",29,"^N","Protocol to support mathematical functions applied element-wise to a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^3G",[["~$m"]],"^57",[["~$m"]],"^5>",[["~$m"]],"^5C",[["~$m"]],"^5L",[["~$m"]],"^6>",[["~$m"]],"^7R",[["~$m"]],"^9J",[["~$m"]],"~$cos",[["~$m"]],"~$log10",[["~$m"]],"~$tan",[["~$m"]],"~$cbrt",[["~$m"]],"~$sqrt",[["~$m"]],"~$exp",[["~$m"]],"~$cosh",[["~$m"]],"~$asin",[["~$m"]],"~$round",[["~$m"]],"~$abs",[["~$m"]],"~$sinh",[["~$m"]],"~$sin",[["~$m"]],"~$signum",[["~$m"]]]]],"^Z",true,"^:","^3H","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",897,"^10",["^ ","^11",["^ ","^3G",[["~$m"]],"^57",[["~$m"]],"^5>",[["~$m"]],"^5C",[["~$m"]],"^5L",[["~$m"]],"^6>",[["~$m"]],"^7R",[["~$m"]],"^9J",[["~$m"]],"^9Y",[["~$m"]],"^9Z",[["~$m"]],"^9[",[["~$m"]],"^:0",[["~$m"]],"^:1",[["~$m"]],"^:2",[["~$m"]],"^:3",[["~$m"]],"^:4",[["~$m"]],"^:5",[["~$m"]],"^:6",[["~$m"]],"^:7",[["~$m"]],"^:8",[["~$m"]],"^:9",[["~$m"]]]],"^17",null,"^J",897,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mathematical functions applied element-wise to a numerical array.","^[",["^P",["@interface"]]],"~$PCoercion",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",266,"^I",14,"^J",266,"^K",23,"^N","Protocol to coerce a parameter to a format used by a specific implementation. It is\n   up to the implementation to determine what parameter types they support.\n   If the implementation is unable to perform coercion, it must return nil.\n\n   Implementations are encouraged to avoid taking a full copy of the data, for performance reasons.\n   It is preferable to use structural sharing with the original data if possible.\n\n   If coercion is impossible (e.g. param has an invalid shape or element types) then the\n   implementation *may* throw an exception, though it may also return nil to get default behaviour,\n   which should implement any expected exceptions.\n\n   If an implementation implements coercion via copying, then it is recommended that conversion\n   should be to the most efficient packed representation (i.e. as defined by 'pack')\n\n   Implementations must also be able to coerce valid scalar values (presumably via the identity function)","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$coerce-param",[["~$m","~$param"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PCoercion","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",266,"^10",["^ ","^11",["^ ","^:;",[["~$m","^:<"]]]],"^17",null,"^J",266,"^18","^19","^1:",["^8",[]],"^N","Protocol to coerce a parameter to a format used by a specific implementation. It is\n   up to the implementation to determine what parameter types they support.\n   If the implementation is unable to perform coercion, it must return nil.\n\n   Implementations are encouraged to avoid taking a full copy of the data, for performance reasons.\n   It is preferable to use structural sharing with the original data if possible.\n\n   If coercion is impossible (e.g. param has an invalid shape or element types) then the\n   implementation *may* throw an exception, though it may also return nil to get default behaviour,\n   which should implement any expected exceptions.\n\n   If an implementation implements coercion via copying, then it is recommended that conversion\n   should be to the most efficient packed representation (i.e. as defined by 'pack')\n\n   Implementations must also be able to coerce valid scalar values (presumably via the identity function)","^[",["^P",["@interface"]]],"~$PRowSetting",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",887,"^I",14,"^J",887,"^K",25,"^N","Protocol for row setting. Should set a dimension 0 (row) slice to thegiven row value.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^6U",[["~$m","~$i","^3R"]],"~$set-row!",[["~$m","~$i","^3R"]]]]],"^Z",true,"^:","^6V","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",887,"^10",["^ ","^11",["^ ","^6U",[["~$m","~$i","^3R"]],"^:?",[["~$m","~$i","^3R"]]]],"^17",null,"^J",887,"^18","^19","^1:",["^8",[]],"^N","Protocol for row setting. Should set a dimension 0 (row) slice to thegiven row value.","^[",["^P",["@interface"]]],"~$get-major-slice-view-seq",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",402,"^I",4,"^J",402,"^K",28,"^L","~$clojure.core.matrix.protocols/PSliceViewSeq","^N","Gets a sequence of all major array slices","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^:A","^:","~$clojure.core.matrix.protocols/get-major-slice-view-seq","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",397,"^J",402,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Gets a sequence of all major array slices"],"~$ensure-mutable",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",195,"^I",4,"^J",195,"^K",18,"^L","~$clojure.core.matrix.protocols/PMutableCoercion","^N","Returns this array if fully mutable, otherwise returns a new mutable array containing\n                   a copy of this array. May return nil if the implementation cannot create a suitable mutable\n                   array.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^:D","^:","~$clojure.core.matrix.protocols/ensure-mutable","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",188,"^J",195,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns this array if fully mutable, otherwise returns a new mutable array containing\n                   a copy of this array. May return nil if the implementation cannot create a suitable mutable\n                   array."],"^22",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",254,"^I",4,"^J",254,"^K",19,"^L","^24","^N","Create a diagonal matrix with the specified leading diagonal values","^O",["^P",["^Q",["^P",[["~$m","^23"]]]]]],"^L","^24","^:","~$clojure.core.matrix.protocols/diagonal-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m","^23"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",249,"^J",254,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^23"]]]]],"^N","Create a diagonal matrix with the specified leading diagonal values"],"~$set-inner-product!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",673,"^I",4,"^J",673,"^K",22,"^L","~$clojure.core.matrix.protocols/PSetInnerProductMutable","^N","Sets m to the inner product of a, b and an optional scalar factor to m","^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^V",["^P",[null,null]]]],"^L","^:H","^:","~$clojure.core.matrix.protocols/set-inner-product!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",669,"^J",673,"^W",4,"^X",true,"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^N","Sets m to the inner product of a, b and an optional scalar factor to m"],"~$PSoftmax",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",866,"^I",14,"^J",866,"^K",22,"^N","Protocol to support element-wise softmax function on a numerical vector.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$softmax",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSoftmax","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^I",1,"^H",866,"^10",["^ ","^11",["^ ","^:K",[["~$m"]]]],"^17",null,"^J",866,"^18","^19","^1:",["^8",[]],"^N","Protocol to support element-wise softmax function on a numerical vector.","^[",["^P",["@interface"]]],"~$sin!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",937,"^I",4,"^J",937,"^K",8,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/sin!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",937,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$normalise!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",796,"^I",4,"^J",796,"^K",14,"^L","~$clojure.core.matrix.protocols/PMutableVectorOps","^N",null,"^O",["^P",["^Q",["^P",[["~$a"]]]]]],"^L","^:P","^:","~$clojure.core.matrix.protocols/normalise!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",794,"^J",796,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$a"]]]]],"^N",null],"~$element-count",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",948,"^I",4,"^J",948,"^K",17,"^L","~$clojure.core.matrix.protocols/PElementCount","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^:S","^:","~$clojure.core.matrix.protocols/element-count","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",945,"^J",948,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PAddInnerProductMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",651,"^I",14,"^J",651,"^K",37,"^N","Protocol to support the mutable add-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^35",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]]],"^Z",true,"^:","^36","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",37,"^I",1,"^H",651,"^10",["^ ","^11",["^ ","^35",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]],"^17",null,"^J",651,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the mutable add-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.","^[",["^P",["@interface"]]],"~$PMatrixAdd",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",621,"^I",14,"^J",621,"^K",24,"^N","Protocol to support addition and subtraction on arbitrary matrices.\n   These are elementwise operations that should support broadcasting.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$matrix-add",[["~$m","~$a"]],"^6D",[["~$m","~$a"]]]]],"^Z",true,"^:","^6E","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",621,"^10",["^ ","^11",["^ ","^:W",[["~$m","~$a"]],"^6D",[["~$m","~$a"]]]],"^17",null,"^J",621,"^18","^19","^1:",["^8",[]],"^N","Protocol to support addition and subtraction on arbitrary matrices.\n   These are elementwise operations that should support broadcasting.","^[",["^P",["@interface"]]],"~$supports-dimensionality?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",72,"^I",4,"^J",72,"^K",28,"^L","^6Q","^N","Returns true if the implementation supports matrices with the given number of dimensions.","^O",["^P",["^Q",["^P",[["~$m","~$dimensions"]]]]]],"^L","^6Q","^:","~$clojure.core.matrix.protocols/supports-dimensionality?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^T",["^P",[["~$m","^:Y"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",40,"^J",72,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^:Y"]]]]],"^N","Returns true if the implementation supports matrices with the given number of dimensions."],"~$column-index",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1174,"^I",4,"^J",1174,"^K",16,"^L","~$clojure.core.matrix.protocols/PColumnIndex","^N","Returns the index of the specified column label","^O",["^P",["^Q",["^P",[["~$m","~$column-label"]]]]]],"^L","^;0","^:","~$clojure.core.matrix.protocols/column-index","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m","^;1"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1169,"^J",1174,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^;1"]]]]],"^N","Returns the index of the specified column label"],"^:K",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",868,"^I",4,"^J",868,"^K",11,"^L","^:L","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^:L","^:","~$clojure.core.matrix.protocols/softmax","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",866,"^J",868,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PSubVector",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",412,"^I",14,"^J",412,"^K",24,"^N","Protocol for getting a sub-vector view of a vector. Must return a mutable view\n   if the original vector is mutable. Should throw an exception if the specified\n   subvector is out of bounds for the target vector.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$subvector",[["~$m","~$start","^99"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSubVector","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",412,"^10",["^ ","^11",["^ ","^;5",[["~$m","^;6","^99"]]]],"^17",null,"^J",412,"^18","^19","^1:",["^8",[]],"^N","Protocol for getting a sub-vector view of a vector. Must return a mutable view\n   if the original vector is mutable. Should throw an exception if the specified\n   subvector is out of bounds for the target vector.","^[",["^P",["@interface"]]],"~$lu",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1193,"^I",4,"^J",1193,"^K",6,"^L","~$clojure.core.matrix.protocols/PLUDecomposition","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]]],"^L","^;9","^:","~$clojure.core.matrix.protocols/lu","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",6,"^T",["^P",[["~$m","^4Y"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1191,"^J",1193,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]],"^N",null],"~$set-selection",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1128,"^I",4,"^J",1128,"^K",17,"^L","~$clojure.core.matrix.protocols/PSetSelection","^N","sets the elements in the selection of a to values","^O",["^P",["^Q",["^P",[["~$a","^5<","^14"]]]]]],"^L","^;<","^:","~$clojure.core.matrix.protocols/set-selection","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$a","^5<","^14"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1125,"^J",1128,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","^5<","^14"]]]]],"^N","sets the elements in the selection of a to values"],"~$logistic",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",844,"^I",4,"^J",844,"^K",12,"^L","~$clojure.core.matrix.protocols/PLogistic","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^;?","^:","~$clojure.core.matrix.protocols/logistic","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",842,"^J",844,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^9Y",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",905,"^I",4,"^J",905,"^K",7,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/cos","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",7,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",905,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PScaleAdd",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",632,"^I",14,"^J",632,"^K",23,"^N","Protocol to support the mutable scale-add! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant values e.g. 0.0 and 1.0 but this is not mandatory.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$scale-add!",[["~$m1","~$a","~$m2","~$b","^3W"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PScaleAdd","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",632,"^10",["^ ","^11",["^ ","^;C",[["^;D","~$a","^;E","~$b","^3W"]]]],"^17",null,"^J",632,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the mutable scale-add! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant values e.g. 0.0 and 1.0 but this is not mandatory.","^[",["^P",["@interface"]]],"~$non-zero-indices",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1141,"^I",5,"^J",1141,"^K",21,"^L","~$clojure.core.matrix.protocols/PNonZeroIndices","^N","Gets the non-zero indices of an array.\n                         - For a 1D vector, returns an ordered index list.\n                         - For a higher dimensional array, returns the non-zero-indices for each slice in row-major order.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^;H","^:","~$clojure.core.matrix.protocols/non-zero-indices","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1139,"^J",1141,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Gets the non-zero indices of an array.\n                         - For a 1D vector, returns an ordered index list.\n                         - For a higher dimensional array, returns the non-zero-indices for each slice in row-major order."],"~$PIndexRank",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",819,"^I",14,"^J",819,"^K",24,"^N","Protocol to support ranking of elements in an array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$index-rank",[["~$m"],["~$m","~$comparator"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PIndexRank","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",819,"^10",["^ ","^11",["^ ","^;K",[["~$m"],["~$m","^;L"]]]],"^17",null,"^J",819,"^18","^19","^1:",["^8",[]],"^N","Protocol to support ranking of elements in an array.","^[",["^P",["@interface"]]],"~$cholesky",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1189,"^I",4,"^J",1189,"^K",12,"^L","~$clojure.core.matrix.protocols/PCholeskyDecomposition","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]]],"^L","^;O","^:","~$clojure.core.matrix.protocols/cholesky","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["~$m","^4Y"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1187,"^J",1189,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]],"^N",null],"^5R",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1209,"^I",4,"^J",1209,"^K",17,"^L","^5S","^N",null,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^5S","^:","~$clojure.core.matrix.protocols/least-squares","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1207,"^J",1209,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N",null],"^9Z",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",910,"^I",4,"^J",910,"^K",9,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/log10","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",910,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$qr",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1185,"^I",4,"^J",1185,"^K",6,"^L","~$clojure.core.matrix.protocols/PQRDecomposition","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]]],"^L","^;T","^:","~$clojure.core.matrix.protocols/qr","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",6,"^T",["^P",[["~$m","^4Y"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1183,"^J",1185,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]],"^N",null],"~$matrix-add!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",629,"^I",4,"^J",629,"^K",15,"^L","~$clojure.core.matrix.protocols/PMatrixAddMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^;W","^:","~$clojure.core.matrix.protocols/matrix-add!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",627,"^J",629,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"^9[",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",916,"^I",4,"^J",916,"^K",7,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/tan","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",7,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",916,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^:0",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",903,"^I",4,"^J",903,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/cbrt","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",903,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$as-double-array",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",475,"^I",4,"^J",475,"^K",19,"^L","~$clojure.core.matrix.protocols/PDoubleArrayOutput","^N","Returns the internal double array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^<0","^:","~$clojure.core.matrix.protocols/as-double-array","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",469,"^J",475,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the internal double array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array."],"~$PAddScaled",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",558,"^I",14,"^J",558,"^K",24,"^N","Protocol for add-scaled operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for result = m + a * factor","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$add-scaled",[["~$m","~$a","^27"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PAddScaled","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",558,"^10",["^ ","^11",["^ ","^<3",[["~$m","~$a","^27"]]]],"^17",null,"^J",558,"^18","^19","^1:",["^8",[]],"^N","Protocol for add-scaled operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for result = m + a * factor","^[",["^P",["@interface"]]],"~$PLUDecomposition",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1191,"^I",14,"^J",1191,"^K",30,"^N","Protocol for LU decomposition","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^;8",[["~$m","^4Y"]]]]],"^Z",true,"^:","^;9","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",1191,"^10",["^ ","^11",["^ ","^;8",[["~$m","^4Y"]]]],"^17",null,"^J",1191,"^18","^19","^1:",["^8",[]],"^N","Protocol for LU decomposition","^[",["^P",["@interface"]]],"~$PValidateShape",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",165,"^I",14,"^J",165,"^K",28,"^N","Optional protocol to validate the shape of a matrix. If the matrix has an incorrect shape, should\n   throw an error. Otherwise it should return the correct shape.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^2:",[["~$m"]]]]],"^Z",true,"^:","^2;","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",165,"^10",["^ ","^11",["^ ","^2:",[["~$m"]]]],"^17",null,"^J",165,"^18","^19","^1:",["^8",[]],"^N","Optional protocol to validate the shape of a matrix. If the matrix has an incorrect shape, should\n   throw an error. Otherwise it should return the correct shape.","^[",["^P",["@interface"]]],"~$softmax!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",872,"^I",4,"^J",872,"^K",12,"^L","~$clojure.core.matrix.protocols/PSoftmaxMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^<8","^:","~$clojure.core.matrix.protocols/softmax!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",870,"^J",872,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^49",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1148,"^I",4,"^J",1148,"^K",18,"^L","^4?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^4?","^:","~$clojure.core.matrix.protocols/index-to-longs","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1145,"^J",1148,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$generic-negate",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1107,"^I",4,"^J",1107,"^K",18,"^L","~$clojure.core.matrix.protocols/PGenericOperations","^N","Generic 'negate' function for numerical values.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^<<","^:","~$clojure.core.matrix.protocols/generic-negate","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1103,"^J",1107,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Generic 'negate' function for numerical values."],"^3>",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1060,"^I",4,"^J",1060,"^K",24,"^L","^3?","^N","Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error.","^O",["^P",["^Q",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]]],"^L","^3?","^:","~$clojure.core.matrix.protocols/element-map-indexed!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]],"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^U",null,"^V",["^P",[null,null,null]],"^I",1,"^H",1048,"^J",1060,"^W",4,"^X",true,"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^N","Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error."],"~$PAddOuterProductMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",660,"^I",14,"^J",660,"^K",37,"^N","Protocol to support the mutable add-outer-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$add-outer-product!",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PAddOuterProductMutable","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",37,"^I",1,"^H",660,"^10",["^ ","^11",["^ ","^<@",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]],"^17",null,"^J",660,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the mutable add-outer-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.","^[",["^P",["@interface"]]],"^8K",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",683,"^I",4,"^J",683,"^K",13,"^L","^8M","^N",null,"^O",["^P",["^Q",["^P",[["~$d","^8L"]]]]]],"^L","^8M","^:","~$clojure.core.matrix.protocols/submatrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$d","^8L"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",678,"^J",683,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$d","^8L"]]]]],"^N",null],"~$tan!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",940,"^I",4,"^J",940,"^K",8,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/tan!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",940,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$lerp!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",648,"^I",4,"^J",648,"^K",9,"^L","~$clojure.core.matrix.protocols/PLerp","^N","Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor. Mutates a.","^O",["^P",["^Q",["^P",[["~$a","~$b","^27"]]]]]],"^L","^<F","^:","~$clojure.core.matrix.protocols/lerp!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$a","~$b","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",644,"^J",648,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b","^27"]]]]],"^N","Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor. Mutates a."],"^9B",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1224,"^I",4,"^J",1224,"^K",13,"^L","^1B","^N","Returns a dataset created by combining the rows of the given datasets","^O",["^P",["^Q",["^P",[["^9C","^9D"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/join-rows","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["^9C","^9D"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1224,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["^9C","^9D"]]]]],"^N","Returns a dataset created by combining the rows of the given datasets"],"~$element-multiply!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",593,"^I",4,"^J",593,"^K",21,"^L","^5X","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^5X","^:","~$clojure.core.matrix.protocols/element-multiply!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",590,"^J",593,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$PTransposeDims",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",699,"^I",14,"^J",699,"^K",28,"^N","Protocol for generalised array transpose operation","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$transpose-dims",[["~$m","^52"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PTransposeDims","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",699,"^10",["^ ","^11",["^ ","^<L",[["~$m","^52"]]]],"^17",null,"^J",699,"^18","^19","^1:",["^8",[]],"^N","Protocol for generalised array transpose operation","^[",["^P",["@interface"]]],"^15",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1137,"^I",4,"^J",1137,"^K",16,"^L","^16","^N","destructively sets the elements from a at indices to values","^O",["^P",["^Q",["^P",[["~$a","^13","^14"]]]]]],"^L","^16","^:","~$clojure.core.matrix.protocols/set-indices!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$a","^13","^14"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1134,"^J",1137,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","^13","^14"]]]]],"^N","destructively sets the elements from a at indices to values"],"~$PSameShape",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",335,"^I",14,"^J",335,"^K",24,"^N","Protocol to test if two arrays have the same shape. Implementations may have an optimised\n   method for shape equality tests, and this is a frequently required operations so it may\n   make sense to provide an optimised implementation.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$same-shape?",[["~$a","~$b"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSameShape","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",335,"^10",["^ ","^11",["^ ","^<P",[["~$a","~$b"]]]],"^17",null,"^J",335,"^18","^19","^1:",["^8",[]],"^N","Protocol to test if two arrays have the same shape. Implementations may have an optimised\n   method for shape equality tests, and this is a frequently required operations so it may\n   make sense to provide an optimised implementation.","^[",["^P",["@interface"]]],"^9M",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",884,"^I",4,"^J",884,"^K",11,"^L","^8D","^N","Returns a new matrix with row i added to row j times k","^O",["^P",["^Q",["^P",[["~$m","~$i","~$j","~$k"]]]]]],"^L","^8D","^:","~$clojure.core.matrix.protocols/add-row","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","~$i","~$j","~$k"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",878,"^J",884,"^W",4,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i","~$j","~$k"]]]]],"^N","Returns a new matrix with row i added to row j times k"],"~$column-matrix",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",178,"^I",4,"^J",178,"^K",17,"^L","~$clojure.core.matrix.protocols/PRowColMatrix","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]]],"^L","^<T","^:","~$clojure.core.matrix.protocols/column-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","^1V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",172,"^J",178,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]],"^N",null],"~$PBlockDiagonalMatrix",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",262,"^I",14,"^J",262,"^K",34,"^N","Protocol for construction of a block diagonal matrix.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^8N",[["~$m","^8P"]]]]],"^Z",true,"^:","^8O","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",34,"^I",1,"^H",262,"^10",["^ ","^11",["^ ","^8N",[["~$m","^8P"]]]],"^17",null,"^J",262,"^18","^19","^1:",["^8",[]],"^N","Protocol for construction of a block diagonal matrix.","^[",["^P",["@interface"]]],"~$PMatrixRows",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",353,"^I",14,"^J",353,"^K",25,"^N","Protocol for accessing rows of a matrix","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^75",[["~$m"]]]]],"^Z",true,"^:","^76","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",353,"^10",["^ ","^11",["^ ","^75",[["~$m"]]]],"^17",null,"^J",353,"^18","^19","^1:",["^8",[]],"^N","Protocol for accessing rows of a matrix","^[",["^P",["@interface"]]],"~$value-equals",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",494,"^I",4,"^J",494,"^K",16,"^L","~$clojure.core.matrix.protocols/PValueEquality","^N","Returns true if two arrays are equal both in shape and according to clojure.core/= for each element.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^<Y","^:","~$clojure.core.matrix.protocols/value-equals","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",491,"^J",494,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Returns true if two arrays are equal both in shape and according to clojure.core/= for each element."],"~$exp!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",931,"^I",4,"^J",931,"^K",8,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/exp!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",931,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^<3",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",564,"^I",4,"^J",564,"^K",14,"^L","^<4","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a","^27"]]]]]],"^L","^<4","^:","~$clojure.core.matrix.protocols/add-scaled","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",558,"^J",564,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","^27"]]]]],"^N",null],"~$matrix-sub!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",630,"^I",4,"^J",630,"^K",15,"^L","^;W","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^;W","^:","~$clojure.core.matrix.protocols/matrix-sub!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",627,"^J",630,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$PCompare",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",959,"^I",14,"^J",959,"^K",22,"^N","Protocol to allow element-wise comparison of elements in an array or matrix.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$element-compare",[["~$a","~$b"]],"~$element-if",[["~$m","~$a","~$b"]],"~$element-lt",[["~$m","~$a"]],"^63",[["~$m","~$a"]],"~$element-gt",[["~$m","~$a"]],"^78",[["~$m","~$a"]],"~$element-ne",[["~$m","~$a"]],"~$element-eq",[["~$m","~$a"]]]]],"^Z",true,"^:","^64","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^I",1,"^H",959,"^10",["^ ","^11",["^ ","^=5",[["~$a","~$b"]],"^=6",[["~$m","~$a","~$b"]],"^=7",[["~$m","~$a"]],"^63",[["~$m","~$a"]],"^=8",[["~$m","~$a"]],"^78",[["~$m","~$a"]],"^=9",[["~$m","~$a"]],"^=:",[["~$m","~$a"]]]],"^17",null,"^J",959,"^18","^19","^1:",["^8",[]],"^N","Protocol to allow element-wise comparison of elements in an array or matrix.","^[",["^P",["@interface"]]],"~$PLogistic",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",842,"^I",14,"^J",842,"^K",23,"^N","Protocol to support element-wise logistic function on a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^;>",[["~$m"]]]]],"^Z",true,"^:","^;?","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",842,"^10",["^ ","^11",["^ ","^;>",[["~$m"]]]],"^17",null,"^J",842,"^18","^19","^1:",["^8",[]],"^N","Protocol to support element-wise logistic function on a numerical array.","^[",["^P",["@interface"]]],"^:1",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",915,"^I",4,"^J",915,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/sqrt","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",915,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$get-2d",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",99,"^I",4,"^J",99,"^K",10,"^L","~$clojure.core.matrix.protocols/PIndexedAccess","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^3R","^2G"]]]]]],"^L","^=>","^:","~$clojure.core.matrix.protocols/get-2d","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^3R","^2G"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",95,"^J",99,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3R","^2G"]]]]],"^N",null],"^26",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",618,"^I",4,"^J",618,"^K",10,"^L","^29","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^27"]]]]]],"^L","^29","^:","~$clojure.core.matrix.protocols/scale!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",616,"^J",618,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^27"]]]]],"^N",null],"^5I",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",314,"^I",4,"^J",314,"^K",29,"^L","^5J","^N","Converts an array to nested Clojure persistent vectors","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^5J","^:","~$clojure.core.matrix.protocols/convert-to-nested-vectors","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",310,"^J",314,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Converts an array to nested Clojure persistent vectors"],"^3V",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",610,"^I",4,"^J",610,"^K",9,"^L","^3Y","^N","Multiplies a array by the scalar constant, ","^O",["^P",["^Q",["^P",[["~$m","^3W"]]]]]],"^L","^3Y","^:","~$clojure.core.matrix.protocols/scale","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m","^3W"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",604,"^J",610,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3W"]]]]],"^N","Multiplies a array by the scalar constant, "],"^82",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",895,"^I",4,"^J",895,"^K",15,"^L","^83","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$i","^2G"]]]]]],"^L","^83","^:","~$clojure.core.matrix.protocols/set-column!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","~$i","^2G"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",892,"^J",895,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i","^2G"]]]]],"^N",null],"^3A",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",856,"^I",4,"^J",856,"^K",13,"^L","^3B","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3B","^:","~$clojure.core.matrix.protocols/softplus!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",854,"^J",856,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^;5",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",416,"^I",4,"^J",416,"^K",13,"^L","^;7","^N","Gets a sub-vector of a vector. Must return a view if the vector is mutable.","^O",["^P",["^Q",["^P",[["~$m","^;6","^99"]]]]]],"^L","^;7","^:","~$clojure.core.matrix.protocols/subvector","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m","^;6","^99"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",412,"^J",416,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^;6","^99"]]]]],"^N","Gets a sub-vector of a vector. Must return a view if the vector is mutable."],"~$inner-product",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",528,"^I",4,"^J",528,"^K",17,"^L","~$clojure.core.matrix.protocols/PMatrixProducts","^N","Returns the inner product of two numerical arrays.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^=G","^:","~$clojure.core.matrix.protocols/inner-product","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",525,"^J",528,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Returns the inner product of two numerical arrays."],"~$to-degrees!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",942,"^I",4,"^J",942,"^K",15,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/to-degrees!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",942,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$is-scalar?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",84,"^I",4,"^J",84,"^K",14,"^L","^6H","^N","Tests whether an object is a scalar value, i.e. a value that can exist at a\n     specific position in an array.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6H","^:","~$clojure.core.matrix.protocols/is-scalar?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",75,"^J",84,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Tests whether an object is a scalar value, i.e. a value that can exist at a\n     specific position in an array."],"~$cbrt!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",927,"^I",4,"^J",927,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/cbrt!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",927,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$inverse",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",807,"^I",4,"^J",807,"^K",11,"^L","~$clojure.core.matrix.protocols/PMatrixOps","^N","Returns the inverse of a matrix. Should return nil if m is not invertible.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^=P","^:","~$clojure.core.matrix.protocols/inverse","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",798,"^J",807,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the inverse of a matrix. Should return nil if m is not invertible."],"^5[",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",836,"^I",4,"^J",836,"^K",15,"^L","^61","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^60"]]]]]],"^L","^61","^:","~$clojure.core.matrix.protocols/element-pow","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","^60"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",831,"^J",836,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^60"]]]]],"^N",null],"~$transpose",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",692,"^I",4,"^J",692,"^K",13,"^L","~$clojure.core.matrix.protocols/PTranspose","^N","Returns the transpose of an array. Equivalent to reversing the \"shape\".\n     Note that:\n     - The transpose of a scalar is the same scalar\n     - The transpose of a 1D vector is the same 1D vector\n     - The transpose of a 2D matrix swaps rows and columns","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^=T","^:","~$clojure.core.matrix.protocols/transpose","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",690,"^J",692,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the transpose of an array. Equivalent to reversing the \"shape\".\n     Note that:\n     - The transpose of a scalar is the same scalar\n     - The transpose of a 1D vector is the same 1D vector\n     - The transpose of a 2D matrix swaps rows and columns"],"~$PMatrixOps",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",798,"^I",14,"^J",798,"^K",24,"^N","Protocol to support common 2D numerical matrix operations","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$trace",[["~$m"]],"~$determinant",[["~$m"]],"^=O",[["~$m"]]]]],"^Z",true,"^:","^=P","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",798,"^10",["^ ","^11",["^ ","^=W",[["~$m"]],"^=X",[["~$m"]],"^=O",[["~$m"]]]],"^17",null,"^J",798,"^18","^19","^1:",["^8",[]],"^N","Protocol to support common 2D numerical matrix operations","^[",["^P",["@interface"]]],"~$get-columns",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",359,"^I",4,"^J",359,"^K",15,"^L","~$clojure.core.matrix.protocols/PMatrixColumns","^N","Returns the columns of a matrix, as a seqable object","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^=Z","^:","~$clojure.core.matrix.protocols/get-columns","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",357,"^J",359,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the columns of a matrix, as a seqable object"],"~$PMatrixDivideMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",582,"^I",14,"^J",582,"^K",34,"^N","Protocol to support mutable element-wise division operater.\n\n   One-arg version computes the reciprocal of all elements.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$element-divide!",[["~$m"],["~$m","~$a"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PMatrixDivideMutable","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",34,"^I",1,"^H",582,"^10",["^ ","^11",["^ ","^>1",[["~$m"],["~$m","~$a"]]]],"^17",null,"^J",582,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable element-wise division operater.\n\n   One-arg version computes the reciprocal of all elements.","^[",["^P",["@interface"]]],"~$PRotateAll",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",710,"^I",14,"^J",710,"^K",24,"^N","Rotates an array using the specified shifts for each dimension.\n\n   shifts may be any sequence of integer shift amounts.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^2=",[["~$m","^2?"]]]]],"^Z",true,"^:","^2>","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",710,"^10",["^ ","^11",["^ ","^2=",[["~$m","^2?"]]]],"^17",null,"^J",710,"^18","^19","^1:",["^8",[]],"^N","Rotates an array using the specified shifts for each dimension.\n\n   shifts may be any sequence of integer shift amounts.","^[",["^P",["@interface"]]],"^7J",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1217,"^I",4,"^J",1217,"^K",11,"^L","^1B","^N","Returns a persistent vector containing columns in the same order they are placed in the dataset","^O",["^P",["^Q",["^P",[["^1C"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/columns","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["^1C"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1217,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["^1C"]]]]],"^N","Returns a persistent vector containing columns in the same order they are placed in the dataset"],"~$PAddScaledMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",566,"^I",14,"^J",566,"^K",31,"^N","Protocol for mutable add-scaled! operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for m = m + a * factor","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^7A",[["~$m","~$a","^27"]]]]],"^Z",true,"^:","^7B","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",566,"^10",["^ ","^11",["^ ","^7A",[["~$m","~$a","^27"]]]],"^17",null,"^J",566,"^18","^19","^1:",["^8",[]],"^N","Protocol for mutable add-scaled! operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for m = m + a * factor","^[",["^P",["@interface"]]],"~$broadcast",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",288,"^I",4,"^J",288,"^K",13,"^L","~$clojure.core.matrix.protocols/PBroadcast","^N","Broadcasts an array over a desired target shape, which should be larger than the current matrix.\n     Dimensions should be matched up according to the last dimension.\n     In order to broadcast sucessfully, the current dimension of the array must be either:\n      - of size 1\n      - equal to the size of the dimension in the target shape\n      - not included in the array (i.e. the target shape has more leading dimensions)\n\n     If broadcasting is not possible, an exception must be thrown.\n\n     Broadcasting may return either a view with replicated element or a new immutable matrix.","^O",["^P",["^Q",["^P",[["~$m","~$target-shape"]]]]]],"^L","^>7","^:","~$clojure.core.matrix.protocols/broadcast","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m","^>8"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",286,"^J",288,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^>8"]]]]],"^N","Broadcasts an array over a desired target shape, which should be larger than the current matrix.\n     Dimensions should be matched up according to the last dimension.\n     In order to broadcast sucessfully, the current dimension of the array must be either:\n      - of size 1\n      - equal to the size of the dimension in the target shape\n      - not included in the array (i.e. the target shape has more leading dimensions)\n\n     If broadcasting is not possible, an exception must be thrown.\n\n     Broadcasting may return either a view with replicated element or a new immutable matrix."],"~$PNonZeroIndices",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1139,"^I",14,"^J",1139,"^K",29,"^N","Protocol for getting non-zero indices of an array","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^;G",[["~$m"]]]]],"^Z",true,"^:","^;H","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",1139,"^10",["^ ","^11",["^ ","^;G",[["~$m"]]]],"^17",null,"^J",1139,"^18","^19","^1:",["^8",[]],"^N","Protocol for getting non-zero indices of an array","^[",["^P",["@interface"]]],"^=:",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",989,"^I",4,"^J",989,"^K",14,"^L","^64","^N","Return a binary array or matrix where elements of m equal to a are\n    represented by 1 and elements not-equal to a are represented as 0.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-eq","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",989,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Return a binary array or matrix where elements of m equal to a are\n    represented by 1 and elements not-equal to a are represented as 0."],"^8W",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1075,"^I",4,"^J",1075,"^K",16,"^L","^3D","^N","Returns true if all the elements of matrix m are zeros","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3D","^:","~$clojure.core.matrix.protocols/zero-matrix?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1070,"^J",1075,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if all the elements of matrix m are zeros"],"~$matrix-multiply",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",522,"^I",4,"^J",522,"^K",19,"^L","^5A","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^5A","^:","~$clojure.core.matrix.protocols/matrix-multiply","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",517,"^J",522,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$calc-common-shape",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1252,"^I",8,"^J",1252,"^K",25,"~:private",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Returns the larger of two shapes if they are compatible, nil otherwise"],"^>@",true,"^:","~$clojure.core.matrix.protocols/calc-common-shape","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1252,"^J",1252,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Returns the larger of two shapes if they are compatible, nil otherwise"],"^=W",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",800,"^I",4,"^J",800,"^K",9,"^L","^=P","^N","Returns the trace of a matrix (sum of elements on main diagonal.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^=P","^:","~$clojure.core.matrix.protocols/trace","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",798,"^J",800,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the trace of a matrix (sum of elements on main diagonal.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)"],"~$PGenericOperations",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1103,"^I",14,"^J",1103,"^K",32,"^N","Protocol for returning the generic numerical functions of a matrix implementation","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$generic-add",[["~$m"]],"~$generic-mul",[["~$m"]],"^<;",[["~$m"]],"~$generic-div",[["~$m"]]]]],"^Z",true,"^:","^<<","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",32,"^I",1,"^H",1103,"^10",["^ ","^11",["^ ","^>D",[["~$m"]],"^>E",[["~$m"]],"^<;",[["~$m"]],"^>F",[["~$m"]]]],"^17",null,"^J",1103,"^18","^19","^1:",["^8",[]],"^N","Protocol for returning the generic numerical functions of a matrix implementation","^[",["^P",["@interface"]]],"~$PCholeskyDecomposition",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1187,"^I",14,"^J",1187,"^K",36,"^N","Procotol for Cholesky decomposition","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^;N",[["~$m","^4Y"]]]]],"^Z",true,"^:","^;O","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",36,"^I",1,"^H",1187,"^10",["^ ","^11",["^ ","^;N",[["~$m","^4Y"]]]],"^17",null,"^J",1187,"^18","^19","^1:",["^8",[]],"^N","Procotol for Cholesky decomposition","^[",["^P",["@interface"]]],"^2R",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1181,"^I",4,"^J",1181,"^K",8,"^L","^2S","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]]],"^L","^2S","^:","~$clojure.core.matrix.protocols/norm","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m","~$p"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1179,"^J",1181,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]],"^N",null],"~$get-shape",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",80,"^I",4,"^J",80,"^K",13,"^L","^6H","^N","Returns the shape of the array, typically as a Java array or sequence of dimension sizes.\n     Implementations are free to choose what type is used to represent the shape, but it must\n     contain only integer values and be traversable as a sequence via clojure.core/seq","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6H","^:","~$clojure.core.matrix.protocols/get-shape","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",75,"^J",80,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the shape of the array, typically as a Java array or sequence of dimension sizes.\n     Implementations are free to choose what type is used to represent the shape, but it must\n     contain only integer values and be traversable as a sequence via clojure.core/seq"],"^9S",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1201,"^I",4,"^J",1201,"^K",9,"^L","^9T","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]]],"^L","^9T","^:","~$clojure.core.matrix.protocols/eigen","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m","^4Y"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1199,"^J",1201,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4Y"]]]]],"^N",null],"~$PSquare",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",838,"^I",14,"^J",838,"^K",21,"^N","Protocol to support element-wise squaring of a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$square",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSquare","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^I",1,"^H",838,"^10",["^ ","^11",["^ ","^>M",[["~$m"]]]],"^17",null,"^J",838,"^18","^19","^1:",["^8",[]],"^N","Protocol to support element-wise squaring of a numerical array.","^[",["^P",["@interface"]]],"^:?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",890,"^I",4,"^J",890,"^K",12,"^L","^6V","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$i","^3R"]]]]]],"^L","^6V","^:","~$clojure.core.matrix.protocols/set-row!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["~$m","~$i","^3R"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",887,"^J",890,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i","^3R"]]]]],"^N",null],"~$matrix-equals-epsilon",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",513,"^I",4,"^J",513,"^K",25,"^L","~$clojure.core.matrix.protocols/PMatrixEqualityEpsilon","^N","As matrix-equals, but provides a numerical tolerance for equality testing.","^O",["^P",["^Q",["^P",[["~$a","~$b","^42"]]]]]],"^L","^>Q","^:","~$clojure.core.matrix.protocols/matrix-equals-epsilon","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^T",["^P",[["~$a","~$b","^42"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",508,"^J",513,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b","^42"]]]]],"^N","As matrix-equals, but provides a numerical tolerance for equality testing."],"~$get-1d",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",98,"^I",4,"^J",98,"^K",10,"^L","^=>","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^3R"]]]]]],"^L","^=>","^:","~$clojure.core.matrix.protocols/get-1d","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^3R"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",95,"^J",98,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3R"]]]]],"^N",null],"~$PBroadcast",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",286,"^I",14,"^J",286,"^K",24,"^N","Protocol to support broadcasting over one or more dimensions.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^>6",[["~$m","^>8"]]]]],"^Z",true,"^:","^>7","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",286,"^10",["^ ","^11",["^ ","^>6",[["~$m","^>8"]]]],"^17",null,"^J",286,"^18","^19","^1:",["^8",[]],"^N","Protocol to support broadcasting over one or more dimensions.","^[",["^P",["@interface"]]],"~$PSliceMap",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1001,"^I",14,"^J",1001,"^K",23,"^N","Maps a function over every slice of one or more arrays.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$slice-map",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSliceMap","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",1001,"^10",["^ ","^11",["^ ","^>W",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]],"^17",null,"^J",1001,"^18","^19","^1:",["^8",[]],"^N","Maps a function over every slice of one or more arrays.","^[",["^P",["@interface"]]],"~$PNumerical",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",747,"^I",14,"^J",747,"^K",24,"^N","Protocol for identifying numerical arrays. Should return true if every element in the\n   array is guaranteed to be a valid numerical value.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^2J",[["~$m"]]]]],"^Z",true,"^:","^2K","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",747,"^10",["^ ","^11",["^ ","^2J",[["~$m"]]]],"^17",null,"^J",747,"^18","^19","^1:",["^8",[]],"^N","Protocol for identifying numerical arrays. Should return true if every element in the\n   array is guaranteed to be a valid numerical value.","^[",["^P",["@interface"]]],"~$PMatrixEqualityEpsilon",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",508,"^I",14,"^J",508,"^K",36,"^N","Protocol for numerical array equality operations with a specified tolerance. Arrays are defined as equal\n   if the array shapes are the same and and for all corresponding elements ai and bi we have: |ai-bi|<=eps\n\n   Should be equivalent to PMatrixEquality when eps is zero.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^>P",[["~$a","~$b","^42"]]]]],"^Z",true,"^:","^>Q","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",36,"^I",1,"^H",508,"^10",["^ ","^11",["^ ","^>P",[["~$a","~$b","^42"]]]],"^17",null,"^J",508,"^18","^19","^1:",["^8",[]],"^N","Protocol for numerical array equality operations with a specified tolerance. Arrays are defined as equal\n   if the array shapes are the same and and for all corresponding elements ai and bi we have: |ai-bi|<=eps\n\n   Should be equivalent to PMatrixEquality when eps is zero.","^[",["^P",["@interface"]]],"~$gemm!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",998,"^I",4,"^J",998,"^K",9,"^L","~$clojure.core.matrix.protocols/PBLASBase","^N",null,"^O",["^P",["^Q",["^P",[["~$c","~$trans-a?","~$trans-b?","~$alpha","~$a","~$b","~$beta"]]]]]],"^L","^?0","^:","~$clojure.core.matrix.protocols/gemm!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$c","^?1","^?2","^?3","~$a","~$b","^?4"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",993,"^J",998,"^W",7,"^X",true,"^O",["^P",["^Q",["^P",[["~$c","^?1","^?2","^?3","~$a","~$b","^?4"]]]]],"^N",null],"~$PImmutableAssignment",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",457,"^I",14,"^J",457,"^K",34,"^N","Protocol for assigning values element-wise to an array, broadcasting as needed.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$assign",[["~$m","~$source"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PImmutableAssignment","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",34,"^I",1,"^H",457,"^10",["^ ","^11",["^ ","^?7",[["~$m","^?8"]]]],"^17",null,"^J",457,"^18","^19","^1:",["^8",[]],"^N","Protocol for assigning values element-wise to an array, broadcasting as needed.","^[",["^P",["@interface"]]],"^:2",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",907,"^I",4,"^J",907,"^K",7,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/exp","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",7,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",907,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PBroadcastLike",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",300,"^I",14,"^J",300,"^K",28,"^N","Protocol to broadcast into a given matrix shape. May also perform coercion if needed by the implementation.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$broadcast-like",[["~$m","~$a"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PBroadcastLike","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",300,"^10",["^ ","^11",["^ ","^?<",[["~$m","~$a"]]]],"^17",null,"^J",300,"^18","^19","^1:",["^8",[]],"^N","Protocol to broadcast into a given matrix shape. May also perform coercion if needed by the implementation.","^[",["^P",["@interface"]]],"~$PAddProductMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",538,"^I",14,"^J",538,"^K",32,"^N","Optional protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$add-product!",[["~$m","~$a","~$b"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PAddProductMutable","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",32,"^I",1,"^H",538,"^10",["^ ","^11",["^ ","^??",[["~$m","~$a","~$b"]]]],"^17",null,"^J",538,"^18","^19","^1:",["^8",[]],"^N","Optional protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b","^[",["^P",["@interface"]]],"~$PIndexedAccess",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",95,"^I",14,"^J",95,"^K",28,"^N","Protocol for indexed read access to arrays, matrices and vectors. Indexing values can\n   be assumed to be integers. indexes may be any sequence or Java array of index values.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^>S",[["~$m","^3R"]],"^==",[["~$m","^3R","^2G"]],"~$get-nd",[["~$m","~$indexes"]]]]],"^Z",true,"^:","^=>","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",95,"^10",["^ ","^11",["^ ","^>S",[["~$m","^3R"]],"^==",[["~$m","^3R","^2G"]],"^?B",[["~$m","^?C"]]]],"^17",null,"^J",95,"^18","^19","^1:",["^8",[]],"^N","Protocol for indexed read access to arrays, matrices and vectors. Indexing values can\n   be assumed to be integers. indexes may be any sequence or Java array of index values.","^[",["^P",["@interface"]]],"~$PMatrixMultiply",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",517,"^I",14,"^J",517,"^K",29,"^N","Protocol to support matrix multiplication on numerical arrays.\n\n   Implementation may return nil if the implementation does not support one of the parameters, in\n   which case a more general operation will be attempted.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^>=",[["~$m","~$a"]],"^5@",[["~$m","~$a"]]]]],"^Z",true,"^:","^5A","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",517,"^10",["^ ","^11",["^ ","^>=",[["~$m","~$a"]],"^5@",[["~$m","~$a"]]]],"^17",null,"^J",517,"^18","^19","^1:",["^8",[]],"^N","Protocol to support matrix multiplication on numerical arrays.\n\n   Implementation may return nil if the implementation does not support one of the parameters, in\n   which case a more general operation will be attempted.","^[",["^P",["@interface"]]],"~$PMatrixMultiplyMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",590,"^I",14,"^J",590,"^K",36,"^N","Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^5W",[["~$m","~$a"]],"^<I",[["~$m","~$a"]]]]],"^Z",true,"^:","^5X","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",36,"^I",1,"^H",590,"^10",["^ ","^11",["^ ","^5W",[["~$m","~$a"]],"^<I",[["~$m","~$a"]]]],"^17",null,"^J",590,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar","^[",["^P",["@interface"]]],"~$rank",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",816,"^I",4,"^J",816,"^K",8,"^L","~$clojure.core.matrix.protocols/PMatrixRank","^N","Returns the rank of a matrix","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^?G","^:","~$clojure.core.matrix.protocols/rank","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",814,"^J",816,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the rank of a matrix"],"^:W",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",624,"^I",4,"^J",624,"^K",14,"^L","^6E","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^6E","^:","~$clojure.core.matrix.protocols/matrix-add","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",621,"^J",624,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$fill!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",465,"^I",4,"^J",465,"^K",9,"^L","~$clojure.core.matrix.protocols/PMutableFill","^N","Fills the array with the given scalar value.","^O",["^P",["^Q",["^P",[["~$m","^3N"]]]]]],"^L","^?K","^:","~$clojure.core.matrix.protocols/fill!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m","^3N"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",464,"^J",465,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3N"]]]]],"^N","Fills the array with the given scalar value."],"~$get-slice-seq",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",394,"^I",4,"^J",394,"^K",17,"^L","~$clojure.core.matrix.protocols/PSliceSeq2","^N","Gets a sequence of all array slices","^O",["^P",["^Q",["^P",[["~$m","^72"]]]]]],"^L","^?N","^:","~$clojure.core.matrix.protocols/get-slice-seq","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","^72"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",389,"^J",394,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^72"]]]]],"^N","Gets a sequence of all array slices"],"~$length-squared",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",766,"^I",4,"^J",766,"^K",18,"^L","~$clojure.core.matrix.protocols/PVectorOps","^N","Squared Euclidean length of a vector.","^O",["^P",["^Q",["^P",[["~$a"]]]]]],"^L","^?Q","^:","~$clojure.core.matrix.protocols/length-squared","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",753,"^J",766,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$a"]]]]],"^N","Squared Euclidean length of a vector."],"^3<",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1052,"^I",4,"^J",1052,"^K",23,"^L","^3?","^N","Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error.","^O",["^P",["^Q",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]]],"^L","^3?","^:","~$clojure.core.matrix.protocols/element-map-indexed","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]],"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^U",null,"^V",["^P",[null,null,null]],"^I",1,"^H",1048,"^J",1052,"^W",4,"^X",true,"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^N","Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error."],"~$add-scaled-product!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",556,"^I",4,"^J",556,"^K",23,"^L","~$clojure.core.matrix.protocols/PAddScaledProductMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b","^27"]]]]]],"^L","^?U","^:","~$clojure.core.matrix.protocols/add-scaled-product!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^T",["^P",[["~$m","~$a","~$b","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",552,"^J",556,"^W",4,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b","^27"]]]]],"^N",null],"~$PVectorView",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",781,"^I",14,"^J",781,"^K",25,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^5T",[["~$m"]]]]],"^Z",true,"^:","^5U","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",781,"^10",["^ ","^11",["^ ","^5T",[["~$m"]]]],"^17",null,"^J",781,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"~$mutable-matrix",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",186,"^I",4,"^J",186,"^K",18,"^L","~$clojure.core.matrix.protocols/PMutableMatrixConstruction","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^?Y","^:","~$clojure.core.matrix.protocols/mutable-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",181,"^J",186,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^??",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",542,"^I",4,"^J",542,"^K",16,"^L","^?@","^N","Adds the elementwise product of a and b to m","^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]]],"^L","^?@","^:","~$clojure.core.matrix.protocols/add-product!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m","~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",538,"^J",542,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]],"^N","Adds the elementwise product of a and b to m"],"^>W",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1003,"^I",4,"^J",1003,"^K",13,"^L","^>X","^N","Maps f over all slices of m (and optionally other arrays)","^O",["^P",["^Q",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]]],"^L","^>X","^:","~$clojure.core.matrix.protocols/slice-map","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]],"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^U",null,"^V",["^P",[null,null,null]],"^I",1,"^H",1001,"^J",1003,"^W",4,"^X",true,"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^N","Maps f over all slices of m (and optionally other arrays)"],"~$lower-triangular?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1085,"^I",4,"^J",1085,"^K",21,"^L","^33","^N","Returns true if the matrix m is lower triangualar","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^33","^:","~$clojure.core.matrix.protocols/lower-triangular?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1082,"^J",1085,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the matrix m is lower triangualar"],"^<@",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",664,"^I",4,"^J",664,"^K",22,"^L","^<A","^N","Adds the outer product of a, b and an optional scalar factor to m","^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^V",["^P",[null,null]]]],"^L","^<A","^:","~$clojure.core.matrix.protocols/add-outer-product!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",660,"^J",664,"^W",4,"^X",true,"^O",["^P",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]],"^N","Adds the outer product of a, b and an optional scalar factor to m"],"~$broadcast-same-shape",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1292,"^I",7,"^J",1292,"^K",27,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Broadcasts two matrices into identical shapes. Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."],"^:","~$clojure.core.matrix.protocols/broadcast-same-shape","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1292,"^J",1292,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Broadcasts two matrices into identical shapes. Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."],"^=X",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",803,"^I",4,"^J",803,"^K",15,"^L","^=P","^N","Returns the determinant of a matrix. May return nil if the implementation is unable\n     to compute determinants, in which case a default implementation will be tried.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^=P","^:","~$clojure.core.matrix.protocols/determinant","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",798,"^J",803,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the determinant of a matrix. May return nil if the implementation is unable\n     to compute determinants, in which case a default implementation will be tried.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)"],"~$PRowColMatrix",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",172,"^I",14,"^J",172,"^K",27,"^N","Protocol to support construction of row and column matrices from 1D vectors.\n\n   A vector of length N should be converted to a 1xN or Nx1 matrix respectively.\n\n   Should throw an error if the data is not a 1D vector","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^<S",[["~$m","^1V"]],"~$row-matrix",[["~$m","^1V"]]]]],"^Z",true,"^:","^<T","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",172,"^10",["^ ","^11",["^ ","^<S",[["~$m","^1V"]],"^@8",[["~$m","^1V"]]]],"^17",null,"^J",172,"^18","^19","^1:",["^8",[]],"^N","Protocol to support construction of row and column matrices from 1D vectors.\n\n   A vector of length N should be converted to a 1xN or Nx1 matrix respectively.\n\n   Should throw an error if the data is not a 1D vector","^[",["^P",["@interface"]]],"~$PMatrixTypes",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1082,"^I",14,"^J",1082,"^K",26,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^32",[["~$m"]],"~$upper-triangular?",[["~$m"]],"^@1",[["~$m"]],"~$positive-definite?",[["~$m"]],"^39",[["~$m"]],"^41",[["~$m","^42"]]]]],"^Z",true,"^:","^33","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",1082,"^10",["^ ","^11",["^ ","^32",[["~$m"]],"^@:",[["~$m"]],"^@1",[["~$m"]],"^@;",[["~$m"]],"^39",[["~$m"]],"^41",[["~$m","^42"]]]],"^17",null,"^J",1082,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"^:3",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",906,"^I",4,"^J",906,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/cosh","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",906,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^;C",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",636,"^I",4,"^J",636,"^K",14,"^L","^;F","^N","Scales array m1 in place by factor b, then adds array m2 scaled by factor b, then adds the constant","^O",["^P",["^Q",["^P",[["^;D","~$a","^;E","~$b","^3W"]]]]]],"^L","^;F","^:","~$clojure.core.matrix.protocols/scale-add!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["^;D","~$a","^;E","~$b","^3W"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",632,"^J",636,"^W",5,"^X",true,"^O",["^P",["^Q",["^P",[["^;D","~$a","^;E","~$b","^3W"]]]]],"^N","Scales array m1 in place by factor b, then adds array m2 scaled by factor b, then adds the constant"],"~$PDimensionInfo",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",75,"^I",14,"^J",75,"^K",28,"^N","Protocol to return standard dimension information about an array.\n   dimensionality and dimension-count are mandatory for implementations","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$dimensionality",[["~$m"]],"^>I",[["~$m"]],"^=K",[["~$m"]],"~$is-vector?",[["~$m"]],"^6G",[["~$m","^6I"]]]]],"^Z",true,"^:","^6H","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",75,"^10",["^ ","^11",["^ ","^@?",[["~$m"]],"^>I",[["~$m"]],"^=K",[["~$m"]],"^@@",[["~$m"]],"^6G",[["~$m","^6I"]]]],"^17",null,"^J",75,"^18","^19","^1:",["^8",[]],"^N","Protocol to return standard dimension information about an array.\n   dimensionality and dimension-count are mandatory for implementations","^[",["^P",["@interface"]]],"~$set-1d",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",106,"^I",4,"^J",106,"^K",10,"^L","^1M","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^3R","~$v"]]]]]],"^L","^1M","^:","~$clojure.core.matrix.protocols/set-1d","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^3R","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",102,"^J",106,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3R","~$v"]]]]],"^N",null],"~$PMutableVectorOps",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",794,"^I",14,"^J",794,"^K",31,"^N","Protocol for mutable versions of common vector operations","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^:O",[["~$a"]]]]],"^Z",true,"^:","^:P","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",794,"^10",["^ ","^11",["^ ","^:O",[["~$a"]]]],"^17",null,"^J",794,"^18","^19","^1:",["^8",[]],"^N","Protocol for mutable versions of common vector operations","^[",["^P",["@interface"]]],"^@:",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1084,"^I",4,"^J",1084,"^K",21,"^L","^33","^N","Returns true if the matrix m is upper triangualar","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^33","^:","~$clojure.core.matrix.protocols/upper-triangular?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1082,"^J",1084,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the matrix m is upper triangualar"],"~$native?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",212,"^I",4,"^J",212,"^K",11,"^L","~$clojure.core.matrix.protocols/PNative","^N","Returns true if an array is in a native format, false otherwise.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^@F","^:","~$clojure.core.matrix.protocols/native?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",208,"^J",212,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if an array is in a native format, false otherwise."],"~$join-along",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",410,"^I",4,"^J",410,"^K",14,"^L","~$clojure.core.matrix.protocols/PSliceJoinAlong","^N","Concatenates a to m, along the slice dimension dim","^O",["^P",["^Q",["^P",[["~$m","~$a","^72"]]]]]],"^L","^@I","^:","~$clojure.core.matrix.protocols/join-along","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a","^72"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",408,"^J",410,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","^72"]]]]],"^N","Concatenates a to m, along the slice dimension dim"],"~$filter-slices",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1011,"^I",4,"^J",1011,"^K",17,"^L","~$clojure.core.matrix.protocols/PFilterSlices","^N","Runs f on all slices of m. Must return those slices which satisfy (f slice).\n     Must return nil if no slices meet the predicate.\n     Must return either a new seqable array containing the filtered slices or a vector of slices\n     (both of which are valid core.matrix arrays)","^O",["^P",["^Q",["^P",[["~$m","~$f"]]]]]],"^L","^@L","^:","~$clojure.core.matrix.protocols/filter-slices","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","~$f"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1009,"^J",1011,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$f"]]]]],"^N","Runs f on all slices of m. Must return those slices which satisfy (f slice).\n     Must return nil if no slices meet the predicate.\n     Must return either a new seqable array containing the filtered slices or a vector of slices\n     (both of which are valid core.matrix arrays)"],"~$assign-array!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",452,"^I",4,"^J",452,"^K",17,"^L","~$clojure.core.matrix.protocols/PAssignment","^N","Sets the elements in an array from a Java array source, in row-major order.","^O",["^P",["^Q",["^P",[["~$m","~$arr"],["~$m","^@P","^;6","^99"]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]],"^O",["^P",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]],"^V",["^P",[null,null]]]],"^L","^@O","^:","~$clojure.core.matrix.protocols/assign-array!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]],"^O",["^P",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",446,"^J",452,"^W",4,"^X",true,"^O",["^P",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]],"^N","Sets the elements in an array from a Java array source, in row-major order."],"~$PValueEquality",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",491,"^I",14,"^J",491,"^K",28,"^N","Protocol for comparing two arrays, with the semantics of clojure.core/=.\n   Must return false if the arrays are not of equal shape, or if any elements are not equal.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^<X",[["~$m","~$a"]]]]],"^Z",true,"^:","^<Y","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",491,"^10",["^ ","^11",["^ ","^<X",[["~$m","~$a"]]]],"^17",null,"^J",491,"^18","^19","^1:",["^8",[]],"^N","Protocol for comparing two arrays, with the semantics of clojure.core/=.\n   Must return false if the arrays are not of equal shape, or if any elements are not equal.","^[",["^P",["@interface"]]],"~$PSolveLinear",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1203,"^I",14,"^J",1203,"^K",26,"^N","Protocol for solving linear matrix equation or system of linear scalar equations","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$solve",[["~$a","~$b"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSolveLinear","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",1203,"^10",["^ ","^11",["^ ","^@T",[["~$a","~$b"]]]],"^17",null,"^J",1203,"^18","^19","^1:",["^8",[]],"^N","Protocol for solving linear matrix equation or system of linear scalar equations","^[",["^P",["@interface"]]],"^?<",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",302,"^I",4,"^J",302,"^K",18,"^L","^?=","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^?=","^:","~$clojure.core.matrix.protocols/broadcast-like","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",300,"^J",302,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N",null],"~$get-major-slice",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",348,"^I",4,"^J",348,"^K",19,"^L","^2B","^N","Gets the major slice of an array with the given index. For a 2D matrix, equivalent to get-row","^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]]],"^L","^2B","^:","~$clojure.core.matrix.protocols/get-major-slice","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m","~$i"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",341,"^J",348,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]],"^N","Gets the major slice of an array with the given index. For a 2D matrix, equivalent to get-row"],"~$row-maps",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1229,"^I",4,"^J",1229,"^K",12,"^L","^3[","^N","Returns seq of maps with row values","^O",["^P",["^Q",["^P",[["^1C"]]]]]],"^L","^3[","^:","~$clojure.core.matrix.protocols/row-maps","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",12,"^T",["^P",[["^1C"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1227,"^J",1229,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["^1C"]]]]],"^N","Returns seq of maps with row values"],"~$PAssignment",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",446,"^I",14,"^J",446,"^K",25,"^N","Protocol for assigning values element-wise to mutable arrays.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$assign!",[["~$m","^?8"]],"^@N",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]]]],"^Z",true,"^:","^@O","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",446,"^10",["^ ","^11",["^ ","^A0",[["~$m","^?8"]],"^@N",[["~$m","^@P"],["~$m","^@P","^;6","^99"]]]],"^17",null,"^J",446,"^18","^19","^1:",["^8",[]],"^N","Protocol for assigning values element-wise to mutable arrays.","^[",["^P",["@interface"]]],"~$PSliceJoinAlong",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",408,"^I",14,"^J",408,"^K",29,"^N","Protocol for concatenating / joining arrays.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^@H",[["~$m","~$a","^72"]]]]],"^Z",true,"^:","^@I","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",408,"^10",["^ ","^11",["^ ","^@H",[["~$m","~$a","^72"]]]],"^17",null,"^J",408,"^18","^19","^1:",["^8",[]],"^N","Protocol for concatenating / joining arrays.","^[",["^P",["@interface"]]],"^=6",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",964,"^I",4,"^J",964,"^K",14,"^L","^64","^N","Element-wise if statement.\n\n    Traverse each element, x, of a array or matrix, m. If:\n      - x > 0, return a (if scalar) or corresponding element of a (if a is an\n        array or matrix with same shape shape as m).\n      - x <= 0, return b (if scalar) or corresponding element in b (if b is an\n        array or matrix with same shape shape as m).\n\n    Return an array or matrix with the same shape as m.","^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-if","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",964,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]],"^N","Element-wise if statement.\n\n    Traverse each element, x, of a array or matrix, m. If:\n      - x > 0, return a (if scalar) or corresponding element of a (if a is an\n        array or matrix with same shape shape as m).\n      - x <= 0, return b (if scalar) or corresponding element in b (if b is an\n        array or matrix with same shape shape as m).\n\n    Return an array or matrix with the same shape as m."],"~$get-indices",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1132,"^I",4,"^J",1132,"^K",15,"^L","~$clojure.core.matrix.protocols/PIndicesAccess","^N","returns a 1-d array with the elements of a at indices","^O",["^P",["^Q",["^P",[["~$a","^13"]]]]]],"^L","^A4","^:","~$clojure.core.matrix.protocols/get-indices","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$a","^13"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1130,"^J",1132,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","^13"]]]]],"^N","returns a 1-d array with the elements of a at indices"],"~$PMatrixAddMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",627,"^I",14,"^J",627,"^K",31,"^N","Protocol to support mutable addition and subtraction","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^;V",[["~$m","~$a"]],"^=2",[["~$m","~$a"]]]]],"^Z",true,"^:","^;W","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",627,"^10",["^ ","^11",["^ ","^;V",[["~$m","~$a"]],"^=2",[["~$m","~$a"]]]],"^17",null,"^J",627,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable addition and subtraction","^[",["^P",["@interface"]]],"~$get-major-slice-seq",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",386,"^I",4,"^J",386,"^K",23,"^L","~$clojure.core.matrix.protocols/PSliceSeq","^N","Gets a sequence of all major array slices","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^A8","^:","~$clojure.core.matrix.protocols/get-major-slice-seq","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",379,"^J",386,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Gets a sequence of all major array slices"],"^6L",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1099,"^I",4,"^J",1099,"^K",16,"^L","^6O","^N","Generic 'zero' value for numerical arrays. Must satisfy (equals m (add m zero)).","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6O","^:","~$clojure.core.matrix.protocols/generic-zero","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1097,"^J",1099,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Generic 'zero' value for numerical arrays. Must satisfy (equals m (add m zero))."],"~$PDimensionLabels",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1157,"^I",14,"^J",1157,"^K",30,"^N","Protocol for arrays supporting labelled dimensions","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$label",[["~$m","^72","~$i"]],"^8=",[["~$m","^72"]]]]],"^Z",true,"^:","^8>","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",1157,"^10",["^ ","^11",["^ ","^A<",[["~$m","^72","~$i"]],"^8=",[["~$m","^72"]]]],"^17",null,"^J",1157,"^18","^19","^1:",["^8",[]],"^N","Protocol for arrays supporting labelled dimensions","^[",["^P",["@interface"]]],"^@T",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1205,"^I",4,"^J",1205,"^K",9,"^L","^@U","^N",null,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^@U","^:","~$clojure.core.matrix.protocols/solve","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1203,"^J",1205,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N",null],"~$PObjectArrayOutput",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",480,"^I",14,"^J",480,"^K",32,"^N","Protocol for getting element data as a flattened object array","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$to-object-array",[["~$m"]],"~$as-object-array",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PObjectArrayOutput","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",32,"^I",1,"^H",480,"^10",["^ ","^11",["^ ","^A?",[["~$m"]],"^A@",[["~$m"]]]],"^17",null,"^J",480,"^18","^19","^1:",["^8",[]],"^N","Protocol for getting element data as a flattened object array","^[",["^P",["@interface"]]],"~$outer-product",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",529,"^I",4,"^J",529,"^K",17,"^L","^=G","^N","Returns the outer product of two numerical arrays. Implementation\n                        may return nil to indicate that a default computation should be used.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^=G","^:","~$clojure.core.matrix.protocols/outer-product","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",525,"^J",529,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Returns the outer product of two numerical arrays. Implementation\n                        may return nil to indicate that a default computation should be used."],"~$element-divide",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",578,"^I",4,"^J",578,"^K",18,"^L","~$clojure.core.matrix.protocols/PMatrixDivide","^N",null,"^O",["^P",["^Q",["^P",[["~$m"],["~$m","~$a"]]]]],"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","~$a"]]],"^O",["^P",[["~$m"],["~$m","~$a"]]],"^V",["^P",[null,null]]]],"^L","^AE","^:","~$clojure.core.matrix.protocols/element-divide","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","~$a"]]],"^O",["^P",[["~$m"],["~$m","~$a"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m"],["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",574,"^J",578,"^W",2,"^X",true,"^O",["^P",[["~$m"],["~$m","~$a"]]],"^N",null],"^7E",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",161,"^I",4,"^J",161,"^K",17,"^L","^7F","^N","Returns the number of non-zero elements in a numerical array. \n     May throw an exception if the array is not numerical.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^7F","^:","~$clojure.core.matrix.protocols/nonzero-count","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",159,"^J",161,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the number of non-zero elements in a numerical array. \n     May throw an exception if the array is not numerical."],"^2N",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",772,"^I",4,"^J",772,"^K",17,"^L","^2P","^N","Cross product of two vectors","^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^2P","^:","~$clojure.core.matrix.protocols/cross-product","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",771,"^J",772,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Cross product of two vectors"],"~$PBroadcastCoerce",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",304,"^I",14,"^J",304,"^K",30,"^N","Protocol to broadcast into a given matrix shape and perform coercion in one step.\n\n   Equivalent to (coerce m (broadcast-like m a)) but likely to be more efficient.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$broadcast-coerce",[["~$m","~$a"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PBroadcastCoerce","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",304,"^10",["^ ","^11",["^ ","^AJ",[["~$m","~$a"]]]],"^17",null,"^J",304,"^18","^19","^1:",["^8",[]],"^N","Protocol to broadcast into a given matrix shape and perform coercion in one step.\n\n   Equivalent to (coerce m (broadcast-like m a)) but likely to be more efficient.","^[",["^P",["@interface"]]],"~$same-shapes?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1304,"^I",7,"^J",1304,"^K",19,"^O",["^P",["^Q",["^P",[["~$arrays"]]]]],"^N","Returns truthy if a sequence of arrays all have the same shape."],"^:","~$clojure.core.matrix.protocols/same-shapes?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["^AM"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1304,"^J",1304,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["^AM"]]]]],"^N","Returns truthy if a sequence of arrays all have the same shape."],"^6M",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1100,"^I",4,"^J",1100,"^K",15,"^L","^6O","^N","Generic 'one' value for numerical arrays. Must satisfy (equals m (mul m one)).","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6O","^:","~$clojure.core.matrix.protocols/generic-one","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1097,"^J",1100,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Generic 'one' value for numerical arrays. Must satisfy (equals m (mul m one))."],"~$PIndexedSettingMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",118,"^I",14,"^J",118,"^K",36,"^N","Protocol for indexed mutable setter access to matrices and vectors.\n   Must be supported for any mutable matrix type.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^3P",[["~$m","^3R","~$v"]],"^4F",[["~$m","^3R","^2G","~$v"]],"~$set-nd!",[["~$m","^?C","~$v"]]]]],"^Z",true,"^:","^3Q","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",36,"^I",1,"^H",118,"^10",["^ ","^11",["^ ","^3P",[["~$m","^3R","~$v"]],"^4F",[["~$m","^3R","^2G","~$v"]],"^AQ",[["~$m","^?C","~$v"]]]],"^17",null,"^J",118,"^18","^19","^1:",["^8",[]],"^N","Protocol for indexed mutable setter access to matrices and vectors.\n   Must be supported for any mutable matrix type.","^[",["^P",["@interface"]]],"~$gemv!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",999,"^I",4,"^J",999,"^K",9,"^L","^?0","^N",null,"^O",["^P",["^Q",["^P",[["~$c","^?1","^?3","~$a","~$b","^?4"]]]]]],"^L","^?0","^:","~$clojure.core.matrix.protocols/gemv!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$c","^?1","^?3","~$a","~$b","^?4"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",993,"^J",999,"^W",6,"^X",true,"^O",["^P",["^Q",["^P",[["~$c","^?1","^?3","~$a","~$b","^?4"]]]]],"^N",null],"^5O",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",247,"^I",4,"^J",247,"^K",10,"^L","^5P","^N","Sets the scalar value in a 0-d array, returning a new 0-d array","^O",["^P",["^Q",["^P",[["~$m","^3N"]]]]]],"^L","^5P","^:","~$clojure.core.matrix.protocols/set-0d","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^3N"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",245,"^J",247,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3N"]]]]],"^N","Sets the scalar value in a 0-d array, returning a new 0-d array"],"~$PMutableMatrixConstruction",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",181,"^I",14,"^J",181,"^K",40,"^N","Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable\n   copy of the given matrix, or nil if not possible.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^?X",[["~$m"]]]]],"^Z",true,"^:","^?Y","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",40,"^I",1,"^H",181,"^10",["^ ","^11",["^ ","^?X",[["~$m"]]]],"^17",null,"^J",181,"^18","^19","^1:",["^8",[]],"^N","Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable\n   copy of the given matrix, or nil if not possible.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.","^[",["^P",["@interface"]]],"~$PDatasetMaps",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1227,"^I",14,"^J",1227,"^K",26,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^3Z",[["^1C"]],"^@Y",[["^1C"]]]]],"^Z",true,"^:","^3[","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",1227,"^10",["^ ","^11",["^ ","^3Z",[["^1C"]],"^@Y",[["^1C"]]]],"^17",null,"^J",1227,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"~$PIndexedSetting",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",102,"^I",14,"^J",102,"^K",29,"^N","Protocol for indexed 'setter' operations. These are like Clojure's 'assoc'\n   function, i.e. they return an updated copy of the original array, which is itself unchanged.\n   Should be supported for any immutable array type.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^@A",[["~$m","^3R","~$v"]],"~$set-2d",[["~$m","^3R","^2G","~$v"]],"~$set-nd",[["~$m","^?C","~$v"]],"^1L",[["~$m"]]]]],"^Z",true,"^:","^1M","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",102,"^10",["^ ","^11",["^ ","^@A",[["~$m","^3R","~$v"]],"^AX",[["~$m","^3R","^2G","~$v"]],"^AY",[["~$m","^?C","~$v"]],"^1L",[["~$m"]]]],"^17",null,"^J",102,"^18","^19","^1:",["^8",[]],"^N","Protocol for indexed 'setter' operations. These are like Clojure's 'assoc'\n   function, i.e. they return an updated copy of the original array, which is itself unchanged.\n   Should be supported for any immutable array type.","^[",["^P",["@interface"]]],"~$PDoubleArrayOutput",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",469,"^I",14,"^J",469,"^K",32,"^N","Protocol for getting element data as a flattened double array","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$to-double-array",[["~$m"]],"^;[",[["~$m"]]]]],"^Z",true,"^:","^<0","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",32,"^I",1,"^H",469,"^10",["^ ","^11",["^ ","^A[",[["~$m"]],"^;[",[["~$m"]]]],"^17",null,"^J",469,"^18","^19","^1:",["^8",[]],"^N","Protocol for getting element data as a flattened double array","^[",["^P",["@interface"]]],"~$PMatrixProducts",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",525,"^I",14,"^J",525,"^K",29,"^N","Protocol for general inner and outer products of numerical arrays.\n   Products should use + and * as normally defined for numerical types.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^=F",[["~$m","~$a"]],"^AB",[["~$m","~$a"]]]]],"^Z",true,"^:","^=G","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",525,"^10",["^ ","^11",["^ ","^=F",[["~$m","~$a"]],"^AB",[["~$m","~$a"]]]],"^17",null,"^J",525,"^18","^19","^1:",["^8",[]],"^N","Protocol for general inner and outer products of numerical arrays.\n   Products should use + and * as normally defined for numerical types.","^[",["^P",["@interface"]]],"~$PSliceSeq2",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",389,"^I",14,"^J",389,"^K",24,"^N","Returns slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^?M",[["~$m","^72"]]]]],"^Z",true,"^:","^?N","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",389,"^10",["^ ","^11",["^ ","^?M",[["~$m","^72"]]]],"^17",null,"^J",389,"^18","^19","^1:",["^8",[]],"^N","Returns slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.","^[",["^P",["@interface"]]],"~$PSliceView",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",361,"^I",14,"^J",361,"^K",24,"^N","Protocol for quick view access into a row-major slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$get-major-slice-view",[["~$m","~$i"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PSliceView","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",361,"^10",["^ ","^11",["^ ","^B3",[["~$m","~$i"]]]],"^17",null,"^J",361,"^18","^19","^1:",["^8",[]],"^N","Protocol for quick view access into a row-major slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.","^[",["^P",["@interface"]]],"^@8",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",179,"^I",4,"^J",179,"^K",14,"^L","^<T","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]]],"^L","^<T","^:","~$clojure.core.matrix.protocols/row-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","^1V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",172,"^J",179,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]],"^N",null],"^=8",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",980,"^I",4,"^J",980,"^K",14,"^L","^64","^N","Return a binary array or matrix where elements of m greater-than a are\n    represented by 1 and elements less-than a are represented as 0.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-gt","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",980,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Return a binary array or matrix where elements of m greater-than a are\n    represented by 1 and elements less-than a are represented as 0."],"^2O",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",774,"^I",4,"^J",774,"^K",18,"^L","^2P","^N","Calculate cross product of two vectors, storing the result in the first vector","^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^2P","^:","~$clojure.core.matrix.protocols/cross-product!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",771,"^J",774,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Calculate cross product of two vectors, storing the result in the first vector"],"~$round!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",935,"^I",4,"^J",935,"^K",10,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/round!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",935,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^8X",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1078,"^I",4,"^J",1078,"^K",14,"^L","^3D","^N","Returns true if matrix m is symmetric","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3D","^:","~$clojure.core.matrix.protocols/symmetric?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1070,"^J",1078,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if matrix m is symmetric"],"^:4",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",901,"^I",4,"^J",901,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/asin","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",901,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$lerp",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",646,"^I",4,"^J",646,"^K",8,"^L","^<F","^N","Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor.","^O",["^P",["^Q",["^P",[["~$a","~$b","^27"]]]]]],"^L","^<F","^:","~$clojure.core.matrix.protocols/lerp","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$a","~$b","^27"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",644,"^J",646,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b","^27"]]]]],"^N","Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor."],"~$PMatrixRank",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",814,"^I",14,"^J",814,"^K",25,"^N","Protocol to support computing the rank (number of linearly independent rows) in a matrix","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^?F",[["~$m"]]]]],"^Z",true,"^:","^?G","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",814,"^10",["^ ","^11",["^ ","^?F",[["~$m"]]]],"^17",null,"^J",814,"^18","^19","^1:",["^8",[]],"^N","Protocol to support computing the rank (number of linearly independent rows) in a matrix","^[",["^P",["@interface"]]],"^5;",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1123,"^I",4,"^J",1123,"^K",15,"^L","^5=","^N","selects all elements at indices which are in the cartesian product of args","^O",["^P",["^Q",["^P",[["~$a","^5<"]]]]]],"^L","^5=","^:","~$clojure.core.matrix.protocols/select-view","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$a","^5<"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1118,"^J",1123,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","^5<"]]]]],"^N","selects all elements at indices which are in the cartesian product of args"],"~$PSetSelection",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1125,"^I",14,"^J",1125,"^K",27,"^N","Protocol for setting the elements of an array returned by (select a args) to values.\n   See the docstring for clojure.core.matrix/select for more information on possible argument values.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^;;",[["~$a","^5<","^14"]]]]],"^Z",true,"^:","^;<","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",1125,"^10",["^ ","^11",["^ ","^;;",[["~$a","^5<","^14"]]]],"^17",null,"^J",1125,"^18","^19","^1:",["^8",[]],"^N","Protocol for setting the elements of an array returned by (select a args) to values.\n   See the docstring for clojure.core.matrix/select for more information on possible argument values.","^[",["^P",["@interface"]]],"~$common-shape",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1267,"^I",7,"^J",1267,"^K",19,"^O",["^P",["^Q",["^P",[["~$shapes"]]]]],"^N","Returns the common shape that can be broadcast to from all the shapes specified,\n   or nil if such a shape does not exist."],"^:","~$clojure.core.matrix.protocols/common-shape","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["^BB"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1267,"^J",1267,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["^BB"]]]]],"^N","Returns the common shape that can be broadcast to from all the shapes specified,\n   or nil if such a shape does not exist."],"~$PTypeInfo",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",153,"^I",14,"^J",153,"^K",23,"^N","Protocol for querying the type of matrix elements. If not provided, the default implementation will\n   return java.lang.Object, and the matrix object is assumed to accept any type of value.\n   If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","~$element-type",[["~$m"]]]]],"^Z",true,"^:","~$clojure.core.matrix.protocols/PTypeInfo","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",153,"^10",["^ ","^11",["^ ","^BE",[["~$m"]]]],"^17",null,"^J",153,"^18","^19","^1:",["^8",[]],"^N","Protocol for querying the type of matrix elements. If not provided, the default implementation will\n   return java.lang.Object, and the matrix object is assumed to accept any type of value.\n   If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.","^[",["^P",["@interface"]]],"~$signum!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",936,"^I",4,"^J",936,"^K",11,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/signum!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",936,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$scale-add",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",641,"^I",4,"^J",641,"^K",13,"^L","~$clojure.core.matrix.protocols/PScaleAdd2","^N","Scales array m1 by factor b, then adds array m2 scaled by factor b, then adds the constant","^O",["^P",["^Q",["^P",[["^;D","~$a","^;E","~$b","^3W"]]]]]],"^L","^BJ","^:","~$clojure.core.matrix.protocols/scale-add","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["^;D","~$a","^;E","~$b","^3W"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",639,"^J",641,"^W",5,"^X",true,"^O",["^P",["^Q",["^P",[["^;D","~$a","^;E","~$b","^3W"]]]]],"^N","Scales array m1 by factor b, then adds array m2 scaled by factor b, then adds the constant"],"~$matrix-equals",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",500,"^I",4,"^J",500,"^K",17,"^L","~$clojure.core.matrix.protocols/PMatrixEquality","^N","Return true if a equals b, i.e. if a and b have the same shape and all elements are equal.\n     Must use numerical value comparison on numbers (==) to account for matrices that may hold a mix of\n     numercial types (e.g. java.lang.Long and java.lang.Double). Implementations that only support doubles\n     should use Number.doubleValue() to get a numeric value to compare.\n     May throw an exception if the matrices are non-numeric","^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^BM","^:","~$clojure.core.matrix.protocols/matrix-equals","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",498,"^J",500,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Return true if a equals b, i.e. if a and b have the same shape and all elements are equal.\n     Must use numerical value comparison on numbers (==) to account for matrices that may hold a mix of\n     numercial types (e.g. java.lang.Long and java.lang.Double). Implementations that only support doubles\n     should use Number.doubleValue() to get a numeric value to compare.\n     May throw an exception if the matrices are non-numeric"],"~$PSliceView2",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",370,"^I",14,"^J",370,"^K",25,"^N","Protocol for quick view access into a slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^84",[["~$m","^72","~$i"]]]]],"^Z",true,"^:","^85","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",370,"^10",["^ ","^11",["^ ","^84",[["~$m","^72","~$i"]]]],"^17",null,"^J",370,"^18","^19","^1:",["^8",[]],"^N","Protocol for quick view access into a slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.","^[",["^P",["@interface"]]],"^@;",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1086,"^I",4,"^J",1086,"^K",22,"^L","^33","^N","Returns true if the matrix is positive definite","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^33","^:","~$clojure.core.matrix.protocols/positive-definite?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1082,"^J",1086,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns true if the matrix is positive definite"],"~$add-product",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",536,"^I",4,"^J",536,"^K",15,"^L","~$clojure.core.matrix.protocols/PAddProduct","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]]],"^L","^BR","^:","~$clojure.core.matrix.protocols/add-product","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m","~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",532,"^J",536,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a","~$b"]]]]],"^N",null],"^:5",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",911,"^I",4,"^J",911,"^K",9,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/round","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",911,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^93",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",602,"^I",4,"^J",602,"^K",21,"^L","^90","^N","Transforms a vector in place - mutates the vector argument","^O",["^P",["^Q",["^P",[["~$t","~$v"]]]]]],"^L","^90","^:","~$clojure.core.matrix.protocols/vector-transform!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^T",["^P",[["~$t","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",595,"^J",602,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$t","~$v"]]]]],"^N","Transforms a vector in place - mutates the vector argument"],"^9Q",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",238,"^I",4,"^J",238,"^K",10,"^L","^7U","^N","Gets the scalar value in an 0d array.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^7U","^:","~$clojure.core.matrix.protocols/get-0d","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",232,"^J",238,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Gets the scalar value in an 0d array."],"~$PQRDecomposition",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1183,"^I",14,"^J",1183,"^K",30,"^N","Protocol for QR decomposition","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^;S",[["~$m","^4Y"]]]]],"^Z",true,"^:","^;T","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",1183,"^10",["^ ","^11",["^ ","^;S",[["~$m","^4Y"]]]],"^17",null,"^J",1183,"^18","^19","^1:",["^8",[]],"^N","Protocol for QR decomposition","^[",["^P",["@interface"]]],"^4I",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",216,"^I",4,"^J",216,"^K",16,"^L","^1S","^N","Attempts to coerce data to a dense array of implementation m. May return nil if not supported","^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]]],"^L","^1S","^:","~$clojure.core.matrix.protocols/dense-coerce","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m","^1V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",214,"^J",216,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]],"^N","Attempts to coerce data to a dense array of implementation m. May return nil if not supported"],"^;K",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",821,"^I",4,"^J",821,"^K",14,"^L","^;M","^N","Returns an array of indexed ranks, using an optional comparator","^O",["^P",["^Q",["^P",[["~$m"],["~$m","^;L"]]]]],"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","^;L"]]],"^O",["^P",[["~$m"],["~$m","^;L"]]],"^V",["^P",[null,null]]]],"^L","^;M","^:","~$clojure.core.matrix.protocols/index-rank","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","^;L"]]],"^O",["^P",[["~$m"],["~$m","^;L"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m"],["~$m","^;L"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",819,"^J",821,"^W",2,"^X",true,"^O",["^P",[["~$m"],["~$m","^;L"]]],"^N","Returns an array of indexed ranks, using an optional comparator"],"~$PTranspose",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",690,"^I",14,"^J",690,"^K",24,"^N","Protocol for array transpose operation","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^=S",[["~$m"]]]]],"^Z",true,"^:","^=T","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",690,"^10",["^ ","^11",["^ ","^=S",[["~$m"]]]],"^17",null,"^J",690,"^18","^19","^1:",["^8",[]],"^N","Protocol for array transpose operation","^[",["^P",["@interface"]]],"~$normalise",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",768,"^I",4,"^J",768,"^K",13,"^L","^?Q","^N","Returns a new vector, normalised to length 1.0","^O",["^P",["^Q",["^P",[["~$a"]]]]]],"^L","^?Q","^:","~$clojure.core.matrix.protocols/normalise","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",753,"^J",768,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$a"]]]]],"^N","Returns a new vector, normalised to length 1.0"],"~$meta-info",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",49,"^I",4,"^J",49,"^K",13,"^L","^6Q","^N","Returns optional meta-information on the implementation.\n\n     Standard keys:\n       :doc - containing a string describing an implementation","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6Q","^:","~$clojure.core.matrix.protocols/meta-info","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",40,"^J",49,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns optional meta-information on the implementation.\n\n     Standard keys:\n       :doc - containing a string describing an implementation"],"~$acos!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",924,"^I",4,"^J",924,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/acos!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",924,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^A0",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",448,"^I",4,"^J",448,"^K",11,"^L","^@O","^N","Sets all the values in an array from a given source. Source may be a scalar\n     or any smaller array that can be broadcast to the shape of m.","^O",["^P",["^Q",["^P",[["~$m","^?8"]]]]]],"^L","^@O","^:","~$clojure.core.matrix.protocols/assign!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","^?8"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",446,"^J",448,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^?8"]]]]],"^N","Sets all the values in an array from a given source. Source may be a scalar\n     or any smaller array that can be broadcast to the shape of m."],"^>E",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1106,"^I",4,"^J",1106,"^K",15,"^L","^<<","^N","Generic 'mul' function for numerical values. Must satisfy (equals x (mul one x)).","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^<<","^:","~$clojure.core.matrix.protocols/generic-mul","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1103,"^J",1106,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Generic 'mul' function for numerical values. Must satisfy (equals x (mul one x))."],"~$element-min",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",953,"^I",4,"^J",953,"^K",15,"^L","^1<","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1<","^:","~$clojure.core.matrix.protocols/element-min","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",950,"^J",953,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PScaleAdd2",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",639,"^I",14,"^J",639,"^K",24,"^N","Protocol to support the immutable scale-add! operation.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^BI",[["^;D","~$a","^;E","~$b","^3W"]]]]],"^Z",true,"^:","^BJ","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",639,"^10",["^ ","^11",["^ ","^BI",[["^;D","~$a","^;E","~$b","^3W"]]]],"^17",null,"^J",639,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the immutable scale-add! operation.","^[",["^P",["@interface"]]],"~$get-row",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",344,"^I",4,"^J",344,"^K",11,"^L","^2B","^N","Gets a row of a matrix with the given row index.","^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]]],"^L","^2B","^:","~$clojure.core.matrix.protocols/get-row","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","~$i"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",341,"^J",344,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]],"^N","Gets a row of a matrix with the given row index."],"~$PColumnIndex",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1169,"^I",14,"^J",1169,"^K",26,"^N","Protocol for getting the index of a named column. Works on any array with labelled columns.\n   If the dimensionality is 1, assumes that columns are the only dimension (i.e. can be applied to\n   dataset rows and Clojure maps in the natural way)\n   Returns an integer index if the column is found, nil otherwise.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^:[",[["~$m","^;1"]]]]],"^Z",true,"^:","^;0","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",1169,"^10",["^ ","^11",["^ ","^:[",[["~$m","^;1"]]]],"^17",null,"^J",1169,"^18","^19","^1:",["^8",[]],"^N","Protocol for getting the index of a named column. Works on any array with labelled columns.\n   If the dimensionality is 1, assumes that columns are the only dimension (i.e. can be applied to\n   dataset rows and Clojure maps in the natural way)\n   Returns an integer index if the column is found, nil otherwise.","^[",["^P",["@interface"]]],"~$sinh!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",938,"^I",4,"^J",938,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/sinh!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",938,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$native",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",211,"^I",4,"^J",211,"^K",10,"^L","^@F","^N","Attempts to coerce data to a native array of implementation m. May return nil if not supported","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^@F","^:","~$clojure.core.matrix.protocols/native","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",208,"^J",211,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Attempts to coerce data to a native array of implementation m. May return nil if not supported"],"~$logistic!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",848,"^I",4,"^J",848,"^K",13,"^L","~$clojure.core.matrix.protocols/PLogisticMutable","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^CB","^:","~$clojure.core.matrix.protocols/logistic!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",846,"^J",848,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PSoftmaxMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",870,"^I",14,"^J",870,"^K",29,"^N","Protocol to support mutable element-wise softmax function on a numerical vector.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^<7",[["~$m"]]]]],"^Z",true,"^:","^<8","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",870,"^10",["^ ","^11",["^ ","^<7",[["~$m"]]]],"^17",null,"^J",870,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable element-wise softmax function on a numerical vector.","^[",["^P",["@interface"]]],"~$PFilterSlices",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1009,"^I",14,"^J",1009,"^K",27,"^N","Filters the slices of the given array, returning only those which satisfy the given predicate.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^@K",[["~$m","~$f"]]]]],"^Z",true,"^:","^@L","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",1009,"^10",["^ ","^11",["^ ","^@K",[["~$m","~$f"]]]],"^17",null,"^J",1009,"^18","^19","^1:",["^8",[]],"^N","Filters the slices of the given array, returning only those which satisfy the given predicate.","^[",["^P",["@interface"]]],"~$PElementMinMax",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",950,"^I",14,"^J",950,"^K",28,"^N","Protocol to return the minimum and maximum elements in a numerical array. Must throw an exception\n   if the array is not numerical.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^C7",[["~$m"]],"^8R",[["~$m"]],"^1;",[["~$m","~$a","~$b"]]]]],"^Z",true,"^:","^1<","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",950,"^10",["^ ","^11",["^ ","^C7",[["~$m"]],"^8R",[["~$m"]],"^1;",[["~$m","~$a","~$b"]]]],"^17",null,"^J",950,"^18","^19","^1:",["^8",[]],"^N","Protocol to return the minimum and maximum elements in a numerical array. Must throw an exception\n   if the array is not numerical.","^[",["^P",["@interface"]]],"^4=",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1151,"^I",4,"^J",1151,"^K",19,"^L","^4?","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^4<"]]]]]],"^L","^4?","^:","~$clojure.core.matrix.protocols/index-from-ints","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m","^4<"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1145,"^J",1151,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4<"]]]]],"^N",null],"~$PAddScaledProductMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",552,"^I",14,"^J",552,"^K",38,"^N","Protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b * factor","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^?T",[["~$m","~$a","~$b","^27"]]]]],"^Z",true,"^:","^?U","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",38,"^I",1,"^H",552,"^10",["^ ","^11",["^ ","^?T",[["~$m","~$a","~$b","^27"]]]],"^17",null,"^J",552,"^18","^19","^1:",["^8",[]],"^N","Protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b * factor","^[",["^P",["@interface"]]],"^AX",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",107,"^I",4,"^J",107,"^K",10,"^L","^1M","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^3R","^2G","~$v"]]]]]],"^L","^1M","^:","~$clojure.core.matrix.protocols/set-2d","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^3R","^2G","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",102,"^J",107,"^W",4,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^3R","^2G","~$v"]]]]],"^N",null],"^?7",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",459,"^I",4,"^J",459,"^K",10,"^L","^?9","^N","Sets all the values in an array from a given source. Source may be a scalar\n     or a smaller array that can be broadcast to the shape of m.","^O",["^P",["^Q",["^P",[["~$m","^?8"]]]]]],"^L","^?9","^:","~$clojure.core.matrix.protocols/assign","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^?8"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",457,"^J",459,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^?8"]]]]],"^N","Sets all the values in an array from a given source. Source may be a scalar\n     or a smaller array that can be broadcast to the shape of m."],"^7Y",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1034,"^I",4,"^J",1034,"^K",16,"^L","^55","^N","Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error.","^O",["^P",["^Q",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]]]],"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]]],"^L","^55","^:","~$clojure.core.matrix.protocols/element-map!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^37",["^ ","^S",false,"^W",4,"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^V",["^P",[null,null,null]]],"^T",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^U",null,"^V",["^P",[null,null,null]],"^I",1,"^H",1018,"^J",1034,"^W",4,"^X",true,"^O",["^P",[["~$m","~$f"],["~$m","~$f","~$a"],["~$m","~$f","~$a","^3="]]],"^N","Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error."],"~$tanh!",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",941,"^I",4,"^J",941,"^K",9,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/tanh!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",941,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PLogisticMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",846,"^I",14,"^J",846,"^K",30,"^N","Protocol to support mutable element-wise logistic function on a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^CA",[["~$m"]]]]],"^Z",true,"^:","^CB","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",846,"^10",["^ ","^11",["^ ","^CA",[["~$m"]]]],"^17",null,"^J",846,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable element-wise logistic function on a numerical array.","^[",["^P",["@interface"]]],"^=5",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",961,"^I",4,"^J",961,"^K",19,"^L","^64","^N","Return the sign (signum) of the element-wise substraction of two scalars,\n    arrays or matrices i.e., must satisfy (signum (sub A B).","^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-compare","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",961,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Return the sign (signum) of the element-wise substraction of two scalars,\n    arrays or matrices i.e., must satisfy (signum (sub A B)."],"^45",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",423,"^I",4,"^J",423,"^K",17,"^L","^46","^N","Returns the main (leading) diagonal of a matrix.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^46","^:","~$clojure.core.matrix.protocols/main-diagonal","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",420,"^J",423,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the main (leading) diagonal of a matrix."],"~$PImplementation",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",40,"^I",14,"^J",40,"^K",29,"^N","Protocol for general implementation functionality. Required to support implementation metadata and\n   matrix construction.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^6P",[["~$m"]],"^C1",[["~$m"]],"~$construct-matrix",[["~$m","^1V"]],"^98",[["~$m","^99"]],"^7H",[["~$m","^7I","^7J"]],"^9V",[["~$m","^2V"]],"^:X",[["~$m","^:Y"]]]]],"^Z",true,"^:","^6Q","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",40,"^10",["^ ","^11",["^ ","^6P",[["~$m"]],"^C1",[["~$m"]],"^CR",[["~$m","^1V"]],"^98",[["~$m","^99"]],"^7H",[["~$m","^7I","^7J"]],"^9V",[["~$m","^2V"]],"^:X",[["~$m","^:Y"]]]],"^17",null,"^J",40,"^18","^19","^1:",["^8",[]],"^N","Protocol for general implementation functionality. Required to support implementation metadata and\n   matrix construction.","^[",["^P",["@interface"]]],"~$PZeroDimensionConstruction",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",226,"^I",14,"^J",226,"^K",40,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^3L",[["~$m"],["~$m","^3N"]]]]],"^Z",true,"^:","^3M","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",40,"^I",1,"^H",226,"^10",["^ ","^11",["^ ","^3L",[["~$m"],["~$m","^3N"]]]],"^17",null,"^J",226,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"~$PTransposeInPlace",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",726,"^I",14,"^J",726,"^K",31,"^N","Protocol for mutable 2D matrix transpose in place","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^9G",[["~$m"]]]]],"^Z",true,"^:","^9H","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",31,"^I",1,"^H",726,"^10",["^ ","^11",["^ ","^9G",[["~$m"]]]],"^17",null,"^J",726,"^18","^19","^1:",["^8",[]],"^N","Protocol for mutable 2D matrix transpose in place","^[",["^P",["@interface"]]],"~$PMutableFill",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",464,"^I",14,"^J",464,"^K",26,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^?J",[["~$m","^3N"]]]]],"^Z",true,"^:","^?K","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",26,"^I",1,"^H",464,"^10",["^ ","^11",["^ ","^?J",[["~$m","^3N"]]]],"^17",null,"^J",464,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"^?B",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",100,"^I",4,"^J",100,"^K",10,"^L","^=>","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^?C"]]]]]],"^L","^=>","^:","~$clojure.core.matrix.protocols/get-nd","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^?C"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",95,"^J",100,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^?C"]]]]],"^N",null],"^CR",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",54,"^I",4,"^J",54,"^K",20,"^L","^6Q","^N","Returns a new n-dimensional array containing the given data. data should be in the form of either\n     nested sequences or a valid existing array.\n\n     The return value should be in the preferred format of the given implementation. If the implementation\n     does not support the required dimensionality or element type then it may either:\n      - Throw an error\n      - Return nil to indicate that a default implementation should be used instead\n\n     0-dimensional arrays / scalars are permitted.","^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]]],"^L","^6Q","^:","~$clojure.core.matrix.protocols/construct-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m","^1V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",40,"^J",54,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^1V"]]]]],"^N","Returns a new n-dimensional array containing the given data. data should be in the form of either\n     nested sequences or a valid existing array.\n\n     The return value should be in the preferred format of the given implementation. If the implementation\n     does not support the required dimensionality or element type then it may either:\n      - Throw an error\n      - Return nil to indicate that a default implementation should be used instead\n\n     0-dimensional arrays / scalars are permitted."],"^:6",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",899,"^I",4,"^J",899,"^K",7,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/abs","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",7,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",899,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^2U",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",435,"^I",4,"^J",435,"^K",20,"^L","^2W","^N","Creates a new sparse array with the given shape.","^O",["^P",["^Q",["^P",[["~$m","^2V"]]]]]],"^L","^2W","^:","~$clojure.core.matrix.protocols/new-sparse-array","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m","^2V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",433,"^J",435,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2V"]]]]],"^N","Creates a new sparse array with the given shape."],"~$PAddProduct",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",532,"^I",14,"^J",532,"^K",25,"^N","Optional protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^BQ",[["~$m","~$a","~$b"]]]]],"^Z",true,"^:","^BR","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",25,"^I",1,"^H",532,"^10",["^ ","^11",["^ ","^BQ",[["~$m","~$a","~$b"]]]],"^17",null,"^J",532,"^18","^19","^1:",["^8",[]],"^N","Optional protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b","^[",["^P",["@interface"]]],"^:7",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",914,"^I",4,"^J",914,"^K",8,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/sinh","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",914,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^<L",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",701,"^I",4,"^J",701,"^K",18,"^L","^<M","^N","Returns the transpose of an array, reordering the dimensions in the specified order.","^O",["^P",["^Q",["^P",[["~$m","^52"]]]]]],"^L","^<M","^:","~$clojure.core.matrix.protocols/transpose-dims","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m","^52"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",699,"^J",701,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^52"]]]]],"^N","Returns the transpose of an array, reordering the dimensions in the specified order."],"^>1",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",586,"^I",4,"^J",586,"^K",19,"^L","^>2","^N",null,"^O",["^P",["^Q",["^P",[["~$m"],["~$m","~$a"]]]]],"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","~$a"]]],"^O",["^P",[["~$m"],["~$m","~$a"]]],"^V",["^P",[null,null]]]],"^L","^>2","^:","~$clojure.core.matrix.protocols/element-divide!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^37",["^ ","^S",false,"^W",2,"^T",["^P",[["~$m"],["~$m","~$a"]]],"^O",["^P",[["~$m"],["~$m","~$a"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m"],["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",582,"^J",586,"^W",2,"^X",true,"^O",["^P",[["~$m"],["~$m","~$a"]]],"^N",null],"^A@",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",486,"^I",4,"^J",486,"^K",19,"^L","^AA","^N","Returns the internal object array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^AA","^:","~$clojure.core.matrix.protocols/as-object-array","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",480,"^J",486,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the internal object array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array."],"~$PMathsFunctionsMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",921,"^I",14,"^J",921,"^K",36,"^N","Protocol to support mutable mathematical functions applied element-wise to a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^1>",[["~$m"]],"^4N",[["~$m"]],"^4U",[["~$m"]],"^4[",[["~$m"]],"^6S",[["~$m"]],"^7M",[["~$m"]],"^8;",[["~$m"]],"^8Y",[["~$m"]],"^9N",[["~$m"]],"^:M",[["~$m"]],"^<C",[["~$m"]],"^<[",[["~$m"]],"^=I",[["~$m"]],"^=M",[["~$m"]],"^B8",[["~$m"]],"^BG",[["~$m"]],"^C3",[["~$m"]],"^C=",[["~$m"]],"^CL",[["~$m"]],"~$floor!",[["~$m"]],"~$log10!",[["~$m"]]]]],"^Z",true,"^:","^1?","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",36,"^I",1,"^H",921,"^10",["^ ","^11",["^ ","^1>",[["~$m"]],"^4N",[["~$m"]],"^4U",[["~$m"]],"^4[",[["~$m"]],"^6S",[["~$m"]],"^7M",[["~$m"]],"^8;",[["~$m"]],"^8Y",[["~$m"]],"^9N",[["~$m"]],"^:M",[["~$m"]],"^<C",[["~$m"]],"^<[",[["~$m"]],"^=I",[["~$m"]],"^=M",[["~$m"]],"^B8",[["~$m"]],"^BG",[["~$m"]],"^C3",[["~$m"]],"^C=",[["~$m"]],"^CL",[["~$m"]],"^D4",[["~$m"]],"^D5",[["~$m"]]]],"^17",null,"^J",921,"^18","^19","^1:",["^8",[]],"^N","Protocol to support mutable mathematical functions applied element-wise to a numerical array.","^[",["^P",["@interface"]]],"^B3",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",368,"^I",4,"^J",368,"^K",24,"^L","^B4","^N","Gets a view of a major array slice","^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]]],"^L","^B4","^:","~$clojure.core.matrix.protocols/get-major-slice-view","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^T",["^P",[["~$m","~$i"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",361,"^J",368,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i"]]]]],"^N","Gets a view of a major array slice"],"^A<",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1159,"^I",4,"^J",1159,"^K",9,"^L","^8>","^N","Returns the label at a specific index along the given dimension","^O",["^P",["^Q",["^P",[["~$m","^72","~$i"]]]]]],"^L","^8>","^:","~$clojure.core.matrix.protocols/label","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m","^72","~$i"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1157,"^J",1159,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^72","~$i"]]]]],"^N","Returns the label at a specific index along the given dimension"],"^AJ",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",308,"^I",4,"^J",308,"^K",20,"^L","^AK","^N","Broadcasts and coerces a to the same shape and implementation as m","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^AK","^:","~$clojure.core.matrix.protocols/broadcast-coerce","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",304,"^J",308,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Broadcasts and coerces a to the same shape and implementation as m"],"^<P",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",339,"^I",4,"^J",339,"^K",15,"^L","^<Q","^N",null,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^<Q","^:","~$clojure.core.matrix.protocols/same-shape?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",335,"^J",339,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N",null],"^9",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",128,"^I",4,"^J",128,"^K",9,"^L","^3K","^N","Returns a clone of an array. Must be a new independent (non-view)\n              instance if the array is mutable.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3K","^:","~$clojure.core.matrix.protocols/clone","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",125,"^J",128,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns a clone of an array. Must be a new independent (non-view)\n              instance if the array is mutable."],"^A?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",482,"^I",4,"^J",482,"^K",19,"^L","^AA","^N","Returns an object array containing the values of m in row-major order. May or may not be\n     the internal object array used by m, depending on the implementation.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^AA","^:","~$clojure.core.matrix.protocols/to-object-array","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",480,"^J",482,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns an object array containing the values of m in row-major order. May or may not be\n     the internal object array used by m, depending on the implementation."],"~$PMutableCoercion",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",188,"^I",14,"^J",188,"^K",30,"^N","Protocol for coercing to a mutable format. May return the original array, if it is already fully mutable,\n   otherwise should return a fully mutable copy of the array.\n\n   Should return nil to indicate that this implementation cannot create a mutable array from the given data.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^:C",[["~$m"]]]]],"^Z",true,"^:","^:D","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",30,"^I",1,"^H",188,"^10",["^ ","^11",["^ ","^:C",[["~$m"]]]],"^17",null,"^J",188,"^18","^19","^1:",["^8",[]],"^N","Protocol for coercing to a mutable format. May return the original array, if it is already fully mutable,\n   otherwise should return a fully mutable copy of the array.\n\n   Should return nil to indicate that this implementation cannot create a mutable array from the given data.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.","^[",["^P",["@interface"]]],"^:;",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",282,"^I",4,"^J",282,"^K",16,"^L","^:=","^N","Attempts to coerce param into a matrix format supported by the implementation of matrix m.\n     May return nil if unable to do so, in which case a default implementation can be used.","^O",["^P",["^Q",["^P",[["~$m","^:<"]]]]]],"^L","^:=","^:","~$clojure.core.matrix.protocols/coerce-param","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m","^:<"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",266,"^J",282,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^:<"]]]]],"^N","Attempts to coerce param into a matrix format supported by the implementation of matrix m.\n     May return nil if unable to do so, in which case a default implementation can be used."],"^AQ",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",123,"^I",4,"^J",123,"^K",11,"^L","^3Q","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^?C","~$v"]]]]]],"^L","^3Q","^:","~$clojure.core.matrix.protocols/set-nd!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","^?C","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",118,"^J",123,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^?C","~$v"]]]]],"^N",null],"^9E",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1225,"^I",4,"^J",1225,"^K",16,"^L","^1B","^N","Returns a dataset created by combining the columns of the given datasets","^O",["^P",["^Q",["^P",[["^9C","^9D"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/join-columns","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["^9C","^9D"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1225,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["^9C","^9D"]]]]],"^N","Returns a dataset created by combining the columns of the given datasets"],"^6N",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1101,"^I",4,"^J",1101,"^K",17,"^L","^6O","^N","Generic value for a new array. Likely to be zero or nil.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6O","^:","~$clojure.core.matrix.protocols/generic-value","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1097,"^J",1101,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Generic value for a new array. Likely to be zero or nil."],"^4K",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",260,"^I",4,"^J",260,"^K",22,"^L","^4M","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^4L"]]]]]],"^L","^4M","^:","~$clojure.core.matrix.protocols/permutation-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",22,"^T",["^P",[["~$m","^4L"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",258,"^J",260,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4L"]]]]],"^N",null],"^D4",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",932,"^I",4,"^J",932,"^K",10,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/floor!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",932,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^@@",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",87,"^I",4,"^J",87,"^K",14,"^L","^6H","^N","Tests whether an object is a vector (1D array)","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6H","^:","~$clojure.core.matrix.protocols/is-vector?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",75,"^J",87,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Tests whether an object is a vector (1D array)"],"~$PVectorDistance",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",777,"^I",14,"^J",777,"^K",29,"^N",null,"^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^2X",[["~$a","~$b"]]]]],"^Z",true,"^:","^2Y","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",777,"^10",["^ ","^11",["^ ","^2X",[["~$a","~$b"]]]],"^17",null,"^J",777,"^18","^19","^1:",["^8",[]],"^N",null,"^[",["^P",["@interface"]]],"~$PMatrixColumns",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",357,"^I",14,"^J",357,"^K",28,"^N","Protocol for accessing columns of a matrix","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^=Y",[["~$m"]]]]],"^Z",true,"^:","^=Z","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",357,"^10",["^ ","^11",["^ ","^=Y",[["~$m"]]]],"^17",null,"^J",357,"^18","^19","^1:",["^8",[]],"^N","Protocol for accessing columns of a matrix","^[",["^P",["@interface"]]],"~$ensure-type",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1321,"^I",7,"^J",1321,"^K",18,"^O",["^P",["^Q",["^P",[["~$m","~$klass"]]]]],"^N","Checks if an array can contain a specified Java type, if so returns the original array, otherwise\n   returns a copy of the array that can support the specified type."],"^:","~$clojure.core.matrix.protocols/ensure-type","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m","^DG"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1321,"^J",1321,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^DG"]]]]],"^N","Checks if an array can contain a specified Java type, if so returns the original array, otherwise\n   returns a copy of the array that can support the specified type."],"^>M",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",840,"^I",4,"^J",840,"^K",10,"^L","^>N","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^>N","^:","~$clojure.core.matrix.protocols/square","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",838,"^J",840,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^AY",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",108,"^I",4,"^J",108,"^K",10,"^L","^1M","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^?C","~$v"]]]]]],"^L","^1M","^:","~$clojure.core.matrix.protocols/set-nd","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^?C","~$v"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",102,"^J",108,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^?C","~$v"]]]]],"^N",null],"^89",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",688,"^I",4,"^J",688,"^K",18,"^L","^8:","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^2V","~$f"]]]]]],"^L","^8:","^:","~$clojure.core.matrix.protocols/compute-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m","^2V","~$f"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",685,"^J",688,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2V","~$f"]]]]],"^N",null],"^99",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",764,"^I",4,"^J",764,"^K",10,"^L","^?Q","^N","Euclidian length of a vector.","^O",["^P",["^Q",["^P",[["~$a"]]]]]],"^L","^?Q","^:","~$clojure.core.matrix.protocols/length","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",753,"^J",764,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$a"]]]]],"^N","Euclidian length of a vector."],"~$PSliceViewSeq",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",397,"^I",14,"^J",397,"^K",27,"^N","Returns the row-major slice views of the array.\n\n   These must be arrays if the array is mutable, i.e. slices of a 1D vector\n   must be 0-dimensional mutable arrays.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^:@",[["~$m"]]]]],"^Z",true,"^:","^:A","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",397,"^10",["^ ","^11",["^ ","^:@",[["~$m"]]]],"^17",null,"^J",397,"^18","^19","^1:",["^8",[]],"^N","Returns the row-major slice views of the array.\n\n   These must be arrays if the array is mutable, i.e. slices of a 1D vector\n   must be 0-dimensional mutable arrays.","^[",["^P",["@interface"]]],"^7Z",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1042,"^I",4,"^J",1042,"^K",18,"^L","^55","^N","Reduces with the function f over all elements of m.\n     Implementations do not need to support clojure.core/reduced","^O",["^P",["^Q",["^P",[["~$m","~$f"],["~$m","~$f","^7["]]]]],"^37",["^ ","^S",false,"^W",3,"^T",["^P",[["~$m","~$f"],["~$m","~$f","^7["]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","^7["]]],"^V",["^P",[null,null]]]],"^L","^55","^:","~$clojure.core.matrix.protocols/element-reduce","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^37",["^ ","^S",false,"^W",3,"^T",["^P",[["~$m","~$f"],["~$m","~$f","^7["]]],"^O",["^P",[["~$m","~$f"],["~$m","~$f","^7["]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m","~$f"],["~$m","~$f","^7["]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1018,"^J",1042,"^W",3,"^X",true,"^O",["^P",[["~$m","~$f"],["~$m","~$f","^7["]]],"^N","Reduces with the function f over all elements of m.\n     Implementations do not need to support clojure.core/reduced"],"~$supports-type?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1315,"^I",7,"^J",1315,"^K",21,"^O",["^P",["^Q",["^P",[["~$m","^DG"]]]]],"^N","Checks if an array can contain a specified Java type."],"^:","~$clojure.core.matrix.protocols/supports-type?","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^T",["^P",[["~$m","^DG"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1315,"^J",1315,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^DG"]]]]],"^N","Checks if an array can contain a specified Java type."],"^:8",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",913,"^I",4,"^J",913,"^K",7,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/sin","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",7,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",913,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^=7",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",974,"^I",4,"^J",974,"^K",14,"^L","^64","^N","Return a binary array or matrix where elements of m less-than a are\n    represented by 1 and elements greater-than a are represented as 0.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-lt","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",974,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Return a binary array or matrix where elements of m less-than a are\n    represented by 1 and elements greater-than a are represented as 0."],"^>D",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1105,"^I",4,"^J",1105,"^K",15,"^L","^<<","^N","Generic 'add' function for numerical values. Must satisfy (equals x (add zero x)).","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^<<","^:","~$clojure.core.matrix.protocols/generic-add","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1103,"^J",1105,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Generic 'add' function for numerical values. Must satisfy (equals x (add zero x))."],"~$relu",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",860,"^I",4,"^J",860,"^K",8,"^L","~$clojure.core.matrix.protocols/PReLU","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^DU","^:","~$clojure.core.matrix.protocols/relu","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",8,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",858,"^J",860,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^81",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",894,"^I",4,"^J",894,"^K",14,"^L","^83","^N",null,"^O",["^P",["^Q",["^P",[["~$m","~$i","^2G"]]]]]],"^L","^83","^:","~$clojure.core.matrix.protocols/set-column","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$i","^2G"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",892,"^J",894,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$i","^2G"]]]]],"^N",null],"^9F",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1221,"^I",4,"^J",1221,"^K",18,"^L","^1B","^N","Returns a dataset created by combining columns of the given datasets. In case of columns with duplicate names, last-one-wins strategy is applied","^O",["^P",["^Q",["^P",[["^9C","^9D"]]]]]],"^L","^1B","^:","~$clojure.core.matrix.protocols/merge-datasets","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["^9C","^9D"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1215,"^J",1221,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["^9C","^9D"]]]]],"^N","Returns a dataset created by combining columns of the given datasets. In case of columns with duplicate names, last-one-wins strategy is applied"],"~$PSliceSeq",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",379,"^I",14,"^J",379,"^K",23,"^N","Returns the row-major slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.\n\n   The default implementation uses get-major-slice-view to obtain the slices.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^A7",[["~$m"]]]]],"^Z",true,"^:","^A8","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",379,"^10",["^ ","^11",["^ ","^A7",[["~$m"]]]],"^17",null,"^J",379,"^18","^19","^1:",["^8",[]],"^N","Returns the row-major slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.\n\n   The default implementation uses get-major-slice-view to obtain the slices.","^[",["^P",["@interface"]]],"^7<",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",721,"^I",4,"^J",721,"^K",13,"^L","^7=","^N","Shift along all specified dimensions as a single operation.\n\n     `shifts` may be any sequence of integer shift amounts.","^O",["^P",["^Q",["^P",[["~$m","^2?"]]]]]],"^L","^7=","^:","~$clojure.core.matrix.protocols/shift-all","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",13,"^T",["^P",[["~$m","^2?"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",716,"^J",721,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2?"]]]]],"^N","Shift along all specified dimensions as a single operation.\n\n     `shifts` may be any sequence of integer shift amounts."],"~$PMatrixEquality",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",498,"^I",14,"^J",498,"^K",29,"^N","Protocol for numerical array equality operations.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^BL",[["~$a","~$b"]]]]],"^Z",true,"^:","^BM","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",29,"^I",1,"^H",498,"^10",["^ ","^11",["^ ","^BL",[["~$a","~$b"]]]],"^17",null,"^J",498,"^18","^19","^1:",["^8",[]],"^N","Protocol for numerical array equality operations.","^[",["^P",["@interface"]]],"^6Y",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",322,"^I",4,"^J",322,"^K",11,"^L","^6Z","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^2V"]]]]]],"^L","^6Z","^:","~$clojure.core.matrix.protocols/reshape","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",11,"^T",["^P",[["~$m","^2V"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",316,"^J",322,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^2V"]]]]],"^N",null],"~$PZeroCount",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",439,"^I",14,"^J",439,"^K",24,"^N","Protocol for counting the number of zeros in a numerical array. Must return an integer value\n   representing the precise number of zeros.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^8@",[["~$m"]]]]],"^Z",true,"^:","^8A","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",439,"^10",["^ ","^11",["^ ","^8@",[["~$m"]]]],"^17",null,"^J",439,"^18","^19","^1:",["^8",[]],"^N","Protocol for counting the number of zeros in a numerical array. Must return an integer value\n   representing the precise number of zeros.","^[",["^P",["@interface"]]],"~$PMatrixDivide",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",574,"^I",14,"^J",574,"^K",27,"^N","Protocol to support element-wise division operator.\n\n   One-arg version returns the reciprocal of all elements.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^AD",[["~$m"],["~$m","~$a"]]]]],"^Z",true,"^:","^AE","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",574,"^10",["^ ","^11",["^ ","^AD",[["~$m"],["~$m","~$a"]]]],"^17",null,"^J",574,"^18","^19","^1:",["^8",[]],"^N","Protocol to support element-wise division operator.\n\n   One-arg version returns the reciprocal of all elements.","^[",["^P",["@interface"]]],"~$PLerp",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",644,"^I",14,"^J",644,"^K",19,"^N","Protocol to support the lerp linear interpolation function.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^B<",[["~$a","~$b","^27"]],"^<E",[["~$a","~$b","^27"]]]]],"^Z",true,"^:","^<F","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^I",1,"^H",644,"^10",["^ ","^11",["^ ","^B<",[["~$a","~$b","^27"]],"^<E",[["~$a","~$b","^27"]]]],"^17",null,"^J",644,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the lerp linear interpolation function.","^[",["^P",["@interface"]]],"^@?",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",78,"^I",4,"^J",78,"^K",18,"^L","^6H","^N","Returns the number of dimensions of an array, as an integer (greater than or equal to zero). ","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^6H","^:","~$clojure.core.matrix.protocols/dimensionality","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",18,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",75,"^J",78,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns the number of dimensions of an array, as an integer (greater than or equal to zero). "],"~$PNative",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",208,"^I",14,"^J",208,"^K",21,"^N","Protocol for creating and handling native arrays. Implementations must return a native format array if they\n   are able to, or nil otherwise.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^C?",[["~$m"]],"^@E",[["~$m"]]]]],"^Z",true,"^:","^@F","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^I",1,"^H",208,"^10",["^ ","^11",["^ ","^C?",[["~$m"]],"^@E",[["~$m"]]]],"^17",null,"^J",208,"^18","^19","^1:",["^8",[]],"^N","Protocol for creating and handling native arrays. Implementations must return a native format array if they\n   are able to, or nil otherwise.","^[",["^P",["@interface"]]],"~$PBLASBase",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",993,"^I",14,"^J",993,"^K",23,"^N","Base blas support.  Note that the largest differences\nfrom the C blas functions is that the return value is provided\nfirst so that the protocol machinery can work (as opposed to alpha, which\nwould often be a numeric base type).","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^>[",[["~$c","^?1","^?2","^?3","~$a","~$b","^?4"]],"^AR",[["~$c","^?1","^?3","~$a","~$b","^?4"]]]]],"^Z",true,"^:","^?0","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",23,"^I",1,"^H",993,"^10",["^ ","^11",["^ ","^>[",[["~$c","^?1","^?2","^?3","~$a","~$b","^?4"]],"^AR",[["~$c","^?1","^?3","~$a","~$b","^?4"]]]],"^17",null,"^J",993,"^18","^19","^1:",["^8",[]],"^N","Base blas support.  Note that the largest differences\nfrom the C blas functions is that the return value is provided\nfirst so that the protocol machinery can work (as opposed to alpha, which\nwould often be a numeric base type).","^[",["^P",["@interface"]]],"~$PMatrixSlices",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",341,"^I",14,"^J",341,"^K",27,"^N","Protocol to support getting slices of an array.  If implemented, must return either a view, a scalar\n   or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^C:",[["~$m","~$i"]],"^4S",[["~$m","~$i"]],"^@W",[["~$m","~$i"]],"^2A",[["~$m","^2C","~$i"]]]]],"^Z",true,"^:","^2B","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",341,"^10",["^ ","^11",["^ ","^C:",[["~$m","~$i"]],"^4S",[["~$m","~$i"]],"^@W",[["~$m","~$i"]],"^2A",[["~$m","^2C","~$i"]]]],"^17",null,"^J",341,"^18","^19","^1:",["^8",[]],"^N","Protocol to support getting slices of an array.  If implemented, must return either a view, a scalar\n   or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.","^[",["^P",["@interface"]]],"~$PIndicesAccess",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1130,"^I",14,"^J",1130,"^K",28,"^N","Protocol for getting elements of an array at the specified indices.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^A3",[["~$a","^13"]]]]],"^Z",true,"^:","^A4","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",28,"^I",1,"^H",1130,"^10",["^ ","^11",["^ ","^A3",[["~$a","^13"]]]],"^17",null,"^J",1130,"^18","^19","^1:",["^8",[]],"^N","Protocol for getting elements of an array at the specified indices.","^[",["^P",["@interface"]]],"~$PSetInnerProductMutable",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",669,"^I",14,"^J",669,"^K",37,"^N","Protocol to support the mutable set-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^:G",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]]],"^Z",true,"^:","^:H","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",37,"^I",1,"^H",669,"^10",["^ ","^11",["^ ","^:G",[["~$m","~$a","~$b"],["~$m","~$a","~$b","^27"]]]],"^17",null,"^J",669,"^18","^19","^1:",["^8",[]],"^N","Protocol to support the mutable set-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.","^[",["^P",["@interface"]]],"^71",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",708,"^I",4,"^J",708,"^K",10,"^L","^74","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^72","^73"]]]]]],"^L","^74","^:","~$clojure.core.matrix.protocols/rotate","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m","^72","^73"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",704,"^J",708,"^W",3,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^72","^73"]]]]],"^N",null],"^:9",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",912,"^I",4,"^J",912,"^K",10,"^L","^3H","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^3H","^:","~$clojure.core.matrix.protocols/signum","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",897,"^J",912,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PReLU",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",858,"^I",14,"^J",858,"^K",19,"^N","Protocol to support element-wise relu function on a numerical array.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^DT",[["~$m"]]]]],"^Z",true,"^:","^DU","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^I",1,"^H",858,"^10",["^ ","^11",["^ ","^DT",[["~$m"]]]],"^17",null,"^J",858,"^18","^19","^1:",["^8",[]],"^N","Protocol to support element-wise relu function on a numerical array.","^[",["^P",["@interface"]]],"^2H",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1167,"^I",4,"^J",1167,"^K",16,"^L","^2I","^N","Returns all labels along the columns on an array","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^2I","^:","~$clojure.core.matrix.protocols/column-names","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1162,"^J",1167,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns all labels along the columns on an array"],"^=9",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",986,"^I",4,"^J",986,"^K",14,"^L","^64","^N","Return a binary array or matrix where elements of m not-equal to a are\n    represented by 1 and elements equal to a are represented as 0.","^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]]],"^L","^64","^:","~$clojure.core.matrix.protocols/element-ne","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$m","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",959,"^J",986,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","~$a"]]]]],"^N","Return a binary array or matrix where elements of m not-equal to a are\n    represented by 1 and elements equal to a are represented as 0."],"^D5",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",934,"^I",4,"^J",934,"^K",10,"^L","^1?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^1?","^:","~$clojure.core.matrix.protocols/log10!","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",10,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",921,"^J",934,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$vector-dot",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",755,"^I",4,"^J",755,"^K",14,"^L","^?Q","^N","Numerical dot product of two vectors. Must return a scalar value if the two parameters are\n      vectors of equal length.\n\n      If the vectors are of unequal length, should throw an exception (however returning nil is\n      also acceptable).\n\n      Otherwise the implementation may optionally either return nil or compute a higher dimensional\n      inner-product (if it is able to do so).","^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^L","^?Q","^:","~$clojure.core.matrix.protocols/vector-dot","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",14,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",753,"^J",755,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^N","Numerical dot product of two vectors. Must return a scalar value if the two parameters are\n      vectors of equal length.\n\n      If the vectors are of unequal length, should throw an exception (however returning nil is\n      also acceptable).\n\n      Otherwise the implementation may optionally either return nil or compute a higher dimensional\n      inner-product (if it is able to do so)."],"^A[",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",471,"^I",4,"^J",471,"^K",19,"^L","^<0","^N","Returns a double array containing the values of m in row-major order. May or may not be\n     the internal double array used by m, depending on the implementation.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^<0","^:","~$clojure.core.matrix.protocols/to-double-array","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",19,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",469,"^J",471,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Returns a double array containing the values of m in row-major order. May or may not be\n     the internal double array used by m, depending on the implementation."],"^>F",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1108,"^I",4,"^J",1108,"^K",15,"^L","^<<","^N","Generic 'div' function for numerical values.","^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^<<","^:","~$clojure.core.matrix.protocols/generic-div","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",15,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1103,"^J",1108,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N","Generic 'div' function for numerical values."],"^4Q",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",224,"^I",4,"^J",224,"^K",20,"^L","^4R","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^4R","^:","~$clojure.core.matrix.protocols/immutable-matrix","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",219,"^J",224,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^BE",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",157,"^I",4,"^J",157,"^K",16,"^L","^BF","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^BF","^:","~$clojure.core.matrix.protocols/element-type","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",16,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",153,"^J",157,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"~$PSelect",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1113,"^I",14,"^J",1113,"^K",21,"^N","Protocol for the sel function. See the docstring for clojure.core.matrix/select for\n   more information on possible argument values.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^7>",[["~$a","^5<"]]]]],"^Z",true,"^:","^7?","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",21,"^I",1,"^H",1113,"^10",["^ ","^11",["^ ","^7>",[["~$a","^5<"]]]],"^17",null,"^J",1113,"^18","^19","^1:",["^8",[]],"^N","Protocol for the sel function. See the docstring for clojure.core.matrix/select for\n   more information on possible argument values.","^[",["^P",["@interface"]]],"^4;",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1150,"^I",4,"^J",1150,"^K",20,"^L","^4?","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^4<"]]]]]],"^L","^4?","^:","~$clojure.core.matrix.protocols/index-from-longs","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",20,"^T",["^P",[["~$m","^4<"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1145,"^J",1150,"^W",2,"^X",true,"^O",["^P",["^Q",["^P",[["~$m","^4<"]]]]],"^N",null],"~$PElementCount",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",945,"^I",14,"^J",945,"^K",27,"^N","Protocol to return the total count of elements in matrix. Result may be any integer type,\n   typically a java.lang.Long","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^:R",[["~$m"]]]]],"^Z",true,"^:","^:S","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",27,"^I",1,"^H",945,"^10",["^ ","^11",["^ ","^:R",[["~$m"]]]],"^17",null,"^J",945,"^18","^19","^1:",["^8",[]],"^N","Protocol to return the total count of elements in matrix. Result may be any integer type,\n   typically a java.lang.Long","^[",["^P",["@interface"]]],"~$PVectorOps",["^ ","^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",753,"^I",14,"^J",753,"^K",24,"^N","Protocol to support common numerical vector operations.","^Z",true,"^[",["^P",["@interface"]],"^10",["^ ","^11",["^ ","^E@",[["~$a","~$b"]],"^99",[["~$a"]],"^?P",[["~$a"]],"^B[",[["~$a"]]]]],"^Z",true,"^:","^?Q","^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",24,"^I",1,"^H",753,"^10",["^ ","^11",["^ ","^E@",[["~$a","~$b"]],"^99",[["~$a"]],"^?P",[["~$a"]],"^B[",[["~$a"]]]],"^17",null,"^J",753,"^18","^19","^1:",["^8",[]],"^N","Protocol to support common numerical vector operations.","^[",["^P",["@interface"]]],"^4:",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",1149,"^I",4,"^J",1149,"^K",17,"^L","^4?","^N",null,"^O",["^P",["^Q",["^P",[["~$m"]]]]]],"^L","^4?","^:","~$clojure.core.matrix.protocols/index-to-ints","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",17,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",1145,"^J",1149,"^W",1,"^X",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^N",null],"^52",["^ ","^E",null,"^F",["^ ","^G","/home/pedro/github/unicycle/resources/public/js/clojure/core/matrix/protocols.cljc","^H",743,"^I",4,"^J",743,"^K",9,"^L","^53","^N",null,"^O",["^P",["^Q",["^P",[["~$m","^13"],["~$m","^2C","^13"]]]]],"^37",["^ ","^S",false,"^W",3,"^T",["^P",[["~$m","^13"],["~$m","^2C","^13"]]],"^O",["^P",[["~$m","^13"],["~$m","^2C","^13"]]],"^V",["^P",[null,null]]]],"^L","^53","^:","~$clojure.core.matrix.protocols/order","^S",false,"^G","resources/public/js/clojure/core/matrix/protocols.cljc","^K",9,"^37",["^ ","^S",false,"^W",3,"^T",["^P",[["~$m","^13"],["~$m","^2C","^13"]]],"^O",["^P",[["~$m","^13"],["~$m","^2C","^13"]]],"^V",["^P",[null,null]]],"^T",["^P",[["~$m","^13"],["~$m","^2C","^13"]]],"^U",null,"^V",["^P",[null,null]],"^I",1,"^H",731,"^J",743,"^W",3,"^X",true,"^O",["^P",[["~$m","^13"],["~$m","^2C","^13"]]],"^N",null]],"~:require-macros",["^ ","^6","^6","^?","^@","^@","^@"],"~:cljs.analyzer/constants",["^ ","~:seen",["^8",["~:default"]],"~:order",["^EO"]],"^N","Namespace for core.matrix protocols. These protocols are intended to be implemented by\n   core.matrix array implementations.\n\n   Note to implementers:\n    - Please read the docstrings for the protocols you are implementing!\n    - Protocols should be implemented correctly to achieve a compliant core.matrix implementations\n\n   core.matrix users should normally avoid using this namespace directly\n   and instead use the functions in the main clojure.core.matrix API"]